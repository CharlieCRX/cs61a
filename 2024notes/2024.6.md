6月份收尾工作

## 6.3

> 时间记录
>
> 10：35-11：08 背单词
>
> 11：12 - 12：29 hw08
>
> 15:18 - 15:58 阅读lab10题目
>
> 15:58 -16：30 阅读3.4部分代码

这周的目标

- 周五晚上12点之前，阅读完毕《大话设计模式》和《上帝掷骰子吗》
- 跑量50km
- cs61a的13周和14周课程，截至时间是周四晚上12点之前
- csapp：截止到周四，完结architecture lab

**3.4阅读摘要：**

- expressions ：primitive(int or float) and call(operator and operand)
- parsing expression:**Lexical analysis.**and**Syntactic analysis**
  - Lexical analysis:将输入的字符串转换为标识符
  - Syntactic analysis：将标识符转换为表达式树（pair实现）

今晚安排：吃饭+csapp的第四章图例+代码阅读+跑步10km+lab10代码抄一遍

## 6.4

今天开始，记录下自己csapp第四章的学习过程。

这是我正式脱离中文材料，拥抱英文材料的开始。第四章本身难度高，所以担心自己三天打鱼两天晒网，索性在这里记录下自己的学习过程，以此激励自己不断向前进发。今天是周二，预计周五晚上12点之前，能写完第四章lab。

没什么要说的，就是干。遇到问题请及时记录，杜绝无意义消耗。

17:05 - 17:29：阅读4.1节，了解y86的指令集编码格式，`OPq rA, rB`只能是寄存器之间参与运算，y86寄存器的编码，Y86和X86汇编语言的差异，`andq`用来判断是否为0

17:40 - 18:07：阅读4.2.1-4.2.3，了解了如何从最小的逻辑门上升到word-level的组合电路。

18:13 - 18:44：用HCL的case expression来描述函数输入输出；时钟信号上升时，才将数据保存到寄存器和内存；将指令化解为阶段操作

## 6.5

14:13 - 14:39 搞明白了`rrmovq rA, D(rB)`中的`valC`赋值来源

14:45 - 15:10 通过前辈的architecture lab记录，发现需要认真学习seq实现和流水线的相关设计；学习了指令`popq`、`pushq`和`call`的具体执行流程。

15:16 - 15:41问题：4.25的图示什么意思？学习了流水线对于指令的优势就是增大吞吐量，随之而来的负面影响就是增大延迟；时钟的上升沿会将指令从流水线的一个阶段转换到另一个阶段。

16:46 - 16:06 学习设计流水线的原则以及流水线的缺陷（不统一的时间片、过度分块导致时间开销大）

## 6.6

cs61a

10:24 - 10:54

学习了lab10的`calc_apply`的流程设计。

```python
def calc_eval(exp):
    """
    >>> calc_eval(Pair("define", Pair("a", Pair(1, nil))))
    'a'
    >>> calc_eval("a")
    1
    >>> calc_eval(Pair("+", Pair(1, Pair(2, nil))))
    3
    """
    if isinstance(exp, Pair):
        operator = exp.first
        operands = exp.rest
        if operator == 'and': # and expressions
            return eval_and(operands)
        elif operator == 'define': # define expressions
            return eval_define(operands)
        else: # Call expressions
            return calc_apply(calc_eval(operator), operands.map(calc_eval))
    elif exp in OPERATORS:   # Looking up procedures
        return OPERATORS[exp]
    elif isinstance(exp, int) or isinstance(exp, bool):   # Numbers and booleans
        return exp
    elif exp in bindings:   # Looking up variables
        return bindings[exp]
```

`calc_apply(calc_eval(operator), operands.map(calc_eval))`：

如果操作符不是`and`和`define`的话，就将操作符应用于剩余的操作数上。其中的`map`方法，是将方法`calc_eval`应用到操作数上。`map`的实现如下：

```python
def map(self, fn):
    """Return a Scheme list after mapping Python function FN to SELF."""
    mapped = fn(self.first)  # 应用函数 fn 到当前 Pair 对象的 first 元素
    if self.rest is nil or isinstance(self.rest, Pair):
        # 如果 rest 是 nil 或另一个 Pair 对象，递归调用 map 方法
        return Pair(mapped, self.rest.map(fn))
    else:
        # 如果 rest 不是 nil 或 Pair 对象，抛出类型错误
        raise TypeError('ill-formed list')
```

`map` 方法通过递归的方式将给定函数 `fn` 应用于 `Pair` 对象中的每个元素，并返回一个新的 `Pair` 列表。具体步骤如下：

1. 将函数 `fn` 应用于 `Pair` 对象的 `first` 元素。
2. 递归调用 `map` 方法对 `rest` 进行相同操作。

## 6.7

9:29 - 10:06

两个有趣的递归函数`reduce`和`as_scheme_list`：

```py
def reduce(fn, scheme_list, start):
    """Reduce a recursive list of Pairs using fn and a start value.

    >>> reduce(add, as_scheme_list(1, 2, 3), 0)
    6
    """
    if scheme_list is nil:
        return start
    return reduce(fn, scheme_list.second, fn(start, scheme_list.first))

def as_scheme_list(*args):
    """Return a recursive list of Pairs that contains the elements of args.

    >>> as_scheme_list(1, 2, 3)
    Pair(1, Pair(2, Pair(3, nil)))
    """
    if len(args) == 0:
        return nil
    return Pair(args[0], as_scheme_list(*args[1:]))
```

10:15 - 10:53

- For Calculator, the only two legal syntactic forms of expressions are numbers and call expressions, which are `Pair` instances representing well-formed Scheme lists.

woc，答案通道关闭了！在github上搜索cs61a，发现了[答案](https://github.com/t0matoOtk/CS61A-sp24/tree/master)，在这里感谢分享！

11:09 

开始今天的macros学习：

- define的困境：

  ```py
  def swap(x, y):
      t = x
      x = y
      y = t
  
  x = 1
  y = 2 
  swap(x, y)
  ```

  在 Python 中，函数参数是按值传递的，这意味着函数内部对参数的赋值不会影响函数外部的变量。因此，`swap` 函数不能交换函数外部变量 `x` 和 `y` 的值。值的变化只在函数内部有效。

- Python 语言设计强调简单和可读性，因此控制结构是内置的、语法固定的，无法像一些其他语言那样定义新的控制构造。

- macros的特点：

  - `#define BLUE 3`：3被标识符`BLUE`所替代表示
  - `#define fun1 fun2`定义函数，相当于扩展了函数`fun1`的表达

- macros和function的区别：

  - 不计算参数的值
  - 宏在编译时（或解释时）执行，用来生成和返回新的代码。这段代码然后被插入到调用宏的地方，并在运行时执行。
  - 函数主要用于抽象和重用代码逻辑，在运行时执行。而宏用于生成代码，在编译时执行，允许创建新的控制结构和扩展语言语法。

- `quasiquote`（反引用）和 `unquote`（取消反引用）

  - 当我们使用反引用包围一个表达式时，表达式中的所有内容默认不求值，除非用逗号`,`标记的部分会被求值。如果在反引用中再次使用反引用，那么它会继续保持不求值，直到取消反引用 , 被显式使用为止(todolist 理解macros - 611)

## 6.11

`quasiquote` 和 `unquote` 的基本用法：

- `quasiquote`：反引号表示，包围的表达式生成一个模板，其中所有子表达式默认不求值
- `unquote`：取消反引用，在 `quasiquote` 环境中标记的子表达式会被求值，其结果插入到模板中

分析代码：

```scheme
(define a 10)
(define b 20)
(define c 30)
`(list ,a `b ,c)  ; 结果是 (list 10 (quasiquote 20) 30)
```

为什么结果为`(list 10 (quasiquote 20) 30)`:

反引用包围一个表达式时，表达式中的所有内容默认不求值，除非用逗号`,`标记的部分会被求值。如果在反引用中再次使用反引用，那么它会继续保持不求值，直到使用取消反引用`,`来对表达式求值。

在这个问题中，b处在反引用中，并且又在反引用中嵌套了反引用，此时嵌套的反引用表示生成一个新的反引用表达式，其中b被保留为符号，不求值。

分析函数`(curry-consume curry args)`：

```scheme
(define (curry-consume curry args)
  (if (null? args)
      curry
      (curry-consume (curry (car args)) (cdr args))))
```

**参数说明**:

- `curry`：一个柯里化函数。
- `args`：一个包含多个参数的列表，将依次应用到 `curry` 函数上。

**基本逻辑**:

- 如果 `args` 列表为空，则表示所有参数都已经应用完毕，此时 `curry` 不再是一个函数，而是最终的结果，返回这个结果。
- 否则，取出 `args` 的第一个元素，将其应用到 `curry` 函数上，然后递归地处理剩余的参数。

单引号和反引号的区别：

- 单引号（`'`）和反引号（```）都用于创建符号或列表
- 单引号用于创建一个符号（symbol）或一个未经求值的列表。使用单引号可以告诉解释器不要对表达式求值，而是将其作为数据处理。
- 反引号（也称为“准引用”或“quasiquote”）用于创建一个模板，其中某些部分可以被求值。反引号允许你在一个模板中包含一些需要求值的部分，这些部分用逗号（`,`）表示。反引号主要用于生成列表和嵌套的结构。

hw09学习记录：

- 学习语法：多分支选择函数`cond`、构造对函数`cons`、单引号和反引号的用途
- curry：学到了柯里化函数最终参数为空的话，就会返回一个值

经验：

- 做题慢直接找答案分析答案：因为背景知识不够，像是hw09中的Q2和Q3，需要对scheme一些语法和curry函数理解到一定程度才可解决
- 没事多chatgpt

csapp学习总结：

- 确认chapter4学习路线：instructions、digital design、sequential、pipelined
- study tools：y86 assembler、simulator of running y86 programs、simulators for sequential and pipelined
- ISA implementation:stat、instructions and endcoding、conventions、except
- memory reference：stop second register or scaling of a register value

## 6.12

csapp：

9:50 - 10:20(y86 instruction)

- 单寄存器操作指令（类似`irmovq`）的另一个不用的寄存器设置为`0xF`：indicates the absence of a register operand
- constant word：immediate data、displacement、destination（serve as absolute address）
- all integers have a little-endian encoding:normal instructions and reverse integer encoding
- byte encodings have the property of unique interpretation

10:30 - 11:44 (exception and program)

- start at address 0
- assembler for y86:YAS
- YIS:model the y86 instructions
- what does the instruction `pushq %rsp` do？
- Why worry about such picky details?

学习总结：

- 整数编码保持小端序
- Y86指令开始地址为0

cs61a([Lab 11: Programs as Data, Macros](https://cs61a.org/lab/lab11/))：

15:30 - 16：56

- `begin` 语法用于顺序执行多个表达式，并返回最后一个表达式的值

- 阶乘：

  ```scheme
  (define (pow-expr base exp)
    (cond ((= exp 0) 1)
      ((= exp 1) `(* ,base 1))
      ((odd? exp) `(* ,base ,(pow-expr base (- exp 1))))
      (else `(square ,(pow-expr base (/ exp 2))))
    )
  )
  ```

  取消引用`,`用于计算表达式或者引用值。计算表达式的时候，需要放在括号前面。

总结：

- 完结lab11
- 学习了关于如何反引用和取消引用的方法

## 6.13

cs61a开始scheme项目

Q1：实现`scheme_classes.py`中的`define` and `lookup` methods

Q2：complete `BuiltinProcedure` in `scheme_apply`

Q3： `scheme_eval`

Q4：在`scheme_forms.py`中的`do_define_form` 方法

Q5：Implement the `do_quote_form` function in `scheme_forms.py` so that it simply returns the unevaluated operand of the `(quote ...)` expression.

需要重点实现这几个函数和功能，下午开始看代码，做好注释理解。

现在回去吃饭，下午完成csapp的4.1习题，买支红笔。

## 6.14

cs61a 10:33 - 

In Part 1, you will develop the following features of the interpreter:

- Symbol evaluation
- Calling built-in procedures
- Definition

## 6.15

装饰器（decorator）是一种高级功能，允许在不修改原函数定义的情况下扩展或修改函数的行为。装饰器本质上是一个可调用对象（通常是函数），它接受一个函数作为参数，并返回一个新函数或修改后的函数。

> Q2
>
> Your implementation should do the following:
>
> - Convert the Scheme list to a Python list of arguments. *Hint:* `args` is a `Pair`, which has a `.first` and `.rest` attribute.
> - If `procedure.need_env` is `True`, then add the current environment `env` as the last argument to this Python list.
> - Return the result of calling `procedure.py_func` on all of those arguments. Use `*args` notation: `f(1, 2, 3)` is equivalent to `f(*[1, 2, 3]`). Do this part within the `try` statement provided, after the line that says `try:`.

Q2：

- 如何将pair类型的参数(1 2 3 4)转换为python的list数据？

## 6.17

目标是将scheme项目搞懂。

12:34 - 

- symbol evaluation:当解释器遇到一个符号时，它会在当前环境（environment）中查找这个符号的绑定值。如果找不到该符号，就会报错。

scheme的原子操作：

```python
def scheme_atomp(x):
    return (scheme_booleanp(x) or scheme_numberp(x) or scheme_symbolp(x) or
            scheme_nullp(x) or scheme_stringp(x))
```

分析`Frame`的具体实现：

```py
class Frame:
    """An environment frame binds Scheme symbols to Scheme values."""

    def __init__(self, parent):
        """An empty frame with parent frame PARENT (which may be None)."""
        self.bindings = {}
        self.parent = parent

    def __repr__(self):
        if self.parent is None:
            return '<Global Frame>'
        s = sorted(['{0}: {1}'.format(k, v) for k, v in self.bindings.items()])
        return '<{{{0}}} -> {1}>'.format(', '.join(s), repr(self.parent))

    def define(self, symbol, value):
        """Define Scheme SYMBOL to have VALUE."""
        # BEGIN PROBLEM 1
        "*** YOUR CODE HERE ***"
        self.bindings[symbol] = value
        # END PROBLEM 1

    def lookup(self, symbol):
        """Return the value bound to SYMBOL. Errors if SYMBOL is not found."""
        # BEGIN PROBLEM 1
        "*** YOUR CODE HERE ***"
        if symbol in self.bindings:
            return self.bindings[symbol]
        elif self.parent is not None:
            return self.parent.lookup(symbol)
        else:
        # END PROBLEM 1
            raise SchemeError('unknown identifier: {0}'.format(symbol))
```

其中的`__repr__`函数详解：`__repr__` 方法用于返回一个对象的字符串表示形式

```py
    def __repr__(self):
        if self.parent is None:
            return '<Global Frame>'
        s = sorted(['{0}: {1}'.format(k, v) for k, v in self.bindings.items()])
        return '<{{{0}}} -> {1}>'.format(', '.join(s), repr(self.parent))
```

1. 检查是否全局框架

   ```py
   if self.parent is None:
               return '<Global Frame>'
   ```

2. 生成当前框架的绑定字符串

   ```py
   s = sorted(['{0}: {1}'.format(k, v) for k, v in self.bindings.items()])
   ```

   `for k, v in self.bindings.items()`: 这是一个列表推导式，用于遍历 `self.bindings.items()` 视图中的每个键值对。

   `'{0}: {1}'.format(k, v)` 是字符串的格式化操作，用于将变量 `k` 和 `v` 的值填充到字符串模板中的占位符 `{0}` 和 `{1}` 中。

   - `{0}` 表示字符串模板中的第一个占位符，用来表示要格式化的第一个参数。

   - `{1}` 表示字符串模板中的第二个占位符，用来表示要格式化的第二个参数。

   举例格式化字符串的用法：

   格式化字符串是指在编程中用于动态构建字符串的一种技术。它允许将变量、表达式或其他字符串的值插入到一个固定的字符串模板中，从而生成最终的字符串输出。

   - `str.format`：通过占位符 `{}` 指定要插入的变量值。

   ```py
   name = 'Alice'
   age = 30
   print('My name is {} and I am {} years old.'.format(name, age))
   ```

   这样输出的结果就是`My name is Alice and I am 30 years old.`

   - 使用 `f-strings`（格式化字符串字面值）

   ```py
   name = 'Charlie'
   age = 35
   print(f'My name is {name} and I am {age} years old.')
   ```

   两个方法效果相同。

3. 返回格式化的框架字符串：

   ```py
   return '<{{{0}}} -> {1}>'.format(', '.join(s), repr(self.parent))
   ```

   `', '.join(s)` 表示将列表 `s` 中的字符串用逗号和空格连接起来，然后作为第一个参数

   `repr(self.parent)` 则表示获取 `self.parent` 对象的表示形式，作为第二个参数。

   这两个参数分别替换了格式化字符串中的 `{0}` 和 `{1}`。

   整个字符串格式为 `'<{current_frame_bindings} -> {parent_frame_repr}>'`

通过这种方式，`__repr__` 方法可以清晰地展示每个框架的内容及其与父框架的关系，使得调试和理解代码变得更加容易。

```python
# 创建一个 Frame 对象
parent_frame = Frame(None)
child_frame = Frame(parent_frame)
child_frame.define('x', 10)
child_frame.define('y', 20)

# 打印 Frame 对象的表示形式
print(repr(child_frame))
```

这样打印的结果即为：

```python
<{x: 10, y: 20} -> <Global Frame>>
```

在Frame框架中，学习到了：

- 字符串的格式化操作：将变量数据放到特定字符串中的方法
- `format`：占位符和对应参数的关系
- `coma.join(iter_list)`：将一个列表的字符串用`coma`连结起来。
- 获取字典的列表方法：`dict.items()`用于获取字典中所有键值对的视图

## 6.18



