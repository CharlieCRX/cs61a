6月份收尾工作

## 6.3

> 时间记录
>
> 10：35-11：08 背单词
>
> 11：12 - 12：29 hw08
>
> 15:18 - 15:58 阅读lab10题目
>
> 15:58 -16：30 阅读3.4部分代码

这周的目标

- 周五晚上12点之前，阅读完毕《大话设计模式》和《上帝掷骰子吗》
- 跑量50km
- cs61a的13周和14周课程，截至时间是周四晚上12点之前
- csapp：截止到周四，完结architecture lab

**3.4阅读摘要：**

- expressions ：primitive(int or float) and call(operator and operand)
- parsing expression:**Lexical analysis.**and**Syntactic analysis**
  - Lexical analysis:将输入的字符串转换为标识符
  - Syntactic analysis：将标识符转换为表达式树（pair实现）

今晚安排：吃饭+csapp的第四章图例+代码阅读+跑步10km+lab10代码抄一遍

## 6.4

今天开始，记录下自己csapp第四章的学习过程。

这是我正式脱离中文材料，拥抱英文材料的开始。第四章本身难度高，所以担心自己三天打鱼两天晒网，索性在这里记录下自己的学习过程，以此激励自己不断向前进发。今天是周二，预计周五晚上12点之前，能写完第四章lab。

没什么要说的，就是干。遇到问题请及时记录，杜绝无意义消耗。

17:05 - 17:29：阅读4.1节，了解y86的指令集编码格式，`OPq rA, rB`只能是寄存器之间参与运算，y86寄存器的编码，Y86和X86汇编语言的差异，`andq`用来判断是否为0

17:40 - 18:07：阅读4.2.1-4.2.3，了解了如何从最小的逻辑门上升到word-level的组合电路。

18:13 - 18:44：用HCL的case expression来描述函数输入输出；时钟信号上升时，才将数据保存到寄存器和内存；将指令化解为阶段操作

## 6.5

14:13 - 14:39 搞明白了`rrmovq rA, D(rB)`中的`valC`赋值来源

14:45 - 15:10 通过前辈的architecture lab记录，发现需要认真学习seq实现和流水线的相关设计；学习了指令`popq`、`pushq`和`call`的具体执行流程。

15:16 - 15:41问题：4.25的图示什么意思？学习了流水线对于指令的优势就是增大吞吐量，随之而来的负面影响就是增大延迟；时钟的上升沿会将指令从流水线的一个阶段转换到另一个阶段。

16:46 - 16:06 学习设计流水线的原则以及流水线的缺陷（不统一的时间片、过度分块导致时间开销大）

## 6.6

cs61a

10:24 - 10:54

学习了lab10的`calc_apply`的流程设计。

```python
def calc_eval(exp):
    """
    >>> calc_eval(Pair("define", Pair("a", Pair(1, nil))))
    'a'
    >>> calc_eval("a")
    1
    >>> calc_eval(Pair("+", Pair(1, Pair(2, nil))))
    3
    """
    if isinstance(exp, Pair):
        operator = exp.first
        operands = exp.rest
        if operator == 'and': # and expressions
            return eval_and(operands)
        elif operator == 'define': # define expressions
            return eval_define(operands)
        else: # Call expressions
            return calc_apply(calc_eval(operator), operands.map(calc_eval))
    elif exp in OPERATORS:   # Looking up procedures
        return OPERATORS[exp]
    elif isinstance(exp, int) or isinstance(exp, bool):   # Numbers and booleans
        return exp
    elif exp in bindings:   # Looking up variables
        return bindings[exp]
```

`calc_apply(calc_eval(operator), operands.map(calc_eval))`：

如果操作符不是`and`和`define`的话，就将操作符应用于剩余的操作数上。其中的`map`方法，是将方法`calc_eval`应用到操作数上。`map`的实现如下：

```python
def map(self, fn):
    """Return a Scheme list after mapping Python function FN to SELF."""
    mapped = fn(self.first)  # 应用函数 fn 到当前 Pair 对象的 first 元素
    if self.rest is nil or isinstance(self.rest, Pair):
        # 如果 rest 是 nil 或另一个 Pair 对象，递归调用 map 方法
        return Pair(mapped, self.rest.map(fn))
    else:
        # 如果 rest 不是 nil 或 Pair 对象，抛出类型错误
        raise TypeError('ill-formed list')
```

`map` 方法通过递归的方式将给定函数 `fn` 应用于 `Pair` 对象中的每个元素，并返回一个新的 `Pair` 列表。具体步骤如下：

1. 将函数 `fn` 应用于 `Pair` 对象的 `first` 元素。
2. 递归调用 `map` 方法对 `rest` 进行相同操作。

