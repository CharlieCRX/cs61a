6月份收尾工作

## 6.3

> 时间记录
>
> 10：35-11：08 背单词
>
> 11：12 - 12：29 hw08
>
> 15:18 - 15:58 阅读lab10题目
>
> 15:58 -16：30 阅读3.4部分代码

这周的目标

- 周五晚上12点之前，阅读完毕《大话设计模式》和《上帝掷骰子吗》
- 跑量50km
- cs61a的13周和14周课程，截至时间是周四晚上12点之前
- csapp：截止到周四，完结architecture lab

**3.4阅读摘要：**

- expressions ：primitive(int or float) and call(operator and operand)
- parsing expression:**Lexical analysis.**and**Syntactic analysis**
  - Lexical analysis:将输入的字符串转换为标识符
  - Syntactic analysis：将标识符转换为表达式树（pair实现）

今晚安排：吃饭+csapp的第四章图例+代码阅读+跑步10km+lab10代码抄一遍

## 6.4

今天开始，记录下自己csapp第四章的学习过程。

这是我正式脱离中文材料，拥抱英文材料的开始。第四章本身难度高，所以担心自己三天打鱼两天晒网，索性在这里记录下自己的学习过程，以此激励自己不断向前进发。今天是周二，预计周五晚上12点之前，能写完第四章lab。

没什么要说的，就是干。遇到问题请及时记录，杜绝无意义消耗。

17:05 - 17:29：阅读4.1节，了解y86的指令集编码格式，`OPq rA, rB`只能是寄存器之间参与运算，y86寄存器的编码，Y86和X86汇编语言的差异，`andq`用来判断是否为0

17:40 - 18:07：阅读4.2.1-4.2.3，了解了如何从最小的逻辑门上升到word-level的组合电路。

18:13 - 18:44：用HCL的case expression来描述函数输入输出；时钟信号上升时，才将数据保存到寄存器和内存；将指令化解为阶段操作

## 6.5

14:13 - 14:39 搞明白了`rrmovq rA, D(rB)`中的`valC`赋值来源

14:45 - 15:10 通过前辈的architecture lab记录，发现需要认真学习seq实现和流水线的相关设计；学习了指令`popq`、`pushq`和`call`的具体执行流程。

15:16 - 15:41问题：4.25的图示什么意思？学习了流水线对于指令的优势就是增大吞吐量，随之而来的负面影响就是增大延迟；时钟的上升沿会将指令从流水线的一个阶段转换到另一个阶段。

16:46 - 16:06 学习设计流水线的原则以及流水线的缺陷（不统一的时间片、过度分块导致时间开销大）

## 6.6

cs61a

10:24 - 10:54

学习了lab10的`calc_apply`的流程设计。

```python
def calc_eval(exp):
    """
    >>> calc_eval(Pair("define", Pair("a", Pair(1, nil))))
    'a'
    >>> calc_eval("a")
    1
    >>> calc_eval(Pair("+", Pair(1, Pair(2, nil))))
    3
    """
    if isinstance(exp, Pair):
        operator = exp.first
        operands = exp.rest
        if operator == 'and': # and expressions
            return eval_and(operands)
        elif operator == 'define': # define expressions
            return eval_define(operands)
        else: # Call expressions
            return calc_apply(calc_eval(operator), operands.map(calc_eval))
    elif exp in OPERATORS:   # Looking up procedures
        return OPERATORS[exp]
    elif isinstance(exp, int) or isinstance(exp, bool):   # Numbers and booleans
        return exp
    elif exp in bindings:   # Looking up variables
        return bindings[exp]
```

`calc_apply(calc_eval(operator), operands.map(calc_eval))`：

如果操作符不是`and`和`define`的话，就将操作符应用于剩余的操作数上。其中的`map`方法，是将方法`calc_eval`应用到操作数上。`map`的实现如下：

```python
def map(self, fn):
    """Return a Scheme list after mapping Python function FN to SELF."""
    mapped = fn(self.first)  # 应用函数 fn 到当前 Pair 对象的 first 元素
    if self.rest is nil or isinstance(self.rest, Pair):
        # 如果 rest 是 nil 或另一个 Pair 对象，递归调用 map 方法
        return Pair(mapped, self.rest.map(fn))
    else:
        # 如果 rest 不是 nil 或 Pair 对象，抛出类型错误
        raise TypeError('ill-formed list')
```

`map` 方法通过递归的方式将给定函数 `fn` 应用于 `Pair` 对象中的每个元素，并返回一个新的 `Pair` 列表。具体步骤如下：

1. 将函数 `fn` 应用于 `Pair` 对象的 `first` 元素。
2. 递归调用 `map` 方法对 `rest` 进行相同操作。

## 6.7

9:29 - 10:06

两个有趣的递归函数`reduce`和`as_scheme_list`：

```py
def reduce(fn, scheme_list, start):
    """Reduce a recursive list of Pairs using fn and a start value.

    >>> reduce(add, as_scheme_list(1, 2, 3), 0)
    6
    """
    if scheme_list is nil:
        return start
    return reduce(fn, scheme_list.second, fn(start, scheme_list.first))

def as_scheme_list(*args):
    """Return a recursive list of Pairs that contains the elements of args.

    >>> as_scheme_list(1, 2, 3)
    Pair(1, Pair(2, Pair(3, nil)))
    """
    if len(args) == 0:
        return nil
    return Pair(args[0], as_scheme_list(*args[1:]))
```

10:15 - 10:53

- For Calculator, the only two legal syntactic forms of expressions are numbers and call expressions, which are `Pair` instances representing well-formed Scheme lists.

woc，答案通道关闭了！在github上搜索cs61a，发现了[答案](https://github.com/t0matoOtk/CS61A-sp24/tree/master)，在这里感谢分享！

11:09 

开始今天的macros学习：

- define的困境：

  ```py
  def swap(x, y):
      t = x
      x = y
      y = t
  
  x = 1
  y = 2 
  swap(x, y)
  ```

  在 Python 中，函数参数是按值传递的，这意味着函数内部对参数的赋值不会影响函数外部的变量。因此，`swap` 函数不能交换函数外部变量 `x` 和 `y` 的值。值的变化只在函数内部有效。

- Python 语言设计强调简单和可读性，因此控制结构是内置的、语法固定的，无法像一些其他语言那样定义新的控制构造。

- macros的特点：

  - `#define BLUE 3`：3被标识符`BLUE`所替代表示
  - `#define fun1 fun2`定义函数，相当于扩展了函数`fun1`的表达

- macros和function的区别：

  - 不计算参数的值
  - 宏在编译时（或解释时）执行，用来生成和返回新的代码。这段代码然后被插入到调用宏的地方，并在运行时执行。
  - 函数主要用于抽象和重用代码逻辑，在运行时执行。而宏用于生成代码，在编译时执行，允许创建新的控制结构和扩展语言语法。

- `quasiquote`（反引用）和 `unquote`（取消反引用）

  - 当我们使用反引用包围一个表达式时，表达式中的所有内容默认不求值，除非用逗号`,`标记的部分会被求值。如果在反引用中再次使用反引用，那么它会继续保持不求值，直到取消反引用 , 被显式使用为止(todolist 理解macros - 611)

## 6.11

`quasiquote` 和 `unquote` 的基本用法：

- `quasiquote`：反引号表示，包围的表达式生成一个模板，其中所有子表达式默认不求值
- `unquote`：取消反引用，在 `quasiquote` 环境中标记的子表达式会被求值，其结果插入到模板中

分析代码：

```scheme
(define a 10)
(define b 20)
(define c 30)
`(list ,a `b ,c)  ; 结果是 (list 10 (quasiquote 20) 30)
```

为什么结果为`(list 10 (quasiquote 20) 30)`:

反引用包围一个表达式时，表达式中的所有内容默认不求值，除非用逗号`,`标记的部分会被求值。如果在反引用中再次使用反引用，那么它会继续保持不求值，直到使用取消反引用`,`来对表达式求值。

在这个问题中，b处在反引用中，并且又在反引用中嵌套了反引用，此时嵌套的反引用表示生成一个新的反引用表达式，其中b被保留为符号，不求值。

分析函数`(curry-consume curry args)`：

```scheme
(define (curry-consume curry args)
  (if (null? args)
      curry
      (curry-consume (curry (car args)) (cdr args))))
```

**参数说明**:

- `curry`：一个柯里化函数。
- `args`：一个包含多个参数的列表，将依次应用到 `curry` 函数上。

**基本逻辑**:

- 如果 `args` 列表为空，则表示所有参数都已经应用完毕，此时 `curry` 不再是一个函数，而是最终的结果，返回这个结果。
- 否则，取出 `args` 的第一个元素，将其应用到 `curry` 函数上，然后递归地处理剩余的参数。

单引号和反引号的区别：

- 单引号（`'`）和反引号（```）都用于创建符号或列表
- 单引号用于创建一个符号（symbol）或一个未经求值的列表。使用单引号可以告诉解释器不要对表达式求值，而是将其作为数据处理。
- 反引号（也称为“准引用”或“quasiquote”）用于创建一个模板，其中某些部分可以被求值。反引号允许你在一个模板中包含一些需要求值的部分，这些部分用逗号（`,`）表示。反引号主要用于生成列表和嵌套的结构。

hw09学习记录：

- 学习语法：多分支选择函数`cond`、构造对函数`cons`、单引号和反引号的用途
- curry：学到了柯里化函数最终参数为空的话，就会返回一个值

经验：

- 做题慢直接找答案分析答案：因为背景知识不够，像是hw09中的Q2和Q3，需要对scheme一些语法和curry函数理解到一定程度才可解决
- 没事多chatgpt

csapp学习总结：

- 确认chapter4学习路线：instructions、digital design、sequential、pipelined
- study tools：y86 assembler、simulator of running y86 programs、simulators for sequential and pipelined
- ISA implementation:stat、instructions and endcoding、conventions、except
- memory reference：stop second register or scaling of a register value

## 6.12

csapp：

9:50 - 10:20(y86 instruction)

- 单寄存器操作指令（类似`irmovq`）的另一个不用的寄存器设置为`0xF`：indicates the absence of a register operand
- constant word：immediate data、displacement、destination（serve as absolute address）
- all integers have a little-endian encoding:normal instructions and reverse integer encoding
- byte encodings have the property of unique interpretation

10:30 - 11:44 (exception and program)

- start at address 0
- assembler for y86:YAS
- YIS:model the y86 instructions
- what does the instruction `pushq %rsp` do？
- Why worry about such picky details?

学习总结：

- 整数编码保持小端序
- Y86指令开始地址为0

