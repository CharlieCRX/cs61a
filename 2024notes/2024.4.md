# 4月份日报

## 4.1

愚人节快乐。

递归仍旧是我的难题，期待有朝一日它能成为我的强项。

## 4.2

今日todo

- [x] 下载bomblab上传git（15mins）
- [x] 阅读bomblab实验要求和题目设置（30mins）
- [ ] 继续阅读[【读薄 CSAPP】贰 机器指令与程序优化](https://wdxtub.com/csapp/thin-csapp-2/2016/04/16/)（2h）
- [x] cs61a：阅读[4.2涉及的代码和基本概念](https://composingprograms.netlify.app/4/2)（25mins）
- [x] 阅读[Lab 05: Iterators, Mutability](https://cs61a.org/lab/lab05/)题目（30mins）
- [x] 阅读[Disc 06: Iterators, Generators](https://cs61a.org/disc/disc06/)题目（30mins）
- [x] 解决[HW 04: Sequences, Trees](https://cs61a.org/hw/hw04/)问题，清理2.23之前的问题（1h）
- [ ] 阅读datalab的后四个问题（1h）
- [x] [了解gdb的基本用法](https://www.cs.cmu.edu/~213/recitations/rec02_handout.pdf)（30mins）
- [ ] [普京的最高理想！让欧洲战栗的女帝！《叶卡捷琳娜大帝》P1](https://www.bilibili.com/video/BV1xY4y1d7uk/?spm_id_from=333.337.search-card.all.click&vd_source=842936ebeedd7cce8bb2e1922b41edf1)
- [ ] [专题：回顾宫崎骏与久石让40年创作历程](https://www.bilibili.com/video/BV1Wx421D7r8/?spm_id_from=333.999.0.0&vd_source=842936ebeedd7cce8bb2e1922b41edf1)
- [x] [whynot视频](https://www.bilibili.com/video/BV1hc411f75N/?spm_id_from=333.999.0.0&vd_source=842936ebeedd7cce8bb2e1922b41edf1)
- [ ] 南京一日游推荐路线

bomblab要学哪些前置知识（重点学习）

1. 汇编指令及其用法
2. gdb调试的小技巧！！！（利用上面的[了解gdb的基本用法](https://www.cs.cmu.edu/~213/recitations/rec02_handout.pdf)）
3. 阅读[writeup](E:\code_life\1_project\csapp\03machine_prog\bomblab.pdf)
4. [slides](https://docs.google.com/presentation/d/1OjLAjPxhEXsElWsvmNnMGD-fzNCeGXip/edit#slide=id.p9)（超级重要！！，相当于做项目之前的知识储备）
5. 用者保存寄存器和被调用者保存寄存器的划分是为了在函数调用过程中管理寄存器的状态，确保在函数调用结束后，寄存器的值能够正确地恢复，不会影响到调用者或被调用者的代码，从而确保程序的正确性和可靠性。
6. %rax,%rsp,%rbp作用
7. Objdump
8. sscanf

迭代器是一种对象，提供对值逐一顺序访问的功能。

```py
>>> iterator = iter(primes)
>>> next(iterator)
>>> try:
        next(iterator)
    except StopIteration:#没有更多可用值
        print('No more values')
```

Python 中的 `for` 语句是对迭代器进行操作。 如果对象具有返回迭代器的 `__iter__` 方法（method），则表示对象是可迭代的。

将函数比作厨师：

> We're lazy (like an iterator) and used ChatGPT to generate a generator joke...
>
> why did the Python function become a chef?
>
> Because it was skilled at knowing when to "return" to the recipe and when to "yield" to improvisation!

# Homework 4: Sequences, ADT Trees

### Q1: Deep Map

Write a function `deep_map` that takes a list `s` and a one-argument function `f`. `s` may be a nested list, one that contain other lists. `deep_map` modifies `s` by replacing each element within `s` or any of the lists it contains with the result of calling `f` on that element.

`deep_map` returns `None` and should not create any new lists.

> **Hint:** `type(a) == list` will evaluate to `True` if `a` is a list.

```py
def deep_map(f, s):
    """Replace all non-list elements x with f(x) in the nested list s.

```

实现思路：

1. 利用递归，将大的嵌套列表元素，分解为一个个小的元素`elem`，并将所有元素`elem`按照`f`规则处理
2. base case：
   1. 一个列表中的所有元素遍历完毕后，返回`None`
   2. 遍历每个元素的时候，如果类型是`list`，则继续递推`deep_map(f, s)`处理此`list`类型的数据；如果不是则按照one-argument function `f`处理

翻译成代码：

```py
def deep_map(f, s):
    """Replace all non-list elements x with f(x) in the nested list s.

    >>> six = [1, 2, [3, [4], 5], 6]
    >>> deep_map(lambda x: x * x, six)
    >>> six
    [1, 4, [9, [16], 25], 36]
    >>> # Check that you're not making new lists
    >>> s = [3, [1, [4, [1]]]]
    >>> s1 = s[1]
    >>> s2 = s1[1]
    >>> s3 = s2[1]
    >>> deep_map(lambda x: x + 1, s)
    >>> s
    [4, [2, [5, [2]]]]
    >>> s1 is s[1]
    True
    >>> s2 is s1[1]
    True
    >>> s3 is s2[1]
    True
    """
    "*** YOUR CODE HERE ***"


    # base case1: Processing of traversing element "elem"
    # If it is not a list element, then for f(elem);
    # If it is a list element, call deep_map(f, elem) on the list element elem
    i = 0
    while i < len(s):
        if type(s[i]) == list:
            deep_map(f, s[i])
        else:
            s[i] = f(s[i])
        i += 1
    # base case: end of traversal
    # After traversing the last element, return None
    return None
```

### Q3: Balanced

Implement the `balanced` function, which returns whether `m` is a balanced mobile. A mobile is balanced if both of the following conditions are met:

1. The torque applied by its left arm is equal to the torque applied by its right arm. The torque of the left arm is the length of the left rod multiplied by the total mass hanging from that rod. Likewise for the right. For example, if the left arm has a length of `5`, and there is a `mobile` hanging at the end of the left arm of total mass `10`, the torque on the left side of our mobile is `50`.
2. Each of the mobiles hanging at the end of its arms is itself balanced.

Planets themselves are balanced, as there is nothing hanging off of them.

> **Reminder:** You may use the `total_mass` function above. Don't violate abstraction barriers. Instead, use the selector functions that have been defined.

递归判断一个`planet`是否平衡：

1. 力矩相同
2. 每个小的`planet`也是平衡的

那么实现思路：

1. base case如果`mobile`左右两边`end`均是星球，那么计算星球力矩是否相同：
   1. 力矩相同，返回`True`；
   2. 力矩不相同，返回`false`
2. 如果`mobile`左右两边力矩相同，判断此`mobile`的左右部分是否平衡
3. 两个条件不满足，则返回`false`

最终实现了这个问题，但是并不是按照这个思路来的（感觉递归很奇妙！）

## 4.3

todlist：

- [x] datalab回顾倒数后4题目回顾解决关键点
- [x] [普京的最高理想！让欧洲战栗的女帝！《叶卡捷琳娜大帝》P1](https://www.bilibili.com/video/BV1xY4y1d7uk/?spm_id_from=333.337.search-card.all.click&vd_source=842936ebeedd7cce8bb2e1922b41edf1)
- [x] 读完[【读薄 CSAPP】贰 机器指令与程序优化](https://wdxtub.com/csapp/thin-csapp-2/2016/04/16/)
- [x] 阅读[Lab 05: Iterators, Mutability](https://cs61a.org/lab/lab05/)题目+答案（30mins）
- [ ] 阅读[Disc 06: Iterators, Generators](https://cs61a.org/disc/disc06/)题目+答案（30mins）

**接受失败并学习**：接受每天无法完成所有计划的事实，并从中学习经验教训。失败并不意味着结束，而是为更好的开始积累经验。

现在是4.3号的17:00，感觉面对这些问题压力很大，总觉得“好困难”的样子。从而阻止了自己想继续下去的脚步。

这两天有一些挫败情绪让我感觉到有压力：

1. 妄图第一遍就解决问题。还是老问题，《学生为什么不喜欢上学》里面说的，当背景知识不够的时候，解决一个问题就会变得异常困难。那么就拿csapp的datalab来说明背景知识影响自己进度心情的例子：float部分题目，需要对IEEE的编码、32位单精度浮点数的值域、移位操作、逻辑与或非技巧很熟练，才能在解决这些问题的时候更加游刃有余。相反如果其中任何一个环节没掌握明白，都会造成自己做题困难，用时很长的问题。
2. 不合理的目标设置。想做出来，最起码理解问题是什么搞清楚，然后就是实现步骤，再最后落实到行动。

这两个问题的出现，让我学会从积极的角度看待失败和挫折，将其视为成长的机会而不是失败。坚持正向的思维和态度，激励自己不断前进。

现在有一个成长的机会摆在我的眼前：如何让自己学起来更愉悦？

那就是别设置太高期望，先混个眼熟大概，然后再仔细研究。最起码，你得先看一眼问题吧？然后稍微思考下解决思路吧？思考10分钟没有结果就赶紧看答案解析呗，哪里不会学哪里啊！答案分析完了自己解决一遍，不会没事，再看一遍答案分析，查缺补漏呗。

顺着情绪来吧，让自己开心一点宝贝。

多轮重复滚动的智慧，不就是降低背景知识缺乏带来的学习挫败吗。

加油宝贝！

今晚先将cs61a部分的问题先理解一遍，描述一下，明天试着解决，5分钟解决不了直接看答案分析。

## 补充知识：

`map` 函数将 `function` 应用于每个可迭代对象中相同位置的元素，返回一个迭代器（在 Python 2 中返回一个列表）

实例：

```py
# 使用内置函数
numbers = [1, 2, 3, 4, 5]
squared_numbers = map(lambda x: x ** 2, numbers)
print(list(squared_numbers))  # 输出: [1, 4, 9, 16, 25]
```

`map` 函数将函数应用于 `numbers` 列表中的每个元素，并返回新的列表或迭代器，包含了应用函数后的结果。

## 4.4

混个眼熟，大概浏览了一遍题目，对其中的问题大概了解了。

- 济南的特产和纪念品+济南旅游攻略
- 南京两天安排（重要！）

```py
(lambda t: [next(t) for _ in range(10)])(gen_fib())
```

调用`gen_fib()`十次。

快速浏览[【读薄 CSAPP】贰 机器指令与程序优化](https://wdxtub.com/csapp/thin-csapp-2/2016/04/16/)背景知识

1. 操作数是带括号的，括号的意思就是寻址：`movq (%rcx), %rax` 也就是说以 %rcx 寄存器中存储的地址去内存里找对应的数据，存到寄存器 %rax 中-- `temp = *p;`
2. 对于寻址来说，比较通用的格式是 `D(Rb, Ri, S)` -> `Mem[Reg[Rb]+S*Reg[Ri]+D]`

## 4.5

今天解决

- [x] [Lab 05: Iterators, Mutability](https://cs61a.org/lab/lab05/)题目（30mins）
- [ ] [Disc 06: Iterators, Generators](https://cs61a.org/disc/disc06/)题目（30mins）
- [ ] [ HW 05: Generators](https://cs61a.org/hw/hw05/)题目（1h）
- [x] 回顾csapp datalab float部分（1h）

`a, b = s, s[:]`

这是一个多重赋值语句，它将列表 `s` 赋值给变量 `a`，同时将列表 `s` 的副本（通过切片 `s[:]` 来实现）赋值给变量 `b`。

这样的赋值方式有一些细微但重要的区别：

- `a = s`：这种赋值方式只是将变量 `a` 指向了列表 `s`，即 `a` 和 `s` 共享同一个对象，修改其中一个变量的值会影响另一个变量。

- `b = s[:]`：这种赋值方式是创建了列表 `s` 的一个副本，并将这个副本赋值给变量 `b`，即 `b` 指向了一个新的列表对象，修改 `b` 的值不会影响 `s`。

