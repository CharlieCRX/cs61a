# 4æœˆä»½æ—¥æŠ¥

## 4.1

æ„šäººèŠ‚å¿«ä¹ã€‚

é€’å½’ä»æ—§æ˜¯æˆ‘çš„éš¾é¢˜ï¼ŒæœŸå¾…æœ‰æœä¸€æ—¥å®ƒèƒ½æˆä¸ºæˆ‘çš„å¼ºé¡¹ã€‚

## 4.2

ä»Šæ—¥todo

- [x] ä¸‹è½½bomblabä¸Šä¼ gitï¼ˆ15minsï¼‰
- [x] é˜…è¯»bomblabå®éªŒè¦æ±‚å’Œé¢˜ç›®è®¾ç½®ï¼ˆ30minsï¼‰
- [ ] ç»§ç»­é˜…è¯»[ã€è¯»è–„ CSAPPã€‘è´° æœºå™¨æŒ‡ä»¤ä¸ç¨‹åºä¼˜åŒ–](https://wdxtub.com/csapp/thin-csapp-2/2016/04/16/)ï¼ˆ2hï¼‰
- [x] cs61aï¼šé˜…è¯»[4.2æ¶‰åŠçš„ä»£ç å’ŒåŸºæœ¬æ¦‚å¿µ](https://composingprograms.netlify.app/4/2)ï¼ˆ25minsï¼‰
- [x] é˜…è¯»[Lab 05: Iterators, Mutability](https://cs61a.org/lab/lab05/)é¢˜ç›®ï¼ˆ30minsï¼‰
- [x] é˜…è¯»[Disc 06: Iterators, Generators](https://cs61a.org/disc/disc06/)é¢˜ç›®ï¼ˆ30minsï¼‰
- [x] è§£å†³[HW 04: Sequences, Trees](https://cs61a.org/hw/hw04/)é—®é¢˜ï¼Œæ¸…ç†2.23ä¹‹å‰çš„é—®é¢˜ï¼ˆ1hï¼‰
- [ ] é˜…è¯»datalabçš„åå››ä¸ªé—®é¢˜ï¼ˆ1hï¼‰
- [x] [äº†è§£gdbçš„åŸºæœ¬ç”¨æ³•](https://www.cs.cmu.edu/~213/recitations/rec02_handout.pdf)ï¼ˆ30minsï¼‰
- [ ] [æ™®äº¬çš„æœ€é«˜ç†æƒ³ï¼è®©æ¬§æ´²æˆ˜æ —çš„å¥³å¸ï¼ã€Šå¶å¡æ·ç³å¨œå¤§å¸ã€‹P1](https://www.bilibili.com/video/BV1xY4y1d7uk/?spm_id_from=333.337.search-card.all.click&vd_source=842936ebeedd7cce8bb2e1922b41edf1)
- [ ] [ä¸“é¢˜ï¼šå›é¡¾å®«å´éªä¸ä¹…çŸ³è®©40å¹´åˆ›ä½œå†ç¨‹](https://www.bilibili.com/video/BV1Wx421D7r8/?spm_id_from=333.999.0.0&vd_source=842936ebeedd7cce8bb2e1922b41edf1)
- [x] [whynotè§†é¢‘](https://www.bilibili.com/video/BV1hc411f75N/?spm_id_from=333.999.0.0&vd_source=842936ebeedd7cce8bb2e1922b41edf1)
- [ ] å—äº¬ä¸€æ—¥æ¸¸æ¨èè·¯çº¿

bomblabè¦å­¦å“ªäº›å‰ç½®çŸ¥è¯†ï¼ˆé‡ç‚¹å­¦ä¹ ï¼‰

1. æ±‡ç¼–æŒ‡ä»¤åŠå…¶ç”¨æ³•
2. gdbè°ƒè¯•çš„å°æŠ€å·§ï¼ï¼ï¼ï¼ˆåˆ©ç”¨ä¸Šé¢çš„[äº†è§£gdbçš„åŸºæœ¬ç”¨æ³•](https://www.cs.cmu.edu/~213/recitations/rec02_handout.pdf)ï¼‰
3. é˜…è¯»[writeup](E:\code_life\1_project\csapp\03machine_prog\bomblab.pdf)
4. [slides](https://docs.google.com/presentation/d/1OjLAjPxhEXsElWsvmNnMGD-fzNCeGXip/edit#slide=id.p9)ï¼ˆè¶…çº§é‡è¦ï¼ï¼ï¼Œç›¸å½“äºåšé¡¹ç›®ä¹‹å‰çš„çŸ¥è¯†å‚¨å¤‡ï¼‰
5. ç”¨è€…ä¿å­˜å¯„å­˜å™¨å’Œè¢«è°ƒç”¨è€…ä¿å­˜å¯„å­˜å™¨çš„åˆ’åˆ†æ˜¯ä¸ºäº†åœ¨å‡½æ•°è°ƒç”¨è¿‡ç¨‹ä¸­ç®¡ç†å¯„å­˜å™¨çš„çŠ¶æ€ï¼Œç¡®ä¿åœ¨å‡½æ•°è°ƒç”¨ç»“æŸåï¼Œå¯„å­˜å™¨çš„å€¼èƒ½å¤Ÿæ­£ç¡®åœ°æ¢å¤ï¼Œä¸ä¼šå½±å“åˆ°è°ƒç”¨è€…æˆ–è¢«è°ƒç”¨è€…çš„ä»£ç ï¼Œä»è€Œç¡®ä¿ç¨‹åºçš„æ­£ç¡®æ€§å’Œå¯é æ€§ã€‚
6. %rax,%rsp,%rbpä½œç”¨
7. Objdump
8. sscanf

è¿­ä»£å™¨æ˜¯ä¸€ç§å¯¹è±¡ï¼Œæä¾›å¯¹å€¼é€ä¸€é¡ºåºè®¿é—®çš„åŠŸèƒ½ã€‚

```py
>>> iterator = iter(primes)
>>> next(iterator)
>>> try:
        next(iterator)
    except StopIteration:#æ²¡æœ‰æ›´å¤šå¯ç”¨å€¼
        print('No more values')
```

Python ä¸­çš„ `for` è¯­å¥æ˜¯å¯¹è¿­ä»£å™¨è¿›è¡Œæ“ä½œã€‚ å¦‚æœå¯¹è±¡å…·æœ‰è¿”å›è¿­ä»£å™¨çš„ `__iter__` æ–¹æ³•ï¼ˆmethodï¼‰ï¼Œåˆ™è¡¨ç¤ºå¯¹è±¡æ˜¯å¯è¿­ä»£çš„ã€‚

å°†å‡½æ•°æ¯”ä½œå¨å¸ˆï¼š

> We're lazy (like an iterator) and used ChatGPT to generate a generator joke...
>
> why did the Python function become a chef?
>
> Because it was skilled at knowing when to "return" to the recipe and when to "yield" to improvisation!

# Homework 4: Sequences, ADT Trees

### Q1: Deep Map

Write a function `deep_map` that takes a list `s` and a one-argument function `f`. `s` may be a nested list, one that contain other lists. `deep_map` modifies `s` by replacing each element within `s` or any of the lists it contains with the result of calling `f` on that element.

`deep_map` returns `None` and should not create any new lists.

> **Hint:** `type(a) == list` will evaluate to `True` if `a` is a list.

```py
def deep_map(f, s):
    """Replace all non-list elements x with f(x) in the nested list s.

```

å®ç°æ€è·¯ï¼š

1. åˆ©ç”¨é€’å½’ï¼Œå°†å¤§çš„åµŒå¥—åˆ—è¡¨å…ƒç´ ï¼Œåˆ†è§£ä¸ºä¸€ä¸ªä¸ªå°çš„å…ƒç´ `elem`ï¼Œå¹¶å°†æ‰€æœ‰å…ƒç´ `elem`æŒ‰ç…§`f`è§„åˆ™å¤„ç†
2. base caseï¼š
   1. ä¸€ä¸ªåˆ—è¡¨ä¸­çš„æ‰€æœ‰å…ƒç´ éå†å®Œæ¯•åï¼Œè¿”å›`None`
   2. éå†æ¯ä¸ªå…ƒç´ çš„æ—¶å€™ï¼Œå¦‚æœç±»å‹æ˜¯`list`ï¼Œåˆ™ç»§ç»­é€’æ¨`deep_map(f, s)`å¤„ç†æ­¤`list`ç±»å‹çš„æ•°æ®ï¼›å¦‚æœä¸æ˜¯åˆ™æŒ‰ç…§one-argument function `f`å¤„ç†

ç¿»è¯‘æˆä»£ç ï¼š

```py
def deep_map(f, s):
    """Replace all non-list elements x with f(x) in the nested list s.

    >>> six = [1, 2, [3, [4], 5], 6]
    >>> deep_map(lambda x: x * x, six)
    >>> six
    [1, 4, [9, [16], 25], 36]
    >>> # Check that you're not making new lists
    >>> s = [3, [1, [4, [1]]]]
    >>> s1 = s[1]
    >>> s2 = s1[1]
    >>> s3 = s2[1]
    >>> deep_map(lambda x: x + 1, s)
    >>> s
    [4, [2, [5, [2]]]]
    >>> s1 is s[1]
    True
    >>> s2 is s1[1]
    True
    >>> s3 is s2[1]
    True
    """
    "*** YOUR CODE HERE ***"


    # base case1: Processing of traversing element "elem"
    # If it is not a list element, then for f(elem);
    # If it is a list element, call deep_map(f, elem) on the list element elem
    i = 0
    while i < len(s):
        if type(s[i]) == list:
            deep_map(f, s[i])
        else:
            s[i] = f(s[i])
        i += 1
    # base case: end of traversal
    # After traversing the last element, return None
    return None
```

### Q3: Balanced

Implement the `balanced` function, which returns whether `m` is a balanced mobile. A mobile is balanced if both of the following conditions are met:

1. The torque applied by its left arm is equal to the torque applied by its right arm. The torque of the left arm is the length of the left rod multiplied by the total mass hanging from that rod. Likewise for the right. For example, if the left arm has a length of `5`, and there is a `mobile` hanging at the end of the left arm of total mass `10`, the torque on the left side of our mobile is `50`.
2. Each of the mobiles hanging at the end of its arms is itself balanced.

Planets themselves are balanced, as there is nothing hanging off of them.

> **Reminder:** You may use the `total_mass` function above. Don't violate abstraction barriers. Instead, use the selector functions that have been defined.

é€’å½’åˆ¤æ–­ä¸€ä¸ª`planet`æ˜¯å¦å¹³è¡¡ï¼š

1. åŠ›çŸ©ç›¸åŒ
2. æ¯ä¸ªå°çš„`planet`ä¹Ÿæ˜¯å¹³è¡¡çš„

é‚£ä¹ˆå®ç°æ€è·¯ï¼š

1. base caseå¦‚æœ`mobile`å·¦å³ä¸¤è¾¹`end`å‡æ˜¯æ˜Ÿçƒï¼Œé‚£ä¹ˆè®¡ç®—æ˜ŸçƒåŠ›çŸ©æ˜¯å¦ç›¸åŒï¼š
   1. åŠ›çŸ©ç›¸åŒï¼Œè¿”å›`True`ï¼›
   2. åŠ›çŸ©ä¸ç›¸åŒï¼Œè¿”å›`false`
2. å¦‚æœ`mobile`å·¦å³ä¸¤è¾¹åŠ›çŸ©ç›¸åŒï¼Œåˆ¤æ–­æ­¤`mobile`çš„å·¦å³éƒ¨åˆ†æ˜¯å¦å¹³è¡¡
3. ä¸¤ä¸ªæ¡ä»¶ä¸æ»¡è¶³ï¼Œåˆ™è¿”å›`false`

æœ€ç»ˆå®ç°äº†è¿™ä¸ªé—®é¢˜ï¼Œä½†æ˜¯å¹¶ä¸æ˜¯æŒ‰ç…§è¿™ä¸ªæ€è·¯æ¥çš„ï¼ˆæ„Ÿè§‰é€’å½’å¾ˆå¥‡å¦™ï¼ï¼‰

## 4.3

todlistï¼š

- [x] datalabå›é¡¾å€’æ•°å4é¢˜ç›®å›é¡¾è§£å†³å…³é”®ç‚¹
- [x] [æ™®äº¬çš„æœ€é«˜ç†æƒ³ï¼è®©æ¬§æ´²æˆ˜æ —çš„å¥³å¸ï¼ã€Šå¶å¡æ·ç³å¨œå¤§å¸ã€‹P1](https://www.bilibili.com/video/BV1xY4y1d7uk/?spm_id_from=333.337.search-card.all.click&vd_source=842936ebeedd7cce8bb2e1922b41edf1)
- [x] è¯»å®Œ[ã€è¯»è–„ CSAPPã€‘è´° æœºå™¨æŒ‡ä»¤ä¸ç¨‹åºä¼˜åŒ–](https://wdxtub.com/csapp/thin-csapp-2/2016/04/16/)
- [x] é˜…è¯»[Lab 05: Iterators, Mutability](https://cs61a.org/lab/lab05/)é¢˜ç›®+ç­”æ¡ˆï¼ˆ30minsï¼‰
- [ ] é˜…è¯»[Disc 06: Iterators, Generators](https://cs61a.org/disc/disc06/)é¢˜ç›®+ç­”æ¡ˆï¼ˆ30minsï¼‰

**æ¥å—å¤±è´¥å¹¶å­¦ä¹ **ï¼šæ¥å—æ¯å¤©æ— æ³•å®Œæˆæ‰€æœ‰è®¡åˆ’çš„äº‹å®ï¼Œå¹¶ä»ä¸­å­¦ä¹ ç»éªŒæ•™è®­ã€‚å¤±è´¥å¹¶ä¸æ„å‘³ç€ç»“æŸï¼Œè€Œæ˜¯ä¸ºæ›´å¥½çš„å¼€å§‹ç§¯ç´¯ç»éªŒã€‚

ç°åœ¨æ˜¯4.3å·çš„17:00ï¼Œæ„Ÿè§‰é¢å¯¹è¿™äº›é—®é¢˜å‹åŠ›å¾ˆå¤§ï¼Œæ€»è§‰å¾—â€œå¥½å›°éš¾â€çš„æ ·å­ã€‚ä»è€Œé˜»æ­¢äº†è‡ªå·±æƒ³ç»§ç»­ä¸‹å»çš„è„šæ­¥ã€‚

è¿™ä¸¤å¤©æœ‰ä¸€äº›æŒ«è´¥æƒ…ç»ªè®©æˆ‘æ„Ÿè§‰åˆ°æœ‰å‹åŠ›ï¼š

1. å¦„å›¾ç¬¬ä¸€éå°±è§£å†³é—®é¢˜ã€‚è¿˜æ˜¯è€é—®é¢˜ï¼Œã€Šå­¦ç”Ÿä¸ºä»€ä¹ˆä¸å–œæ¬¢ä¸Šå­¦ã€‹é‡Œé¢è¯´çš„ï¼Œå½“èƒŒæ™¯çŸ¥è¯†ä¸å¤Ÿçš„æ—¶å€™ï¼Œè§£å†³ä¸€ä¸ªé—®é¢˜å°±ä¼šå˜å¾—å¼‚å¸¸å›°éš¾ã€‚é‚£ä¹ˆå°±æ‹¿csappçš„datalabæ¥è¯´æ˜èƒŒæ™¯çŸ¥è¯†å½±å“è‡ªå·±è¿›åº¦å¿ƒæƒ…çš„ä¾‹å­ï¼šfloatéƒ¨åˆ†é¢˜ç›®ï¼Œéœ€è¦å¯¹IEEEçš„ç¼–ç ã€32ä½å•ç²¾åº¦æµ®ç‚¹æ•°çš„å€¼åŸŸã€ç§»ä½æ“ä½œã€é€»è¾‘ä¸æˆ–éæŠ€å·§å¾ˆç†Ÿç»ƒï¼Œæ‰èƒ½åœ¨è§£å†³è¿™äº›é—®é¢˜çš„æ—¶å€™æ›´åŠ æ¸¸åˆƒæœ‰ä½™ã€‚ç›¸åå¦‚æœå…¶ä¸­ä»»ä½•ä¸€ä¸ªç¯èŠ‚æ²¡æŒæ¡æ˜ç™½ï¼Œéƒ½ä¼šé€ æˆè‡ªå·±åšé¢˜å›°éš¾ï¼Œç”¨æ—¶å¾ˆé•¿çš„é—®é¢˜ã€‚
2. ä¸åˆç†çš„ç›®æ ‡è®¾ç½®ã€‚æƒ³åšå‡ºæ¥ï¼Œæœ€èµ·ç ç†è§£é—®é¢˜æ˜¯ä»€ä¹ˆææ¸…æ¥šï¼Œç„¶åå°±æ˜¯å®ç°æ­¥éª¤ï¼Œå†æœ€åè½å®åˆ°è¡ŒåŠ¨ã€‚

è¿™ä¸¤ä¸ªé—®é¢˜çš„å‡ºç°ï¼Œè®©æˆ‘å­¦ä¼šä»ç§¯æçš„è§’åº¦çœ‹å¾…å¤±è´¥å’ŒæŒ«æŠ˜ï¼Œå°†å…¶è§†ä¸ºæˆé•¿çš„æœºä¼šè€Œä¸æ˜¯å¤±è´¥ã€‚åšæŒæ­£å‘çš„æ€ç»´å’Œæ€åº¦ï¼Œæ¿€åŠ±è‡ªå·±ä¸æ–­å‰è¿›ã€‚

ç°åœ¨æœ‰ä¸€ä¸ªæˆé•¿çš„æœºä¼šæ‘†åœ¨æˆ‘çš„çœ¼å‰ï¼šå¦‚ä½•è®©è‡ªå·±å­¦èµ·æ¥æ›´æ„‰æ‚¦ï¼Ÿ

é‚£å°±æ˜¯åˆ«è®¾ç½®å¤ªé«˜æœŸæœ›ï¼Œå…ˆæ··ä¸ªçœ¼ç†Ÿå¤§æ¦‚ï¼Œç„¶åå†ä»”ç»†ç ”ç©¶ã€‚æœ€èµ·ç ï¼Œä½ å¾—å…ˆçœ‹ä¸€çœ¼é—®é¢˜å§ï¼Ÿç„¶åç¨å¾®æ€è€ƒä¸‹è§£å†³æ€è·¯å§ï¼Ÿæ€è€ƒ10åˆ†é’Ÿæ²¡æœ‰ç»“æœå°±èµ¶ç´§çœ‹ç­”æ¡ˆè§£æå‘—ï¼Œå“ªé‡Œä¸ä¼šå­¦å“ªé‡Œå•Šï¼ç­”æ¡ˆåˆ†æå®Œäº†è‡ªå·±è§£å†³ä¸€éï¼Œä¸ä¼šæ²¡äº‹ï¼Œå†çœ‹ä¸€éç­”æ¡ˆåˆ†æï¼ŒæŸ¥ç¼ºè¡¥æ¼å‘—ã€‚

é¡ºç€æƒ…ç»ªæ¥å§ï¼Œè®©è‡ªå·±å¼€å¿ƒä¸€ç‚¹å®è´ã€‚

å¤šè½®é‡å¤æ»šåŠ¨çš„æ™ºæ…§ï¼Œä¸å°±æ˜¯é™ä½èƒŒæ™¯çŸ¥è¯†ç¼ºä¹å¸¦æ¥çš„å­¦ä¹ æŒ«è´¥å—ã€‚

åŠ æ²¹å®è´ï¼

ä»Šæ™šå…ˆå°†cs61aéƒ¨åˆ†çš„é—®é¢˜å…ˆç†è§£ä¸€éï¼Œæè¿°ä¸€ä¸‹ï¼Œæ˜å¤©è¯•ç€è§£å†³ï¼Œ5åˆ†é’Ÿè§£å†³ä¸äº†ç›´æ¥çœ‹ç­”æ¡ˆåˆ†æã€‚

## è¡¥å……çŸ¥è¯†ï¼š

`map` å‡½æ•°å°† `function` åº”ç”¨äºæ¯ä¸ªå¯è¿­ä»£å¯¹è±¡ä¸­ç›¸åŒä½ç½®çš„å…ƒç´ ï¼Œè¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼ˆåœ¨ Python 2 ä¸­è¿”å›ä¸€ä¸ªåˆ—è¡¨ï¼‰

å®ä¾‹ï¼š

```py
# ä½¿ç”¨å†…ç½®å‡½æ•°
numbers = [1, 2, 3, 4, 5]
squared_numbers = map(lambda x: x ** 2, numbers)
print(list(squared_numbers))  # è¾“å‡º: [1, 4, 9, 16, 25]
```

`map` å‡½æ•°å°†å‡½æ•°åº”ç”¨äº `numbers` åˆ—è¡¨ä¸­çš„æ¯ä¸ªå…ƒç´ ï¼Œå¹¶è¿”å›æ–°çš„åˆ—è¡¨æˆ–è¿­ä»£å™¨ï¼ŒåŒ…å«äº†åº”ç”¨å‡½æ•°åçš„ç»“æœã€‚

## 4.4

æ··ä¸ªçœ¼ç†Ÿï¼Œå¤§æ¦‚æµè§ˆäº†ä¸€éé¢˜ç›®ï¼Œå¯¹å…¶ä¸­çš„é—®é¢˜å¤§æ¦‚äº†è§£äº†ã€‚

- æµå—çš„ç‰¹äº§å’Œçºªå¿µå“+æµå—æ—…æ¸¸æ”»ç•¥
- å—äº¬ä¸¤å¤©å®‰æ’ï¼ˆé‡è¦ï¼ï¼‰

```py
(lambda t: [next(t) for _ in range(10)])(gen_fib())
```

è°ƒç”¨`gen_fib()`åæ¬¡ã€‚

å¿«é€Ÿæµè§ˆ[ã€è¯»è–„ CSAPPã€‘è´° æœºå™¨æŒ‡ä»¤ä¸ç¨‹åºä¼˜åŒ–](https://wdxtub.com/csapp/thin-csapp-2/2016/04/16/)èƒŒæ™¯çŸ¥è¯†

1. æ“ä½œæ•°æ˜¯å¸¦æ‹¬å·çš„ï¼Œæ‹¬å·çš„æ„æ€å°±æ˜¯å¯»å€ï¼š`movq (%rcx), %rax` ä¹Ÿå°±æ˜¯è¯´ä»¥ %rcx å¯„å­˜å™¨ä¸­å­˜å‚¨çš„åœ°å€å»å†…å­˜é‡Œæ‰¾å¯¹åº”çš„æ•°æ®ï¼Œå­˜åˆ°å¯„å­˜å™¨ %rax ä¸­-- `temp = *p;`
2. å¯¹äºå¯»å€æ¥è¯´ï¼Œæ¯”è¾ƒé€šç”¨çš„æ ¼å¼æ˜¯ `D(Rb, Ri, S)` -> `Mem[Reg[Rb]+S*Reg[Ri]+D]`

## 4.5

ä»Šå¤©è§£å†³

- [x] [Lab 05: Iterators, Mutability](https://cs61a.org/lab/lab05/)é¢˜ç›®ï¼ˆ30minsï¼‰
- [x] [Disc 06: Iterators, Generators](https://cs61a.org/disc/disc06/)é¢˜ç›®ï¼ˆ30minsï¼‰
- [x] [ HW 05: Generators](https://cs61a.org/hw/hw05/)é¢˜ç›®ï¼ˆ1hï¼‰
- [x] å›é¡¾csapp datalab floatéƒ¨åˆ†ï¼ˆ1hï¼‰

`a, b = s, s[:]`

è¿™æ˜¯ä¸€ä¸ªå¤šé‡èµ‹å€¼è¯­å¥ï¼Œå®ƒå°†åˆ—è¡¨ `s` èµ‹å€¼ç»™å˜é‡ `a`ï¼ŒåŒæ—¶å°†åˆ—è¡¨ `s` çš„å‰¯æœ¬ï¼ˆé€šè¿‡åˆ‡ç‰‡ `s[:]` æ¥å®ç°ï¼‰èµ‹å€¼ç»™å˜é‡ `b`ã€‚

è¿™æ ·çš„èµ‹å€¼æ–¹å¼æœ‰ä¸€äº›ç»†å¾®ä½†é‡è¦çš„åŒºåˆ«ï¼š

- `a = s`ï¼šè¿™ç§èµ‹å€¼æ–¹å¼åªæ˜¯å°†å˜é‡ `a` æŒ‡å‘äº†åˆ—è¡¨ `s`ï¼Œå³ `a` å’Œ `s` å…±äº«åŒä¸€ä¸ªå¯¹è±¡ï¼Œä¿®æ”¹å…¶ä¸­ä¸€ä¸ªå˜é‡çš„å€¼ä¼šå½±å“å¦ä¸€ä¸ªå˜é‡ã€‚

- `b = s[:]`ï¼šè¿™ç§èµ‹å€¼æ–¹å¼æ˜¯åˆ›å»ºäº†åˆ—è¡¨ `s` çš„ä¸€ä¸ªå‰¯æœ¬ï¼Œå¹¶å°†è¿™ä¸ªå‰¯æœ¬èµ‹å€¼ç»™å˜é‡ `b`ï¼Œå³ `b` æŒ‡å‘äº†ä¸€ä¸ªæ–°çš„åˆ—è¡¨å¯¹è±¡ï¼Œä¿®æ”¹ `b` çš„å€¼ä¸ä¼šå½±å“ `s`ã€‚

60åˆ†è¦æ¯”100åˆ†é‡è¦ï¼

`yield from`ï¼šç”Ÿæˆå™¨å‡½æ•°ä¸­å§”æ‰˜ç”Ÿæˆå™¨ã€‚è¿™ç§è¯­æ³•ä½¿å¾—ç”Ÿæˆå™¨å¯ä»¥ç›´æ¥è°ƒç”¨å¦ä¸€ä¸ªç”Ÿæˆå™¨ï¼Œå¹¶å°†å…¶äº§ç”Ÿçš„å€¼é€ä¸ªè¿”å›ï¼Œè€Œä¸éœ€è¦åœ¨å¤–å±‚ç”Ÿæˆå™¨ä¸­æ˜¾å¼åœ°éå†å¹¶ yield ç”Ÿæˆå™¨å†…éƒ¨çš„å€¼ã€‚

```py
def partition_gen(n, m):
    """Yield the partitions of n using parts up to size m.

    >>> for partition in sorted(partition_gen(6, 4)):
    ...     print(partition)
    1 + 1 + 1 + 1 + 1 + 1
    1 + 1 + 1 + 1 + 2
    1 + 1 + 1 + 3
    1 + 1 + 2 + 2
    1 + 1 + 4
    1 + 2 + 3
    2 + 2 + 2
    2 + 4
    3 + 3
    """
    assert n > 0 and m > 0
    if n == m:
        yield str(n)
    if n - m > 0:
        for p in partition_gen(n - m, m):
            yield p + ' + ' + str(m)
    if m > 1:
        yield from partition_gen(n, m-1)
```

`yield from partition_gen(n, m - 1)` å®é™…ä¸Šç›¸å½“äºéå†è°ƒç”¨ `partition_gen(n, m - 1)` ç”Ÿæˆå™¨æ‰€äº§ç”Ÿçš„æ‰€æœ‰å€¼ï¼Œå¹¶å°†è¿™äº›å€¼é€ä¸ª yield å‡ºæ¥ã€‚

å…·ä½“æ¥è¯´ï¼Œ`yield from` è¯­å¥ä¼šå°†è°ƒç”¨çš„ç”Ÿæˆå™¨äº§ç”Ÿçš„å€¼é€ä¸ªè¿”å›ç»™å¤–å±‚çš„ç”Ÿæˆå™¨ï¼Œå°±å¥½åƒåœ¨å¤–å±‚ç”Ÿæˆå™¨ä¸­æ‰‹åŠ¨éå†å¹¶ yield è¿™äº›å€¼ä¸€æ ·ã€‚è¿™æ ·åšçš„å¥½å¤„æ˜¯å¯ä»¥ç®€åŒ–ä»£ç ï¼Œä½¿å¾—ç”Ÿæˆå™¨çš„ä½¿ç”¨æ›´åŠ æ¸…æ™°å’Œç®€æ´ã€‚

## 4.8

è®°å½•æ—¶é•¿å’Œå…·ä½“é—®é¢˜ã€‚

10:00-10:30ï¼šè®°å¿†3.2ä¸­çš„å¯„å­˜å™¨åŠå…¶å¤§ä½“åŠŸèƒ½ï¼›è®°å¿†æ“ä½œæ•°ä¸‰ä¸ªæ¥æºï¼ˆç«‹å³æ•°ã€å¯„å­˜å™¨å’Œå†…å­˜ï¼‰åŠå…¶å½¢å¼ã€‚

10:30-11:00ï¼šå¦‚å›¾ã€‚æ•°æ®è½¬ç§»æŒ‡ä»¤çš„æ ¼å¼åŠå…¶åç¼€æ„ä¹‰ã€‚

![image-20240408104834004](E:\code_life\1_project\cs61a\2024notes\image\image-20240408104834004.png)

14:00-15:00ï¼šåœ¨x86ä¸­ï¼Œæ ˆæ˜¯æœç€ä½åœ°å€ç”Ÿé•¿çš„ã€‚With x86-64, stacks grow toward lower addresses, so pushing involves decrementing the stack pointer (register %rsp) and storing to memory,while popping involves reading from memory and incrementing the stack pointer.

`pushq %rbp` is equivalent to that of the pair of instructions:

```assembly
subq $8,%rsp 		#Decrement stack pointer
movq %rbp,(%rsp) 	#Store %rbp on stack
```

the instruction `popq %rax` is equivalent to the following pair of instructions:

```assembly
movq (%rsp),%rax 	#Read %rax from stack
addq $8,%rsp 		#Increment stack pointer
```

csappæ€»å…±ç”¨æ—¶3hï¼ŒæŒæ¡äº†å¯„å­˜å™¨ï¼ŒmovæŒ‡ä»¤å’Œstackéƒ¨åˆ†çš„çŸ¥è¯†ï¼Œå› ä¸ºå­¦ä¹ çš„å†…å®¹éƒ½åå‘è®°å¿†ï¼Œæ‰€ä»¥å­¦ä¹ è¾ƒä¸ºè½»æ¾ã€‚

15:40å¼€å§‹ï¼Œå­¦ä¹ cs61açš„2.5èŠ‚ã€‚

```py
>>> class Account:
   		def __init__(self, account_holder):
            self.balance = 0
            self.holder = account_holder
```

- æ„é€ å‡½æ•°åŠå…¶å‚æ•°ã€‚ç¬¬ä¸€ä¸ª `self` ç»‘å®šåˆ°æ–°åˆ›å»ºçš„ `Account` å¯¹è±¡ã€‚ç¬¬äºŒä¸ªå‚æ•° `account_holder` æ˜¯ç±»è¿›è¡Œå®ä¾‹åŒ–æ—¶çš„å‚æ•°ã€‚

- å†…ç½®å‡½æ•° `getattr` å¯ä»¥æŒ‰åç§°è¿”å›å¯¹è±¡çš„å±æ€§`getattr(spock_account, 'balance')`

- è°ƒç”¨æ–¹æ³•ï¼š

  ```py
  >>> Account.deposit(spock_account, 1001)	# å‡½æ•° deposit æ¥å—ä¸¤ä¸ªå‚æ•°
  1011
  >>> spock_account.deposit(1000) 			# æ–¹æ³• deposit æ¥å—ä¸€ä¸ªå‚æ•°
  2011
  ```

- åœ¨å­ç±»ä¸­æœªæŒ‡å®šçš„ä»»ä½•å†…å®¹éƒ½ä¼šè¢«è‡ªåŠ¨å‡å®šä¸ºä¸çˆ¶ç±»çš„è¡Œä¸ºä¸€æ ·

15:40-16:12ï¼šå®Œæˆé˜…è¯»2.5èŠ‚å†…å®¹ï¼Œå‡†å¤‡é˜…è¯»2.7èŠ‚å†…å®¹ã€‚

16:12-18:30ï¼šæ™šé¥­ï¼Œå¤„ç†é¸¡è‚‰ï¼Œæ¨èæ‰‹æœº+ä¼‘æ¯25mins

é€šè¿‡ `@property` è£…é¥°å™¨ï¼Œå¯ä»¥å°†ä¸€ä¸ªæ–¹æ³•è½¬å˜ä¸ºç±»çš„ä¸€ä¸ªå±æ€§ï¼Œè€Œä¸éœ€è¦ä½¿ç”¨æ–¹æ³•è°ƒç”¨çš„æ‹¬å·ã€‚è¿™ç§æ–¹å¼å¯ä»¥ä½¿å¾—ä»£ç æ›´åŠ æ¸…æ™°å’Œç®€æ´ï¼Œå¹¶ä¸”ç¬¦åˆ Python çš„é¢å‘å¯¹è±¡ç¼–ç¨‹é£æ ¼

18:30-17:30ï¼šé˜…è¯»2.7å’Œ2.8å†…å®¹ã€‚

17:30-20:16ï¼šæœé›†sicpå­¦ä¹ æ–¹é¢çš„èµ„æ–™ï¼š

[Why Structure and Interpretation of Computer Programs matters](https://people.eecs.berkeley.edu/~bh/sicp.html)ï¼š

- In my SICP-based course at Berkeley, we spend the first hour on notation and that's all we need; for the rest of the semester we're learning ideas, not syntax. 
- Once you learned the big ideas, they thought, and this is my experience also, learning another programming language isn't a big deal; it's a chore for a weekend.
- The idea that computer science should be about ideas, not entirely about programming practice, has since widened to include non-technical ideas about the context and social implications of computing

å­¦å¥½é‡Œé¢çš„æ€æƒ³çš„å‰æï¼Œå°±æ˜¯éœ€è¦ç»ƒä¹ å·©å›ºæ¦‚å¿µå§ï¼Ÿ

å­¦ä¹ äº†ä¸‹è€¶å…‹æ–¯å¤šå¾·æ£®å®šå¾‹ï¼Œä¸€ä¸ªå…³äºåŠ¨æœºå’Œæ•ˆç‡ä¹‹é—´çš„å…³ç³»å›¾è¡¨ã€‚æ€»ç»“å°±æ˜¯ä¸¤å¥è¯ï¼š

1. åŠ¨æœºå’Œæ•ˆç‡å¹¶ä¸æˆæ­£æ¯”ï¼Œå¾€å¾€æˆä¸€ä¸ªå€’Uå‹æ›²çº¿ã€‚è¦åŠæ—¶è§‚å¯Ÿè‡ªå·±çš„å¿ƒæ€æ„Ÿå—ï¼Œæ¬²é€Ÿåˆ™ä¸è¾¾ï¼Œæ±‚è€Œä¸å¾—ã€‚

2. å›°éš¾çš„é—®é¢˜éœ€è¦è¾ƒå°‘çš„åŠ¨æœºï¼Œæ‰ä¼šæœ‰æ›´å¥½åœ°ä½“éªŒã€‚

ä¹Ÿå¯ä»¥è¯´å°†å¤§é—®é¢˜åˆ†è§£ä¸ºå®¹æ˜“åšçš„å°é—®é¢˜ã€‚è¿™ä¸ªå°é—®é¢˜çš„åº¦å°±æ˜¯ç®€å•æ— è„‘ï¼ˆç±»ä¼¼é“ºå«èƒŒæ™¯çŸ¥è¯†ï¼‰ï¼Œç­‰ä½ è§£å†³è¿™äº›å°é—®é¢˜å¤šäº†ï¼Œæ‰å‘ç°è¿™ä¸ªé—®é¢˜å·²ç»è§£å†³çš„å·®ä¸å¤šäº†ã€‚è¦å¤šæ³¨æ„è‡ªå·±çš„çœŸå®æ„Ÿå—ï¼Œå°Šé‡è‡ªå·±å¹¶çˆ±æŠ¤è‡ªå·±çš„å¥½å¥‡å¿ƒå’Œè¿›å–å¿ƒã€‚

å› ä¸ºå®ƒä»¬æ˜¯å¾ˆè„†å¼±çš„ã€‚

## 4.9

cs61a

1.7é€’å½’å­¦ä¹ ï¼š

1. `sum_digits(738)`åšäº†ä»€ä¹ˆ

```py
>>> def sum_digits(n):
        """Return the sum of the digits of positive integer n."""
        if n < 10:
            return n
        else:
            all_but_last, last = n // 10, n % 10
            return sum_digits(all_but_last) + last
>>> sum_digits(738)
```

2. sum_digitsçš„base caseæ˜¯ä»€ä¹ˆï¼Ÿ
3.  whyï¼ŸThat is, we should not care about how `fact(n-1)` is implemented in the body of `fact`; we should simply trust that it computes the factorial of `n-1`.*recursive leap of faith*ï¼Œç›¸ä¿¡`fact(n-1)`çš„æ­£ç¡®æ€§ï¼Œè€Œä¸æ˜¯å…³æ³¨`fact(n-1)`çš„å…·ä½“å®ç°ã€‚
4. tree recursion, in which a function calls itself more than once.but why called they are tree recurision?å› ä¸ºé—®é¢˜ä¼šè¢«åˆ†è§£çš„æ›´å°ä½†æ˜¯æ•°é‡ä¼šå˜å¤šã€‚

1.7è®²äº†é€’å‡½æ•°æŠ½è±¡çš„å…·ä½“åŒ–ï¼šå°†å¤§é—®é¢˜åŒ–è§£ä¸ºå°é—®é¢˜çš„é€’å½’ï¼Œè¿™æ ·å°±å¯ä»¥çœå»æ¯ä¸€æ­¥çš„å…·ä½“å®ç°ã€‚åªéœ€è¦è€ƒè™‘ï¼Œå¦‚ä½•å°†è¿™ä¸ªå¤§é—®é¢˜åŒ–è§£ä¸ºåŒæ ·çš„å‡ ä¸ªè¾ƒå°çš„é—®é¢˜ï¼Œè€Œä¸éœ€è¦è€ƒè™‘è¿™å‡ ä¸ªè¾ƒå°çš„é—®é¢˜å…·ä½“å¦‚ä½•å®ç°ã€‚æ‰€è°“â€œé€’å½’çš„ä¿¡ä»°ä¹‹è·ƒâ€å°±æ˜¯è¿™æ ·ã€‚

å¼€å§‹å­¦ä¹ ç¬¬äºŒç« ï¼Œè¿™ä¸€ç« è®²äº†å¦‚ä½•å°†æ•°æ®åšæˆæŠ½è±¡çš„ã€‚

2.1Introduction

-  Chapter 1ï¼šcreate functional abstractions by giving names to processes
- è¿™ç« è¦å¹²å˜›ï¼šThe type for most values must be defined by programmers using the means of combination and abstraction that we will develop in this chapter
- The following sections introduce more of Python's native data types, **focusing on the role they play in creating useful data abstractions**.

Listï¼šthe difference between `append()` and `extend()`

- `append()`ï¼šadds a single item to the end of the listï¼ˆå°†å‚æ•°ä¸­çš„åˆ—è¡¨å…ƒç´ çœ‹åšä¸€ä¸ªæ•´ä½“ï¼Œä½œä¸ºä¸€ä¸ªå…ƒç´ æ’å…¥åˆ—è¡¨ä¸­ï¼‰
-  `extend()` ï¼šmethod takes one argument, a list, and appends each of the items of the argument to the original list.ï¼ˆå°†å‚æ•°ä¸­çš„åˆ—è¡¨å…ƒç´ å±•å¼€ï¼Œåˆ†åˆ«æ’å…¥æºåˆ—è¡¨ä¸­ï¼‰

## 4.10

2.2æ•°æ®æŠ½è±¡ğŸ˜‰

- shield parts of our program that compute using positions from the details of how those positions are represented.
- isolating the parts of a program that deal with how data are represented from the parts that deal with how data are manipulatedï¼ˆå°†æ•°æ®çš„è¡¨ç¤ºå’Œæ•°æ®çš„è¿ç®—å¤„ç†éš”ç¦»-ä½ åªæ˜¯æƒ³è¦è¿™ä¸ªæ•°æ®æ€ä¹ˆç”¨ï¼Œè€Œä¸è€ƒè™‘è¿™ä¸ªæ•°æ®æ˜¯æ€ä¹ˆæ¥çš„ï¼‰
- å›é¡¾chapter1ï¼šWhen we create a functional abstraction, the details of how a function is implemented can be suppressed, and the particular function itself can be replaced by any other function with the same overall behaviorï¼ˆå‡½æ•°æŠ½è±¡ï¼šåªéœ€è¦çŸ¥é“æ€ä¹ˆç”¨å‡½æ•°ï¼Œä¸éœ€è¦è€ƒè™‘å…·ä½“å®ç°ï¼Œåªè¦å®ç°ç›¸åŒçš„è¡Œä¸ºï¼Œå…¶ä»–å‡½æ•°ä¹Ÿå¯ä»¥ï¼‰
- ç‚¹æ˜chapter2ï¼šAnalogously, data abstraction isolates how a compound data value is used from the details of how it is constructed
- In addition, the appropriate relationship must hold among the constructor and selectors
- listå¹¶ä¸æ˜¯å”¯ä¸€è¡¨ç¤ºæœ‰ç†æ•°çš„åˆ†å­åˆ†æ¯çš„å¿…è¦ç»“æ„ï¼Œè‡³äºè¦æœ‰ä¸€å¯¹å€¼çš„ç»“æ„å°±å¯ä»¥ã€‚åé¢å°±ç”¨é«˜é˜¶å‡½æ•°è¯æ˜äº†è¿™ä¸ªã€‚The point of exhibiting the functional representation of a pair is not that Python actually works this way (lists are implemented more directly, for efficiency reasons) but that it could work this way. 

2.2æ€»ç»“ï¼š

æ•°æ®æŠ½è±¡çš„æ„ä¹‰åœ¨äºï¼Œå¯ä»¥å°†ç‰¹å®šçš„æ•°æ®æ“ä½œå’Œè¿™ä¸ªæ•°æ®æ€ä¹ˆå®ç°çš„éš”ç¦»å¼€ï¼Œè¿™æ ·çš„æ•°æ®æŠ½è±¡ä¿è¯äº†ç¨‹åºçš„æ¨¡å—åŒ–å¼€å‘ã€‚

csappï¼š

- registers are used to store integer data as well as pointers.
- effective addressï¼ša computed address
- movæŒ‡ä»¤ï¼šThe **source operand** designates a value that is immediate, stored in a register,
  or stored in memory. The **destination operand** designates a location that is either a
  register or a memory address
- pushing involves decrementing the stack pointer (register %rsp) and storing to memory
- popping involves reading from memory and incrementing the stack pointer.
- leaq:the instruction copies the effective address to the destination.This instruction can be used to generate pointers for later memory references
- leaqå’Œmovqçš„åŒºåˆ«ï¼šmovq s,dçš„ç¬¬ä¸€ä¸ªå‚æ•°å¦‚æœä¸æ˜¯ç«‹å³æ•°æˆ–è€…å¯„å­˜å™¨ï¼Œé‚£ä¹ˆå°†ä¼šä»å¯¹åº”çš„åœ°å€ä¸­æ‰¾åˆ°æ•°æ®ã€‚è€Œleaqåˆ™åªæ˜¯å°†ç¬¬ä¸€ä¸ªå‚æ•°ä½œä¸ºåœ°å€ä¼ é€’ç»™destination operandã€‚

## 4.11

ä»Šå¤©æ—©æ™¨é¦–å…ˆå›é¡¾äº†ä¸‹æœ€è¿‘å‡ å¤©çš„æ—¥æŠ¥ï¼Œå‘ç°è®°å½•å­¦ä¹ çš„è¿›åº¦è›®å¥½çš„ã€‚

å¯¹æ‰€å­¦çŸ¥è¯†è¿›è¡Œç®€å•æ€»ç»“ï¼Œå°±èƒ½åœ¨æ—¥åç¿»é˜…çš„æ—¶å€™å¾ˆå¿«æ£€ç´¢åˆ°å¯¹åº”çš„ä¿¡æ¯ï¼Œçœå»äº†é‡æ–°æ•´ç†çš„æ—¶é—´ã€‚

ä»Šå¤©ä¸»è¦æ˜¯å°†2.3å’Œ2.4èŠ‚ä¸ä¼šçš„å•è¯æŸ¥å‡ºæ¥è€Œå·²ï¼Œæ”¾è½»æ¾ã€‚ä¸‹åˆè¦å»ä¹°ç‚¹æ´—é¢å¥¶å’Œçˆ½è‚¤æ°´

å­¦ä¹ 2.3åºåˆ—ä¸€èŠ‚ï¼Œåœ¨å­¦ä¹ ä¹‹å‰ï¼Œå…ˆçœ‹çœ‹è‡ªå·±å¤§æ¦‚è¦å­¦ä»€ä¹ˆï¼Œåšåˆ°å¿ƒä¸­æœ‰æ•°ï¼š[CS61Aé˜…è¯»æŒ‡å—](https://www.cnblogs.com/shangshankandashu/articles/18046806)

2.3Sequences

- A sequence is an ordered collection of values
- many kinds of sequences all share common behavior:length and element selection

10:04-11:30ï¼ˆéå¸¸ç‰›é€¼ï¼ï¼‰

```py
for <name> in <expression>:
    <suite>
```

- `for` loop introduces yet another way in which the environment can be updated by a statement.

```py
>>> pairs = [[1, 2], [2, 2], [2, 3], [4, 4]]
>>> same_count = 0
>>> for x, y in pairs:
        if x == y:
            same_count = same_count + 1
```

A `for` statement may include multiple names in its header to "unpack" each element sequence into its respective elements.

The following `for` statement with two names in its header will bind each name `x` and `y` to the first and second elements in each pair, respectively.

***sequence unpacking***:This pattern of binding multiple names to multiple values in a fixed-length sequence is called *sequence unpacking*

**ranges**:

```py
>>> range(1, 10)  # Includes 1, but not 10
range(1, 10)

>>> for _ in range(3):
        print('Go Bears!')

Go Bears!
Go Bears!
Go Bears!
```

Ranges commonly appear as the expression in a `for` header to specify the number of times that the suite should be executed(rangeç”¨æ¥æŒ‡ç¤ºå¾ªç¯çš„æ¬¡æ•°)

```py
>>> odds = [1, 3, 5, 7, 9]
>>> [x+1 for x in odds]
[2, 4, 6, 8, 10]
```

The sub-expression `x+1` is evaluated with `x` bound to each element of `odds` in turn, and the resulting values are collected into a list

```py
>>> apply_to_all = lambda map_fn, s: list(map(map_fn, s))
>>> keep_if = lambda filter_fn, s: list(filter(filter_fn, s))
```

The definitions above are equivalent to applying the `list` constructor to the result of built-in `map` and `filter` calls.

è¿™é‡Œå»ºè®®ç»“åˆä»£ç å°†treeçš„æ¦‚å¿µå¤šæ¥å‡ éï¼š

Closure is the key to power in any means of combination because it permits us to create hierarchical structures â€” structures made up of parts, which themselves are made up of parts, and so on.ï¼ˆlistçš„å…ƒç´ ä¹Ÿç”¨listï¼Œè¿™æ ·çš„ç‰¹æ€§è®©æˆ‘ä»¬æ‹¥æœ‰äº†åˆ›å»ºä½“ç³»ç»“æ„çš„èƒ½åŠ›ï¼‰

A tree has a root label and a sequence of branches. 

Each branch of a tree is a tree. A tree with no branches is called a *leaf*. 

Any tree contained within a tree is called a *sub-tree* of that tree (such as a branch of a branch). The root of each sub-tree of a tree is called a node in that tree.

```py
>>> def tree(root_label, branches=[]):
        for branch in branches:
            assert is_tree(branch), 'branches must be trees'
        return [root_label] + list(branches)
>>> def label(tree):
        return tree[0]
>>> def branches(tree):
        return tree[1:]
    
# åˆ¤æ–­   

>>> def is_tree(tree):
        if type(tree) != list or len(tree) < 1:
            return False
        for branch in branches(tree):
            if not is_tree(branch):
                return False
        return True

>>> def is_leaf(tree):
        return not branches(tree)
```

Tree-recursive functions are also used to process trees. For example, the `count_leaves` function counts the leaves of a tree.

```py
>>> def count_leaves(tree):
      if is_leaf(tree):
          return 1
      else:
          branch_counts = [count_leaves(b) for b in branches(tree)]
          return sum(branch_counts)
>>> count_leaves(fib_tree(5))
8
```

 In a non-leaf partition tree:

- the left (index 0) branch contains all ways of partitioning `n` using at least one `m`,
- the right (index 1) branch contains partitions using parts up to `m-1`, and 
- the root label is `m`.

```py
>>> def partition_tree(n, m):
        """Return a partition tree of n using parts of up to m."""
        if n == 0:
            return tree(True)
        elif n < 0 or m == 0:
            return tree(False)
        else:
            left = partition_tree(n-m, m)
            right = partition_tree(n, m-1)
            return tree(m, [left, right])
>>> partition_tree(2, 2)
[2, [True], [1, [1, [True], [False]], [False]]]
```

ç­‰å›å¤´å†æ¥ç†è§£è¿™ä¸ªé—®é¢˜ï¼Œç°åœ¨æœ‰ç‚¹æ¶å¿ƒçš„ã€‚

csappçš„ç§»ä½æ“ä½œé—®é¢˜:

è‡ªå·±é˜…è¯»ç»†èŠ‚æ²¡åˆ°ä½ã€‚

> With x86-64, a shift instruction operating on data values that are w bits long **determines** the shift amount from the low-order m bits of register `%cl`, where `2^m = w`. The higher-order bits are ignored.
>
> So, for example, when register %cl has hexadecimal value 0xFF, then instruction salb would shift by 7, while salw would shift by 15, sall would shift by 31, and salq would shift by 63.

instructionï¼šsab -- w = 8bits -->m = 3ã€‚

controlï¼š20:00 - 21:40

*traight-line code*ï¼šwhere instructions follow one another in sequence 

Machine code provides two basic low-level mechanisms for implementing conditional behavior: it tests data values and then alters either the control flow or the data flow based on the results of these tests.

`cmp`:ä¸subç±»ä¼¼

`test`ï¼šAND ç±»ä¼¼

