# 4月份日报

## 4.1

愚人节快乐。

递归仍旧是我的难题，期待有朝一日它能成为我的强项。

## 4.2

今日todo

- [x] 下载bomblab上传git（15mins）
- [x] 阅读bomblab实验要求和题目设置（30mins）
- [ ] 继续阅读[【读薄 CSAPP】贰 机器指令与程序优化](https://wdxtub.com/csapp/thin-csapp-2/2016/04/16/)（2h）
- [x] cs61a：阅读[4.2涉及的代码和基本概念](https://composingprograms.netlify.app/4/2)（25mins）
- [x] 阅读[Lab 05: Iterators, Mutability](https://cs61a.org/lab/lab05/)题目（30mins）
- [x] 阅读[Disc 06: Iterators, Generators](https://cs61a.org/disc/disc06/)题目（30mins）
- [x] 解决[HW 04: Sequences, Trees](https://cs61a.org/hw/hw04/)问题，清理2.23之前的问题（1h）
- [ ] 阅读datalab的后四个问题（1h）
- [x] [了解gdb的基本用法](https://www.cs.cmu.edu/~213/recitations/rec02_handout.pdf)（30mins）
- [ ] [普京的最高理想！让欧洲战栗的女帝！《叶卡捷琳娜大帝》P1](https://www.bilibili.com/video/BV1xY4y1d7uk/?spm_id_from=333.337.search-card.all.click&vd_source=842936ebeedd7cce8bb2e1922b41edf1)
- [ ] [专题：回顾宫崎骏与久石让40年创作历程](https://www.bilibili.com/video/BV1Wx421D7r8/?spm_id_from=333.999.0.0&vd_source=842936ebeedd7cce8bb2e1922b41edf1)
- [x] [whynot视频](https://www.bilibili.com/video/BV1hc411f75N/?spm_id_from=333.999.0.0&vd_source=842936ebeedd7cce8bb2e1922b41edf1)
- [ ] 南京一日游推荐路线

bomblab要学哪些前置知识（重点学习）

1. 汇编指令及其用法
2. gdb调试的小技巧！！！（利用上面的[了解gdb的基本用法](https://www.cs.cmu.edu/~213/recitations/rec02_handout.pdf)）
3. 阅读[writeup](E:\code_life\1_project\csapp\03machine_prog\bomblab.pdf)
4. [slides](https://docs.google.com/presentation/d/1OjLAjPxhEXsElWsvmNnMGD-fzNCeGXip/edit#slide=id.p9)（超级重要！！，相当于做项目之前的知识储备）
5. 用者保存寄存器和被调用者保存寄存器的划分是为了在函数调用过程中管理寄存器的状态，确保在函数调用结束后，寄存器的值能够正确地恢复，不会影响到调用者或被调用者的代码，从而确保程序的正确性和可靠性。
6. %rax,%rsp,%rbp作用
7. Objdump
8. sscanf

迭代器是一种对象，提供对值逐一顺序访问的功能。

```py
>>> iterator = iter(primes)
>>> next(iterator)
>>> try:
        next(iterator)
    except StopIteration:#没有更多可用值
        print('No more values')
```

Python 中的 `for` 语句是对迭代器进行操作。 如果对象具有返回迭代器的 `__iter__` 方法（method），则表示对象是可迭代的。

将函数比作厨师：

> We're lazy (like an iterator) and used ChatGPT to generate a generator joke...
>
> why did the Python function become a chef?
>
> Because it was skilled at knowing when to "return" to the recipe and when to "yield" to improvisation!

# Homework 4: Sequences, ADT Trees

### Q1: Deep Map

Write a function `deep_map` that takes a list `s` and a one-argument function `f`. `s` may be a nested list, one that contain other lists. `deep_map` modifies `s` by replacing each element within `s` or any of the lists it contains with the result of calling `f` on that element.

`deep_map` returns `None` and should not create any new lists.

> **Hint:** `type(a) == list` will evaluate to `True` if `a` is a list.

```py
def deep_map(f, s):
    """Replace all non-list elements x with f(x) in the nested list s.

```

实现思路：

1. 利用递归，将大的嵌套列表元素，分解为一个个小的元素`elem`，并将所有元素`elem`按照`f`规则处理
2. base case：
   1. 一个列表中的所有元素遍历完毕后，返回`None`
   2. 遍历每个元素的时候，如果类型是`list`，则继续递推`deep_map(f, s)`处理此`list`类型的数据；如果不是则按照one-argument function `f`处理

翻译成代码：

```py
def deep_map(f, s):
    """Replace all non-list elements x with f(x) in the nested list s.

    >>> six = [1, 2, [3, [4], 5], 6]
    >>> deep_map(lambda x: x * x, six)
    >>> six
    [1, 4, [9, [16], 25], 36]
    >>> # Check that you're not making new lists
    >>> s = [3, [1, [4, [1]]]]
    >>> s1 = s[1]
    >>> s2 = s1[1]
    >>> s3 = s2[1]
    >>> deep_map(lambda x: x + 1, s)
    >>> s
    [4, [2, [5, [2]]]]
    >>> s1 is s[1]
    True
    >>> s2 is s1[1]
    True
    >>> s3 is s2[1]
    True
    """
    "*** YOUR CODE HERE ***"


    # base case1: Processing of traversing element "elem"
    # If it is not a list element, then for f(elem);
    # If it is a list element, call deep_map(f, elem) on the list element elem
    i = 0
    while i < len(s):
        if type(s[i]) == list:
            deep_map(f, s[i])
        else:
            s[i] = f(s[i])
        i += 1
    # base case: end of traversal
    # After traversing the last element, return None
    return None
```

### Q3: Balanced

Implement the `balanced` function, which returns whether `m` is a balanced mobile. A mobile is balanced if both of the following conditions are met:

1. The torque applied by its left arm is equal to the torque applied by its right arm. The torque of the left arm is the length of the left rod multiplied by the total mass hanging from that rod. Likewise for the right. For example, if the left arm has a length of `5`, and there is a `mobile` hanging at the end of the left arm of total mass `10`, the torque on the left side of our mobile is `50`.
2. Each of the mobiles hanging at the end of its arms is itself balanced.

Planets themselves are balanced, as there is nothing hanging off of them.

> **Reminder:** You may use the `total_mass` function above. Don't violate abstraction barriers. Instead, use the selector functions that have been defined.

递归判断一个`planet`是否平衡：

1. 力矩相同
2. 每个小的`planet`也是平衡的

那么实现思路：

1. base case如果`mobile`左右两边`end`均是星球，那么计算星球力矩是否相同：
   1. 力矩相同，返回`True`；
   2. 力矩不相同，返回`false`
2. 如果`mobile`左右两边力矩相同，判断此`mobile`的左右部分是否平衡
3. 两个条件不满足，则返回`false`

最终实现了这个问题，但是并不是按照这个思路来的（感觉递归很奇妙！）

## 4.3

todlist：

- [x] datalab回顾倒数后4题目回顾解决关键点
- [x] [普京的最高理想！让欧洲战栗的女帝！《叶卡捷琳娜大帝》P1](https://www.bilibili.com/video/BV1xY4y1d7uk/?spm_id_from=333.337.search-card.all.click&vd_source=842936ebeedd7cce8bb2e1922b41edf1)
- [x] 读完[【读薄 CSAPP】贰 机器指令与程序优化](https://wdxtub.com/csapp/thin-csapp-2/2016/04/16/)
- [x] 阅读[Lab 05: Iterators, Mutability](https://cs61a.org/lab/lab05/)题目+答案（30mins）
- [ ] 阅读[Disc 06: Iterators, Generators](https://cs61a.org/disc/disc06/)题目+答案（30mins）

**接受失败并学习**：接受每天无法完成所有计划的事实，并从中学习经验教训。失败并不意味着结束，而是为更好的开始积累经验。

现在是4.3号的17:00，感觉面对这些问题压力很大，总觉得“好困难”的样子。从而阻止了自己想继续下去的脚步。

这两天有一些挫败情绪让我感觉到有压力：

1. 妄图第一遍就解决问题。还是老问题，《学生为什么不喜欢上学》里面说的，当背景知识不够的时候，解决一个问题就会变得异常困难。那么就拿csapp的datalab来说明背景知识影响自己进度心情的例子：float部分题目，需要对IEEE的编码、32位单精度浮点数的值域、移位操作、逻辑与或非技巧很熟练，才能在解决这些问题的时候更加游刃有余。相反如果其中任何一个环节没掌握明白，都会造成自己做题困难，用时很长的问题。
2. 不合理的目标设置。想做出来，最起码理解问题是什么搞清楚，然后就是实现步骤，再最后落实到行动。

这两个问题的出现，让我学会从积极的角度看待失败和挫折，将其视为成长的机会而不是失败。坚持正向的思维和态度，激励自己不断前进。

现在有一个成长的机会摆在我的眼前：如何让自己学起来更愉悦？

那就是别设置太高期望，先混个眼熟大概，然后再仔细研究。最起码，你得先看一眼问题吧？然后稍微思考下解决思路吧？思考10分钟没有结果就赶紧看答案解析呗，哪里不会学哪里啊！答案分析完了自己解决一遍，不会没事，再看一遍答案分析，查缺补漏呗。

顺着情绪来吧，让自己开心一点宝贝。

多轮重复滚动的智慧，不就是降低背景知识缺乏带来的学习挫败吗。

加油宝贝！

今晚先将cs61a部分的问题先理解一遍，描述一下，明天试着解决，5分钟解决不了直接看答案分析。

## 补充知识：

`map` 函数将 `function` 应用于每个可迭代对象中相同位置的元素，返回一个迭代器（在 Python 2 中返回一个列表）

实例：

```py
# 使用内置函数
numbers = [1, 2, 3, 4, 5]
squared_numbers = map(lambda x: x ** 2, numbers)
print(list(squared_numbers))  # 输出: [1, 4, 9, 16, 25]
```

`map` 函数将函数应用于 `numbers` 列表中的每个元素，并返回新的列表或迭代器，包含了应用函数后的结果。

## 4.4

混个眼熟，大概浏览了一遍题目，对其中的问题大概了解了。

- 济南的特产和纪念品+济南旅游攻略
- 南京两天安排（重要！）

```py
(lambda t: [next(t) for _ in range(10)])(gen_fib())
```

调用`gen_fib()`十次。

快速浏览[【读薄 CSAPP】贰 机器指令与程序优化](https://wdxtub.com/csapp/thin-csapp-2/2016/04/16/)背景知识

1. 操作数是带括号的，括号的意思就是寻址：`movq (%rcx), %rax` 也就是说以 %rcx 寄存器中存储的地址去内存里找对应的数据，存到寄存器 %rax 中-- `temp = *p;`
2. 对于寻址来说，比较通用的格式是 `D(Rb, Ri, S)` -> `Mem[Reg[Rb]+S*Reg[Ri]+D]`

## 4.5

今天解决

- [x] [Lab 05: Iterators, Mutability](https://cs61a.org/lab/lab05/)题目（30mins）
- [x] [Disc 06: Iterators, Generators](https://cs61a.org/disc/disc06/)题目（30mins）
- [x] [ HW 05: Generators](https://cs61a.org/hw/hw05/)题目（1h）
- [x] 回顾csapp datalab float部分（1h）

`a, b = s, s[:]`

这是一个多重赋值语句，它将列表 `s` 赋值给变量 `a`，同时将列表 `s` 的副本（通过切片 `s[:]` 来实现）赋值给变量 `b`。

这样的赋值方式有一些细微但重要的区别：

- `a = s`：这种赋值方式只是将变量 `a` 指向了列表 `s`，即 `a` 和 `s` 共享同一个对象，修改其中一个变量的值会影响另一个变量。

- `b = s[:]`：这种赋值方式是创建了列表 `s` 的一个副本，并将这个副本赋值给变量 `b`，即 `b` 指向了一个新的列表对象，修改 `b` 的值不会影响 `s`。

60分要比100分重要！

`yield from`：生成器函数中委托生成器。这种语法使得生成器可以直接调用另一个生成器，并将其产生的值逐个返回，而不需要在外层生成器中显式地遍历并 yield 生成器内部的值。

```py
def partition_gen(n, m):
    """Yield the partitions of n using parts up to size m.

    >>> for partition in sorted(partition_gen(6, 4)):
    ...     print(partition)
    1 + 1 + 1 + 1 + 1 + 1
    1 + 1 + 1 + 1 + 2
    1 + 1 + 1 + 3
    1 + 1 + 2 + 2
    1 + 1 + 4
    1 + 2 + 3
    2 + 2 + 2
    2 + 4
    3 + 3
    """
    assert n > 0 and m > 0
    if n == m:
        yield str(n)
    if n - m > 0:
        for p in partition_gen(n - m, m):
            yield p + ' + ' + str(m)
    if m > 1:
        yield from partition_gen(n, m-1)
```

`yield from partition_gen(n, m - 1)` 实际上相当于遍历调用 `partition_gen(n, m - 1)` 生成器所产生的所有值，并将这些值逐个 yield 出来。

具体来说，`yield from` 语句会将调用的生成器产生的值逐个返回给外层的生成器，就好像在外层生成器中手动遍历并 yield 这些值一样。这样做的好处是可以简化代码，使得生成器的使用更加清晰和简洁。

## 4.8

记录时长和具体问题。

10:00-10:30：记忆3.2中的寄存器及其大体功能；记忆操作数三个来源（立即数、寄存器和内存）及其形式。

10:30-11:00：如图。数据转移指令的格式及其后缀意义。

![image-20240408104834004](E:\backup\crx\cs\cs61a\2024notes\image\image-20240408104834004.png)

14:00-15:00：在x86中，栈是朝着低地址生长的。With x86-64, stacks grow toward lower addresses, so pushing involves decrementing the stack pointer (register %rsp) and storing to memory,while popping involves reading from memory and incrementing the stack pointer.

`pushq %rbp` is equivalent to that of the pair of instructions:

```assembly
subq $8,%rsp 		#Decrement stack pointer
movq %rbp,(%rsp) 	#Store %rbp on stack
```

the instruction `popq %rax` is equivalent to the following pair of instructions:

```assembly
movq (%rsp),%rax 	#Read %rax from stack
addq $8,%rsp 		#Increment stack pointer
```

csapp总共用时3h，掌握了寄存器，mov指令和stack部分的知识，因为学习的内容都偏向记忆，所以学习较为轻松。

15:40开始，学习cs61a的2.5节。

```py
>>> class Account:
   		def __init__(self, account_holder):
            self.balance = 0
            self.holder = account_holder
```

- 构造函数及其参数。第一个 `self` 绑定到新创建的 `Account` 对象。第二个参数 `account_holder` 是类进行实例化时的参数。

- 内置函数 `getattr` 可以按名称返回对象的属性`getattr(spock_account, 'balance')`

- 调用方法：

  ```py
  >>> Account.deposit(spock_account, 1001)	# 函数 deposit 接受两个参数
  1011
  >>> spock_account.deposit(1000) 			# 方法 deposit 接受一个参数
  2011
  ```

- 在子类中未指定的任何内容都会被自动假定为与父类的行为一样

15:40-16:12：完成阅读2.5节内容，准备阅读2.7节内容。

16:12-18:30：晚饭，处理鸡肉，推荐手机+休息25mins

通过 `@property` 装饰器，可以将一个方法转变为类的一个属性，而不需要使用方法调用的括号。这种方式可以使得代码更加清晰和简洁，并且符合 Python 的面向对象编程风格

18:30-17:30：阅读2.7和2.8内容。

17:30-20:16：搜集sicp学习方面的资料：

[Why Structure and Interpretation of Computer Programs matters](https://people.eecs.berkeley.edu/~bh/sicp.html)：

- In my SICP-based course at Berkeley, we spend the first hour on notation and that's all we need; for the rest of the semester we're learning ideas, not syntax. 
- Once you learned the big ideas, they thought, and this is my experience also, learning another programming language isn't a big deal; it's a chore for a weekend.
- The idea that computer science should be about ideas, not entirely about programming practice, has since widened to include non-technical ideas about the context and social implications of computing

学好里面的思想的前提，就是需要练习巩固概念吧？

学习了下耶克斯多德森定律，一个关于动机和效率之间的关系图表。总结就是两句话：

1. 动机和效率并不成正比，往往成一个倒U型曲线。要及时观察自己的心态感受，欲速则不达，求而不得。

2. 困难的问题需要较少的动机，才会有更好地体验。

也可以说将大问题分解为容易做的小问题。这个小问题的度就是简单无脑（类似铺垫背景知识），等你解决这些小问题多了，才发现这个问题已经解决的差不多了。要多注意自己的真实感受，尊重自己并爱护自己的好奇心和进取心。

因为它们是很脆弱的。

## 4.9

cs61a

1.7递归学习：

1. `sum_digits(738)`做了什么

```py
>>> def sum_digits(n):
        """Return the sum of the digits of positive integer n."""
        if n < 10:
            return n
        else:
            all_but_last, last = n // 10, n % 10
            return sum_digits(all_but_last) + last
>>> sum_digits(738)
```

2. sum_digits的base case是什么？
3.  why？That is, we should not care about how `fact(n-1)` is implemented in the body of `fact`; we should simply trust that it computes the factorial of `n-1`.*recursive leap of faith*，相信`fact(n-1)`的正确性，而不是关注`fact(n-1)`的具体实现。
4. tree recursion, in which a function calls itself more than once.but why called they are tree recurision?因为问题会被分解的更小但是数量会变多。

1.7讲了递函数抽象的具体化：将大问题化解为小问题的递归，这样就可以省去每一步的具体实现。只需要考虑，如何将这个大问题化解为同样的几个较小的问题，而不需要考虑这几个较小的问题具体如何实现。所谓“递归的信仰之跃”就是这样。

开始学习第二章，这一章讲了如何将数据做成抽象的。

2.1Introduction

-  回顾Chapter 1：create functional abstractions by giving names to processes
- 这章要干嘛：The type for most values must be defined by programmers using the means of combination and abstraction that we will develop in this chapter
- The following sections introduce more of Python's native data types, **focusing on the role they play in creating useful data abstractions**.

List：the difference between `append()` and `extend()`

- `append()`：adds a single item to the end of the list（将参数中的列表元素看做一个整体，作为一个元素插入列表中）
-  `extend()` ：method takes one argument, a list, and appends each of the items of the argument to the original list.（将参数中的列表元素展开，分别插入源列表中）

## 4.10

2.2数据抽象😉（其实没必要记录这些话，因为很多都是废话了，主要是通过案例理解思想）

- shield parts of our program that compute using positions from the details of how those positions are represented.
- isolating the parts of a program that deal with how data are represented from the parts that deal with how data are manipulated（将数据的表示和数据的运算处理隔离-你只是想要这个数据怎么用，而不考虑这个数据是怎么来的）
- 回顾chapter1：When we create a functional abstraction, the details of how a function is implemented can be suppressed, and the particular function itself can be replaced by any other function with the same overall behavior（函数抽象：只需要知道怎么用函数，不需要考虑具体实现，只要实现相同的行为，其他函数也可以）
- 点明chapter2：Analogously, data abstraction isolates how a compound data value is used from the details of how it is constructed
- In addition, the appropriate relationship must hold among the constructor and selectors
- list并不是唯一表示有理数的分子分母的必要结构，至于要有一对值的结构就可以。后面就用高阶函数证明了这个。The point of exhibiting the functional representation of a pair is not that Python actually works this way (lists are implemented more directly, for efficiency reasons) but that it could work this way. 

2.2总结：

数据抽象的意义在于，可以将特定的数据操作和这个数据怎么实现的隔离开，这样的数据抽象保证了程序的模块化开发。

csapp：

- registers are used to store integer data as well as pointers.
- effective address：a computed address
- mov指令：The **source operand** designates a value that is immediate, stored in a register,
  or stored in memory. The **destination operand** designates a location that is either a
  register or a memory address
- pushing involves decrementing the stack pointer (register %rsp) and storing to memory
- popping involves reading from memory and incrementing the stack pointer.
- leaq:the instruction copies the effective address to the destination.This instruction can be used to generate pointers for later memory references
- leaq和movq的区别：movq s,d的第一个参数如果不是立即数或者寄存器，那么将会从对应的地址中找到数据。而leaq则只是将第一个参数作为地址传递给destination operand。

## 4.11

今天早晨首先回顾了下最近几天的日报，发现记录学习的进度蛮好的。

对所学知识进行简单总结，就能在日后翻阅的时候很快检索到对应的信息，省去了重新整理的时间。

今天主要是将2.3和2.4节不会的单词查出来而已，放轻松。

学习2.3序列一节，在学习之前，先看看自己大概要学什么，做到心中有数：[CS61A阅读指南](https://www.cnblogs.com/shangshankandashu/articles/18046806)

2.3Sequences

- A sequence is an ordered collection of values
- many kinds of sequences all share common behavior:length and element selection

10:04-11:30（非常牛逼！）

```py
for <name> in <expression>:
    <suite>
```

- `for` loop introduces yet another way in which the environment can be updated by a statement.

```py
>>> pairs = [[1, 2], [2, 2], [2, 3], [4, 4]]
>>> same_count = 0
>>> for x, y in pairs:
        if x == y:
            same_count = same_count + 1
```

A `for` statement may include multiple names in its header to "unpack" each element sequence into its respective elements.

The following `for` statement with two names in its header will bind each name `x` and `y` to the first and second elements in each pair, respectively.

***sequence unpacking***:This pattern of binding multiple names to multiple values in a fixed-length sequence is called *sequence unpacking*

**ranges**:

```py
>>> range(1, 10)  # Includes 1, but not 10
range(1, 10)

>>> for _ in range(3):
        print('Go Bears!')

Go Bears!
Go Bears!
Go Bears!
```

Ranges commonly appear as the expression in a `for` header to specify the number of times that the suite should be executed(range用来指示循环的次数)

```py
>>> odds = [1, 3, 5, 7, 9]
>>> [x+1 for x in odds]
[2, 4, 6, 8, 10]
```

The sub-expression `x+1` is evaluated with `x` bound to each element of `odds` in turn, and the resulting values are collected into a list

```py
>>> apply_to_all = lambda map_fn, s: list(map(map_fn, s))
>>> keep_if = lambda filter_fn, s: list(filter(filter_fn, s))
```

The definitions above are equivalent to applying the `list` constructor to the result of built-in `map` and `filter` calls.

这里建议结合代码将tree的概念多来几遍：

Closure is the key to power in any means of combination because it permits us to create hierarchical structures — structures made up of parts, which themselves are made up of parts, and so on.（list的元素也用list，这样的特性让我们拥有了创建体系结构的能力）

A tree has a root label and a sequence of branches. 

Each branch of a tree is a tree. A tree with no branches is called a *leaf*. 

Any tree contained within a tree is called a *sub-tree* of that tree (such as a branch of a branch). The root of each sub-tree of a tree is called a node in that tree.

```py
>>> def tree(root_label, branches=[]):
        for branch in branches:
            assert is_tree(branch), 'branches must be trees'
        return [root_label] + list(branches)
>>> def label(tree):
        return tree[0]
>>> def branches(tree):
        return tree[1:]
    
# 判断   

>>> def is_tree(tree):
        if type(tree) != list or len(tree) < 1:
            return False
        for branch in branches(tree):
            if not is_tree(branch):
                return False
        return True

>>> def is_leaf(tree):
        return not branches(tree)
```

Tree-recursive functions are also used to process trees. For example, the `count_leaves` function counts the leaves of a tree.

```py
>>> def count_leaves(tree):
      if is_leaf(tree):
          return 1
      else:
          branch_counts = [count_leaves(b) for b in branches(tree)]
          return sum(branch_counts)
>>> count_leaves(fib_tree(5))
8
```

 In a non-leaf partition tree:

- the left (index 0) branch contains all ways of partitioning `n` using at least one `m`,
- the right (index 1) branch contains partitions using parts up to `m-1`, and 
- the root label is `m`.

```py
>>> def partition_tree(n, m):
        """Return a partition tree of n using parts of up to m."""
        if n == 0:
            return tree(True)
        elif n < 0 or m == 0:
            return tree(False)
        else:
            left = partition_tree(n-m, m)
            right = partition_tree(n, m-1)
            return tree(m, [left, right])
>>> partition_tree(2, 2)
[2, [True], [1, [1, [True], [False]], [False]]]
```

等回头再来理解这个问题，现在有点恶心的。

csapp的移位操作问题:

自己阅读细节没到位。

> With x86-64, a shift instruction operating on data values that are w bits long **determines** the shift amount from the low-order m bits of register `%cl`, where `2^m = w`. The higher-order bits are ignored.
>
> So, for example, when register %cl has hexadecimal value 0xFF, then instruction salb would shift by 7, while salw would shift by 15, sall would shift by 31, and salq would shift by 63.

instruction：sab -- w = 8bits -->m = 3。

control：20:00 - 21:40

*traight-line code*：where instructions follow one another in sequence 

Machine code provides two basic low-level mechanisms for implementing conditional behavior: it tests data values and then alters either the control flow or the data flow based on the results of these tests.

`cmp`:与sub类似

`test`：AND 类似

## 4.12

今天简单浏览cs61a代码。

## 4.15

新的一周在建邺区开始了。

> ### Q4: Recursive Hailstone
>
> Recall the `hailstone` function from [Homework 1](https://cs61a.org/hw/hw01/). First, pick a positive integer `n` as the start. If `n` is even, divide it by 2. If `n` is odd, multiply it by 3 and add 1. Repeat this process until `n` is 1. Complete this recursive version of `hailstone` that prints out the values of the sequence and returns the number of steps.

```py
def hailstone(n):
    """Print out the hailstone sequence starting at n, 
    and return the number of elements in the sequence.
    >>> a = hailstone(10)
    10
    5
    16
    8
    4
    2
    1
    >>> a
    7
    >>> b = hailstone(1)
    1
    >>> b
    1
    """
    print(n)
    if n % 2 == 0:
        return even(n)
    else:
        return odd(n)

def even(n):
    return 1 + hailstone(n // 2)

def odd(n):
    if n == 1:
        return 1
    else:
        return 1 + hailstone(3 * n + 1)
```

学习点：步数记录

## 4.16

> ### Q2: Digit Distance
>
> For a given integer, the *digit distance* is the sum of the absolute differences between consecutive digits. For example:
>
> - The digit distance of `6` is `0`.
> - The digit distance of `61` is `5`, as the absolute value of `6 - 1` is `5`.
> - The digit distance of `71253` is `12` (`6 + 1 + 3 + 2`).
>
> Write a function that determines the digit distance of a given positive integer. You must use recursion or the tests will fail.

```py
def digit_distance(n):
    """Determines the digit distance of n.

    >>> digit_distance(3)
    0
    >>> digit_distance(777)
    0
    >>> digit_distance(314)
    5
    >>> digit_distance(31415926535)
    32
    >>> digit_distance(3464660003)
    16
    >>> from construct_check import check
    >>> # ban all loops
    >>> check(HW_SOURCE_FILE, 'digit_distance',
    ...       ['For', 'While'])
    True
    """
    if n < 10:
        return 0
    return abs(n % 10 - (n // 10) % 10) + digit_distance(n // 10)
```

待解决的问题：

- [x] 函数调用时，查看入参在哪几个寄存器中：i r查看寄存器
- [x] 函数返回的时候，返回参数在哪：调用完毕后，查看哪个寄存器存放返回值

## 4.17

重看2.2节

- The general technique of isolating the parts of a program that deal with how data are represented from the parts that deal with how data are manipulated is a powerful design methodology called data abstraction.
- In general, the underlying idea of data abstraction is to identify a basic set of operations in terms of which all manipulations of values of some kind will be expressed, and then to use only those operations in manipulating the data. 
- Abstraction barriers make programs easier to maintain and to modify. The fewer functions that depend on a particular representation, the fewer changes are required when one wants to change that representation.

csapp：17：04开始看control一节

- two basic low-level mechanisms for implementing conditional
  behavior: it tests data values and then alters either the control flow or the
  data flow based on the results of these tests.
- 首先讲解实行条件判断指令的两个方法，然后讲解loop和switch语句
- 首先静心阅读小土刀的博客，做到心中有数。
- 这就发现了，其实这四个条件代码，是用来标记上一条命令的结果的各种可能的，是自动会进行设置的。
- rsp寄存器存放的是栈顶的地址。

3.7节

- 程序是一种抽象
- 机器级代码为了支持程序运转，具有control passing、passing data和allocating and deallocating memory的功能。
- 通过减stack pointer合适的值，就可用来存放数据
- p调用q的时候，会将执行完毕函数q后的程序重新开始的地址保存起来。

## 4.18

> ### Q2: Max Product
>
> Implement `max_product`, which takes a list of numbers and returns the maximum product that can be formed by multiplying together non-consecutive elements of the list. Assume that all numbers in the input list are greater than or equal to 1.

```py
def max_product(s):
    """Return the maximum product of non-consecutive elements of s.

    >>> max_product([10, 3, 1, 9, 2])   # 10 * 9
    90
    >>> max_product([5, 10, 5, 10, 5])  # 5 * 5 * 5
    125
    >>> max_product([])                 # The product of no numbers is 1
    1
    """
    if s == []:
        return 1
    if len(s) == 1:
        return s[0]
    else:
        return max(s[0] * max_product(s[2:]), max_product(s[1:]))
        # OR
        return max(s[0] * max_product(s[2:]), s[1] * max_product(s[3:]))
```

分析：

- In every case, `max_product` is called on a list of numbers and its return value is treated as a number.
- 第二个base case的留存：Since this expression never refers to s[1], and s[2:] evaluates to the empty list even for a one-element list `s`, the second base case `(len(s) == 1)` can be omitted if this recursive case is used.

发现两个题目都有很大的提升空间。

或许应该欣赏下这两个题目，写一个blog记录下解决两个问题的心路历程。

其实今天下午有点心急了，做好当下的事情就好了宝贝。

> ### Q3: Sum Fun
>
> Implement `sums(n, m)`, which takes a total `n` and maximum `m`. It returns a list of all lists:
>
> 1. that sum to `n`,
> 2. that contain only positive numbers up to `m`, and
> 3. in which no two adjacent numbers are the same.
>
> Two lists with the same numbers in a different order should both be returned.
>
> Here's a recursive approach that matches the template below: build up the `result` list by building all lists that sum to `n` and start with `k`, for each `k` from 1 to `m`. For example, the result of `sums(5, 3)` is made up of three lists:
>
> - `[[1, 3, 1]]` starts with 1,
> - `[[2, 1, 2], [2, 3]]` start with 2, and
> - `[[3, 2]]` starts with 3.
>
> **Hint:** Use `[k] + s` for a number `k` and list `s` to build a list that starts with `k` and then has all the elements of `s`.
>
> ```py
> >>> k = 2
> >>> s = [4, 3, 1]
> >>> [k] + s
> [2, 4, 3, 1]
> ```

```py
def sums(n, m):
    """Return lists that sum to n containing positive numbers up to m that
    have no adjacent repeats.

    >>> sums(5, 1)
    []
    >>> sums(5, 2)
    [[2, 1, 2]]
    >>> sums(5, 3)
    [[1, 3, 1], [2, 1, 2], [2, 3], [3, 2]]
    >>> sums(5, 5)
    [[1, 3, 1], [1, 4], [2, 1, 2], [2, 3], [3, 2], [4, 1], [5]]
    >>> sums(6, 3)
    [[1, 2, 1, 2], [1, 2, 3], [1, 3, 2], [2, 1, 2, 1], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]
    """
    if n < 0:
        return []
    if n == 0:
        sums_to_zero = []     # The only way to sum to zero using positives
        return [sums_to_zero] # Return a list of all the ways to sum to zero
    result = []
    # 每次结果以k开头
    for k in range(1, m + 1):
        result = result + [ ___ for rest in ___ if rest == [] or ___ ]
    return result
```

题目分析：

- 与分割数类似，但是加了一个限制条件，即两个相邻的数字不能是相同的。

- 将问题递推到更小的问题：

  创建一个从`k`开始的新列表，而剩余的列表元素则是求和为`n-k`的序列，并且剩余元素的第一个元素，不能是`k`。

  剩余列表元素可以记录为`rest`（例如[1,2,3]，就可以分为[1] + [2,3]，其中`k`为1，`rest`为[2,3]）。

  `rest`是从`sums(n-k, m)`中获取的，但是限制条件为`rest[0] != k`，即确保`[k] + rest`后产生的新序列中，第一个和第二个索引数据不能均为为`k`。

解决：

- 第一个空，拼装结果：`[k] + rest`
- 第二个空，`rest`列表的数据，是将`n`减去`k`后的值，再对`m`进行`sum`处理后产生的列表：`sum(n-k,m)`
- 第三个空，限制条件“相邻元素不能相同”：`rest[0] != k`。

要相信递归的信仰之跃。

如果不知道怎么实现的，那就相信它能实现就好了。😎🎊

## 4.19

今天简单介绍下程序的执行流程吧。

这里确定一个程序，进行单步调试。

明确要解决什么问题：

首先就是控制转移：

1. 一个函数调用另一个函数的时候，rsp和rip发生了什么，为什么这么做？
2. 函数调用返回的时候，rsp和rip发生了什么？为什么？
3. 用栈保存返回地址，那么函数返回的时候怎么获取到的这个返回地址呢？

数据转移：

1. 参数一般会放在那些寄存器中？

2. 当多于参数寄存器的数量的入参，怎么保存多余的入参？

3. `char a4, char *a4p`的实际存放地址：

   ```assembly
   a4 at %rsp+8 ( 8 bits)
   a4p at %rsp+16 (64 bits)
   ```

   问题：为什么a4参数在前，但是放在栈中就是低地址的数据（更容易存取），a4p参数在后面，但是为什么会被存放在栈的高地址处？

- `rip` 寄存器用于存储下一条指令的地址，控制程序的执行流程；而 `rsp` 寄存器用于管理栈空间，指向当前线程的栈顶，用于存储函数调用信息和局部变量等

## 4.21

子函数被调用时候做了什么？

- 保存返回地址：为了在子函数执行完毕后可以继续原来的进程，当前指令的下一行指令地址（即 ip 寄存器的值）需要存入栈内存。
- 改变程序计数器：子函数的内存地址放入ip中，以便于执行命令。

## 4.22

> ### Q3: Buying Fruit
>
> Implement `buy`, which takes a list of `required_fruits` (strings), a dictionary `prices` (strings for key, positive integers for value), and a `total_amount` (integer). It prints all the ways to buy some of each required fruit so that the total price equals `total_amount`. You must include at least one of every fruit in `required_fruit` and cannot include any other fruits that are not in `required_fruit`.

> The `display` function will be helpful. You can call `display` on a `fruit` and its `count` to create a string containing both.
>
> What does `fruits` and `amount` represent? How are they used in the recursive?

```py
def buy(required_fruits, prices, total_amount):
    """Print ways to buy some of each fruit so that the sum of prices is amount.

    >>> prices = {'oranges': 4, 'apples': 3, 'bananas': 2, 'kiwis': 9}
    >>> buy(['apples', 'oranges', 'bananas'], prices, 12)
    [2 apples][1 orange][1 banana]
    >>> buy(['apples', 'oranges', 'bananas'], prices, 16)
    [2 apples][1 orange][3 bananas]
    [2 apples][2 oranges][1 banana]
    >>> buy(['apples', 'kiwis'], prices, 36)
    [3 apples][3 kiwis]
    [6 apples][2 kiwis]
    [9 apples][1 kiwi]
    """
    def add(fruits, amount, cart):
        if fruits == [] and amount == 0:
            print(cart)
        elif fruits and amount > 0:
            fruit = fruits[0]
            price = ____
            for k in ____:
                add(____, ____, ____)
    add(required_fruits, total_amount, '')

def display(fruit, count):
    """Display a count of a fruit in square brackets.

    >>> display('apples', 3)
    '[3 apples]'
    >>> display('apples', 1)
    '[1 apple]'
    """
    assert count >= 1 and fruit[-1] == 's'
    if count == 1:
        fruit = fruit[:-1]  # get rid of the plural s
    return '[' + str(count) + ' ' + fruit + ']'
```

思路：只要钱够用，就可以买要求的水果，数量不限。

这样的问题就分解为挑完第一种水果任意数量的后，转而用剩下的钱挑选第二种水果任意数量，以此类推。

disc5：

> ### Q2: Has Path
>
> Implement `has_path`, which takes a tree `t` and a list `p`. It returns whether there is a path from the root of `t` with labels `p`. For example, `t1` has a path from its root with labels `[3, 5, 6]` but not `[3, 4, 6]` or `[5, 6]`.
>
> **Important**: Before trying to implement this function, discuss these questions from lecture about the recursive call of a tree processing function:
>
> - What recursive calls will you make?
> - What type of values do they return?
> - What do the possible return values mean?
> - How can you use those return values to complete your implementation?

```py
def has_path(t, p):
    """Return whether tree t has a path from the root with labels p.

    >>> t2 = tree(5, [tree(6), tree(7)])
    >>> t1 = tree(3, [tree(4), t2])
    >>> has_path(t1, [5, 6])        # This path is not from the root of t1
    False
    >>> has_path(t2, [5, 6])        # This path is from the root of t2
    True
    >>> has_path(t1, [3, 5])        # This path does not go to a leaf, but that's ok
    True
    >>> has_path(t1, [3, 5, 6])     # This path goes to a leaf
    True
    >>> has_path(t1, [3, 4, 5, 6])  # There is no path with these labels
    False
    """
    if p == [label(t)]:  # when len(p) is 1
        return True
    elif label(t) != p[0]:
        return False
    else:
        "*** YOUR CODE HERE ***"
        return any(has_path(b, p[1:]) for b in branches(t))
```

- **What recursive calls will you make?**

  对比当前树`t`的label和路径第一个值是否相同，如果相同，对比`t`剩余分支的label是否与路径剩余元素的第一个值相同。转换为

  As you usual, you will call `has_path` on each branch `b`. You'll make this call after comparing `p[0]` to `label(t)`, and so the second argument to `has_path` will be the rest of `p`: `has_path(b, p[1:])`.

- **What type of values do they return?**

  bool

csapp：

在举例`所以 call 指令实际上等同于下面操作:`时，可以补充下`push %rip`的对应指令集：

```assembly
subq $8,%rsp 	#Decrement stack pointer
movq %rip,(%rsp) #Store %rip on stack
```

这里作者应该是为了具体讲解`call`而故意屏蔽掉了`push`命令的复杂度。

`int argc`和 `char *argv[]`：

`int main(int argc, char *argv[])` 是 C/C++ 程序中 `main` 函数的标准签名，用于接收命令行参数。让我们分解这个函数签名的每个部分（`int argc`和 `char *argv[]`）：

- `int argc`：是表示命令行参数个数的整数类型参数，即 argument count。`argc` 的值至少为 `1`，因为第一个参数是程序本身的名称，后面可以跟随零个或多个命令行参数。
- `char *argv[]`：是一个指向字符指针数组的参数，即 argument vector。`argv` 中的每个元素都是一个指向以空字符 `\0` 结尾的字符串的指针，表示一个命令行参数。

综合起来，`int main(int argc, char *argv[])` 的意思是定义一个 `main` 函数，该函数接受两个参数：`argc` 表示命令行参数个数，`argv` 是一个指针数组，每个元素都是一个字符串，表示一个命令行参数。

举个例子，假设你在命令行中输入 `./program arg1 arg2`，那么在程序中 `argc` 的值为 `3`，`argv[0]` 是程序名称 `"./program"`，`argv[1]` 是参数 `"arg1"`，`argv[2]` 是参数 `"arg2"`。

## 4.23

- [ ] 搜索鬼片

为什么我的盲打还是很慢？训练了这么久，好像没有达到相应的预期。

答：现在加入新的练习网站[typingclub](https://www.typingclub.com/sportal/)，里面的中文特殊训练课程已经加入了训练计划中。

hw04中，对于balanced的代码，我觉得写得蛮不错的，贴一下，等会发帖子。

> Q3: Balanced
> Implement the balanced function, which returns whether m is a balanced mobile. A mobile is balanced if both of the following conditions are met:
>
> The torque applied by its left arm is equal to the torque applied by its right arm. The torque of the left arm is the length of the left rod multiplied by the total mass hanging from that rod. Likewise for the right. For example, if the left arm has a length of 5, and there is a mobile hanging at the end of the left arm of total mass 10, the torque on the left side of our mobile is 50.
> Each of the mobiles hanging at the end of its arms is itself balanced.
> Planets themselves are balanced, as there is nothing hanging off of them.

```py
def torque(len, mass):
    return len * mass

def torque_of_arm(arm):
    len = length(arm)
    mass = total_mass(end(arm))
    return torque(len, mass)

def balanced(m):
    """Return whether m is balanced.

    >>> t, u, v = examples()
    >>> balanced(t)
    True
    >>> balanced(v)
    True
    >>> p = mobile(arm(3, t), arm(2, u))
    >>> balanced(p)
    False
    >>> balanced(mobile(arm(1, v), arm(1, p)))
    False
    >>> balanced(mobile(arm(1, p), arm(1, v)))
    False
    >>> from construct_check import check
    >>> # checking for abstraction barrier violations by banning indexing
    >>> check(HW_SOURCE_FILE, 'balanced', ['Index'])
    True
    """
    "*** YOUR CODE HERE ***"
    def is_torque_balanced(mobile):
        left_torque = torque_of_arm(left(mobile))
        right_torque = torque_of_arm(right(mobile))
        return left_torque == right_torque

    if is_planet(m):
        return True
   
    if is_torque_balanced(m):
        return balanced(end(left(m))) and balanced(end(right(m)))
    else:
        return False
```

分析我觉得牛逼在哪里。😎

牛逼在将力矩的具体实现和判断模型的力矩是否平衡分开了。这样的好处是判断力矩是否平衡的函数`is_torque_balanced(mobile)`只需要关注`mobile`的具体实现，而不需要关心力矩的具体实现。（函数抽象的作用）

csapp单步调试：

```bash
(gdb) bt
#1  0x0000000000401347 in strings_not_equal ()
#2  0x0000000000400eee in phase_1 ()
#3  0x0000000000400e3f in main (argc=<optimized out>, argv=<optimized out>) at bomb.c:74
```

这里的执行流程为：

```c
    /* Hmm...  Six phases must be more secure than one phase! */
    input = read_line();             /* Get input                   */
    phase_1(input);                  /* Run the phase               */
    phase_defused();                 /* Drat!  They figured it out!
				      * Let me know how they did it. */
    printf("Phase 1 defused. How about the next one?\n");
```

可以发现只有`phase_1`正常返回的时候，才会执行下面的`phase_defused()`函数将阶段1的炸弹拆除。现在就想让`phase_1`正常执行完，那就需要让此函数中所有不正常的跳转都不执行。

首先查看`phase_1`函数的汇编代码：

```assembly
(gdb) disassemble phase_1
Dump of assembler code for function phase_1:
   0x0000000000400ee0 <+0>:     sub    $0x8,%rsp
   0x0000000000400ee4 <+4>:     mov    $0x402400,%esi               #0x402400 --> %esi
   0x0000000000400ee9 <+9>:     call   0x401338 <strings_not_equal> #调用strings_not_equal函数
   0x0000000000400eee <+14>:    test   %eax,%eax                    
   0x0000000000400ef0 <+16>:    je     0x400ef7 <phase_1+23>		#如果%eax值为0，则正常返回
   0x0000000000400ef2 <+18>:    call   0x40143a <explode_bomb>		#如果%eax值不为0，则触发炸弹
   0x0000000000400ef7 <+23>:    add    $0x8,%rsp
   0x0000000000400efb <+27>:    ret
```

`test` 指令将 `%eax` 寄存器的值与自身进行逻辑与操作，并设置标志位，但不修改 `%eax` 的值。如果 `%eax` 的值为零，则标志位会被置为零；如果 `%eax` 的值不为零，则标志位会被置为非零。

如果想让程序正常执行，那么就需要让获得`%esi`寄存器值的函数`strings_not_equal`返回值为0。

下面查看函数`strings_not_equal`的代码，并且分析下主要的控制代码，看看如何让返回值为0：

## 4.24

```assembly
(gdb) disassemble strings_not_equal 
Dump of assembler code for function strings_not_equal:
   0x0000000000401338 <+0>:     push   %r12
   0x000000000040133a <+2>:     push   %rbp
   0x000000000040133b <+3>:     push   %rbx
   0x000000000040133c <+4>:     mov    %rdi,%rbx						
   0x000000000040133f <+7>:     mov    %rsi,%rbp
   0x0000000000401342 <+10>:    call   0x40131b <string_length>			# 将%rbx和 %rbp传入函数string_length
   0x0000000000401347 <+15>:    mov    %eax,%r12d						# 第一次返回值%eax赋给 %r12d
   0x000000000040134a <+18>:    mov    %rbp,%rdi						# %rbp —> %rdi
   0x000000000040134d <+21>:    call   0x40131b <string_length>			# %rdi的值作为入参	
   0x0000000000401352 <+26>:    mov    $0x1,%edx
   0x0000000000401357 <+31>:    cmp    %eax,%r12d 						# 对比两次函数长度调用的结果
   0x000000000040135a <+34>:    jne    0x40139b <strings_not_equal+99>  # 若长度不同，返回1
   
   # 以上代码均为判断两个字符串的长度是否相同，现在的%r12d、%eax分别保存了第一次和第二次的函数调用结果，即两个字符串的长度
   # 寄存器rbx 和 rbp 分别保存着函数的两个参数
   
   # 35c-41:若函数第一个参数低8位为0，则返回0
   0x000000000040135c <+36>:    movzbl (%rbx),%eax						# 参数1的低1位字节赋值给eax
   0x000000000040135f <+39>:    test   %al,%al							# %al & %al
   0x0000000000401361 <+41>:    je     0x401388 <strings_not_equal+80>  # Jump condition:ZF---(Equal / zero)
   # 35c-37f:对比参数1和参数2的每个字节，直到发现不相等的字符或者到达字符串结尾
   0x0000000000401363 <+43>:    cmp    0x0(%rbp),%al					# 参数2的低1位字节与数1的低1位字节对比
   0x0000000000401366 <+46>:    je     0x401372 <strings_not_equal+58>	# 如果相等，则对比更高1位的字节
   0x0000000000401368 <+48>:    jmp    0x40138f <strings_not_equal+87>  # 不相等，返回错误1
   0x000000000040136a <+50>:    cmp    0x0(%rbp),%al					
   0x000000000040136d <+53>:    nopl   (%rax)
   0x0000000000401370 <+56>:    jne    0x401396 <strings_not_equal+94> #若参数1、2的第2个字节不同，则返回错误1
   0x0000000000401372 <+58>:    add    $0x1,%rbx
   0x0000000000401376 <+62>:    add    $0x1,%rbp
   0x000000000040137a <+66>:    movzbl (%rbx),%eax
   0x000000000040137d <+69>:    test   %al,%al
   0x000000000040137f <+71>:    jne    0x40136a <strings_not_equal+50>
   
   
   0x0000000000401381 <+73>:    mov    $0x0,%edx
   0x0000000000401386 <+78>:    jmp    0x40139b <strings_not_equal+99>
   0x0000000000401388 <+80>:    mov    $0x0,%edx
   0x000000000040138d <+85>:    jmp    0x40139b <strings_not_equal+99>
   0x000000000040138f <+87>:    mov    $0x1,%edx
   0x0000000000401394 <+92>:    jmp    0x40139b <strings_not_equal+99>
   0x0000000000401396 <+94>:    mov    $0x1,%edx
   0x000000000040139b <+99>:    mov    %edx,%eax
   0x000000000040139d <+101>:   pop    %rbx
   0x000000000040139e <+102>:   pop    %rbp
   0x000000000040139f <+103>:   pop    %r12
   0x00000000004013a1 <+105>:   ret    
End of assembler dump.
```

这里的几个比较重要的跳转代码：

`0x40139b <strings_not_equal+99>`：函数将以`%edx`作为返回值返回。 

`0x401388 <strings_not_equal+80>`：返回0。

`0x40136a <strings_not_equal+50>`：比较 `%al` 寄存器中的值与 `%rbp` 寄存器偏移 0 的内存地址处的值，如果不相等，则跳转到地址 `0x401396` 处执行相应的代码（函数会返回1），否则继续执行后续指令。

重点理解的指令有：

- `test S1, S2`：相当于`S1&S2`，若结果为0，则设置ZF为1
- `jmp`的所有指令。重点有`je`，jump condition为`ZF = 1`
- `movzbl`：0拓展数据。Move zero-extended **byte** to **double** word（`movz S,R`： R ← ZeroExtend(S)）

综上，可以得知如果想拆除阶段1的炸弹，则需要输入合理的字符串，而这个字符串可以通过以下分析得出：

1. 查看`phase_1`函数的汇编代码，发现入参`%rdi`需要跟另一个参数`0x402400 --> %rsi`进入函数`strings_not_equal `进行计算，若结果为0，则可以拆除炸弹，否则爆炸。
2. 查看`strings_not_equal `函数的汇编代码，可以分析出此函数是将入参寄存器（`%rdi`和`%rsi`）所指地址处的字符串进行比对，如果长度相同并且每个字都相同（按照字节对比），则返回0

通过上面两个函数的分析，就可以得知我们所输入的字符串，需要跟地址为`0x402400`处的字符串进行比对，比对成功则炸弹拆除。

那这样，通过gdb的命令`x/s 0x402400`，GDB 会读取内存地址 `0x402400` 处开始的连续字节，直到遇到字符串结束符（`\0`，空字符），然后将这些字节解释为字符串并打印出来。

```py
(gdb) x/s 0x402400                                                                                                                                           
0x402400:       "Border relations with Canada have never been better."
				#translation：边境与加拿大的关系从未如此良好。
```

## 4.25

早晨发现自己的git又没法提交了。

解决办法是删除工作目录，[设置ssh密钥配对](https://www.cnblogs.com/shangshankandashu/p/18099444)，然后`git clone`对应的代码。

然而gdb在运行`bomb`文件的时候，提示没有权限：

```bash
(gdb) r                                                                               
Starting program: /home/crx/study/csapp/03machine_prog/bomb/bomb                      
/bin/bash: line 1: /home/crx/study/csapp/03machine_prog/bomb/bomb: Permission denied  
/bin/bash: line 1: exec: /home/crx/study/csapp/03machine_prog/bomb/bomb: cannot execute: Permission denied
During startup program exited with code 126.        
```

可以看出在运行`bomb`文件的时候，提示我没有执行此文件的权限。解决方法就是修改这个文件的权限，但是我希望`/home/crx/study`这个目录下的所有文件都可以用普通用户的权限去执行使用，这样就将目标文件夹`/home/crx/study`下的所有文件和子目录的所有者改为目标用户。

**改变所有者：** 使用 `chown` 命令将目标文件夹下的所有文件和子目录的所有者改为目标用户。假设目标用户为 `username`，目标文件夹路径为 `/path/to/directory`，则命令如下：

```bash
sudo chown -R username:username /path/to/directory
```

然后就是**修改权限：** 使用 `chmod` 命令修改目标文件夹下的所有文件和子目录的权限，确保目标用户具有读写执行权限。假设你希望目标用户有所有权限，则可以使用以下命令：

```bash
sudo chmod -R u+rwx /path/to/directory
```

这里的 `-R` 参数同样表示递归操作。

执行以上步骤后，目标用户就可以使用该文件夹下的所有文件了，并且具有读、写和执行的权限。

boom lab-phase2：

gdb用法：

- gdb如何给特定地址打断点：`break *0x12345678`
- 输出单独寄存器的值： `print $eax`

反汇编和反编译：

**反汇编（Disassembly）：** 反汇编是将机器代码转换为汇编语言的过程。

**反编译（Discompilation）**:反编译是将机器代码转换为高级语言（例如 C、C++、Python 等）的过程。

开始下断点`b phase_2`，单步执行，反汇编当前函数，汇编代码如下：

```assembly
(gdb) disassemble 
Dump of assembler code for function phase_2:
=> 0x0000000000400efc <+0>:     push   %rbp
   0x0000000000400efd <+1>:     push   %rbx
   0x0000000000400efe <+2>:     sub    $0x28,%rsp
   0x0000000000400f02 <+6>:     mov    %rsp,%rsi		#将栈指针保存到%rsi中
   0x0000000000400f05 <+9>:     call   0x40145c <read_six_numbers>
   0x0000000000400f0a <+14>:    cmpl   $0x1,(%rsp)
   0x0000000000400f0e <+18>:    je     0x400f30 <phase_2+52>
   0x0000000000400f10 <+20>:    call   0x40143a <explode_bomb>
   0x0000000000400f15 <+25>:    jmp    0x400f30 <phase_2+52>
   0x0000000000400f17 <+27>:    mov    -0x4(%rbx),%eax
   0x0000000000400f1a <+30>:    add    %eax,%eax
   0x0000000000400f1c <+32>:    cmp    %eax,(%rbx)
   0x0000000000400f1e <+34>:    je     0x400f25 <phase_2+41>
   0x0000000000400f20 <+36>:    call   0x40143a <explode_bomb>
   0x0000000000400f25 <+41>:    add    $0x4,%rbx
   0x0000000000400f29 <+45>:    cmp    %rbp,%rbx
   0x0000000000400f2c <+48>:    jne    0x400f17 <phase_2+27>
   0x0000000000400f2e <+50>:    jmp    0x400f3c <phase_2+64>
   0x0000000000400f30 <+52>:    lea    0x4(%rsp),%rbx
   0x0000000000400f35 <+57>:    lea    0x18(%rsp),%rbp
   0x0000000000400f3a <+62>:    jmp    0x400f17 <phase_2+27>
   0x0000000000400f3c <+64>:    add    $0x28,%rsp
   0x0000000000400f40 <+68>:    pop    %rbx
   0x0000000000400f41 <+69>:    pop    %rbp
   0x0000000000400f42 <+70>:    ret    
End of assembler dump.
```

分析这个函数的功能：

这里<+6>行的`mov    %rsp,%rsi`的目的是保存`caller`中栈顶的位置，方便在`read_six_numbers`中进行改值。

函数只有在寄存器%rsp所指的内存数据为0x1的时候，才不会引爆炸弹，而栈指针 `%rsp` 就是用来指示当前栈顶位置的寄存器。等效于栈顶数据是否为1。

假设现在栈顶数据为1（`(%rsp) == 0x1`），则不会引爆炸弹，而是会调用`+52`行的代码，即：

> `lea    0x4(%rsp),%rbx`：将%rsp的值加4（dec），然后赋值给寄存器%rbx。
>
> `lea    0x18(%rsp),%rbp`：将%rsp的值加24（dec），然后赋值给寄存器%rbp。

给%rbx和%rbp重新赋值，此时%rbx = %rsp + 4， %rbp =  %rsp + 18。

这里可以通过函数`read_six_numbers`推测出，栈顶保存的数据是第一个int类型数据，所占空间为4bytes，然后从栈顶开始向高位地址处连续6个int数据，就是此函数的6个返回值。

随后跳转调用`<phase_2+27>`处的代码：

```assembly
   0x0000000000400f17 <+27>:    mov    -0x4(%rbx),%eax		#（%rsp + 4 - 4）-->%eax
   0x0000000000400f1a <+30>:    add    %eax,%eax			#%eax = 2 %eax
   0x0000000000400f1c <+32>:    cmp    %eax,(%rbx)			#(%rsp + 4) - %eax
   0x0000000000400f1e <+34>:    je     0x400f25 <phase_2+41>	#如果相等，则不爆炸
   0x0000000000400f20 <+36>:    call   0x40143a <explode_bomb>
```

此时不爆炸的条件是：栈(%rsp + 4)处的数据（第二个参数）等于两倍的栈顶（%rsp）的数据。

假若此时不爆炸，则程序又会跳转到`<phase_2+41>`处执行：

```assembly
   0x0000000000400f25 <+41>:    add    $0x4,%rbx			# %rbx = %rsp + 8
   0x0000000000400f29 <+45>:    cmp    %rbp,%rbx			#todo：为什么要对比%rbp,%rbx？
   0x0000000000400f2c <+48>:    jne    0x400f17 <phase_2+27>
   0x0000000000400f2e <+50>:    jmp    0x400f3c <phase_2+64>
```

分析下为什么`cmp    %rbp,%rbx`：这里`%rbx`的作用是作为6个参数的指针，而`%rbp`保存的是第6个参数的位置。比较两者的大小就是确认是否指针索引到了最后一个参数。

此时%rbx = %rsp + 8。如果还没到最后一个参数，那么重新跳转到`<phase_2+27>`处的代码：

```assembly
   0x0000000000400f17 <+27>:    mov    -0x4(%rbx),%eax		#（%rsp + 4）-->%eax
   0x0000000000400f1a <+30>:    add    %eax,%eax			#%eax = 2 * %eax = 2 * (%rsp + 4)
   0x0000000000400f1c <+32>:    cmp    %eax,(%rbx)			#(%rsp + 8) == 2 * (%rsp + 4)
   0x0000000000400f1e <+34>:    je     0x400f25 <phase_2+41>	#如果相等，则不爆炸
   0x0000000000400f20 <+36>:    call   0x40143a <explode_bomb>
```

这里` cmp    %eax,(%rbx)			#(%rsp + 8) == 2 * (%rsp + 4)`可以得知：第三个参数需要为第二个参数的两倍。

如此循环往复，直到最后一个参数。若栈顶数据为a，则其余数据分别为2a，4a，8a，16a，32a。这时候程序会执行`jmp    0x400f3c <phase_2+64>`，到`phase_2+64`位置继续执行指令：

```assembly
   0x0000000000400f3c <+64>:    add    $0x28,%rsp
   0x0000000000400f40 <+68>:    pop    %rbx
   0x0000000000400f41 <+69>:    pop    %rbp
   0x0000000000400f42 <+70>:    ret   
```

这里就是回收栈空间，函数正常返回了。

我们可以通过调用函数` call   0x40145c <read_six_numbers>`完毕后的比较语句，以及上述分析的后续语句推测函数`read_six_numbers`的功能就是返回一个从1开始的等比序列。

## 4.26

看下这个函数`read_six_numbers`的具体执行：

```assembly
(gdb) disassemble 
Dump of assembler code for function read_six_numbers:
=> 0x000000000040145c <+0>:     sub    $0x18,%rsp
   0x0000000000401460 <+4>:     mov    %rsi,%rdx
   0x0000000000401463 <+7>:     lea    0x4(%rsi),%rcx
   0x0000000000401467 <+11>:    lea    0x14(%rsi),%rax
   0x000000000040146b <+15>:    mov    %rax,0x8(%rsp)
   0x0000000000401470 <+20>:    lea    0x10(%rsi),%rax
   0x0000000000401474 <+24>:    mov    %rax,(%rsp)
   0x0000000000401478 <+28>:    lea    0xc(%rsi),%r9
   0x000000000040147c <+32>:    lea    0x8(%rsi),%r8
   0x0000000000401480 <+36>:    mov    $0x4025c3,%esi
   0x0000000000401485 <+41>:    mov    $0x0,%eax
   0x000000000040148a <+46>:    call   0x400bf0 <__isoc99_sscanf@plt>
   0x000000000040148f <+51>:    cmp    $0x5,%eax
   0x0000000000401492 <+54>:    jg     0x401499 <read_six_numbers+61>
   0x0000000000401494 <+56>:    call   0x40143a <explode_bomb>
   0x0000000000401499 <+61>:    add    $0x18,%rsp
   0x000000000040149d <+65>:    ret    
End of assembler dump.
```

这里补充下gdb如何将内存数据以int类型输出：

```bash
# 以 int 类型输出内存地址为0x12345678处的数据
x/dw 0x12345678
```

在这个示例中，`x` 是 GDB 的查看内存命令，`/dw` 指定了打印格式，其中 `/d` 表示十进制，`w` 表示以字（4 字节）为单位进行打印。你可以根据需要调整打印的数据大小和内存地址。

逐一分析指令：

- `sub    $0x18,%rsp`：开辟24bytes的栈空间（6个double word类型数据）
- `mov    %rsi,%rdx`：           %rdx = %rsi。（问：此时%rsi保存的是什么？）此时%rsi保存的是`rsi            0x7fffffffe310`。
- `lea    0x4(%rsi),%rcx`：%rcx = %rsi + 4
- `lea    0x14(%rsi),%rax`：%rax = %rsi + 20
- `mov    %rax,0x8(%rsp)`：栈顶下第二个int数据（0x7fffffffe2f8）= 0x7fffffffe324
- `lea    0x10(%rsi),%rax`：%rax = %rsi + 16，%rax = 0x7fffffffe320
- `mov    %rax,(%rsp)`：（%rsp）= %rsi + 16

额，好像不需要分析了。

首先通过`phase_2`代码可知：

```assembly
Dump of assembler code for function phase_2:
=> 0x0000000000400efc <+0>:     push   %rbp
   0x0000000000400efd <+1>:     push   %rbx
   0x0000000000400efe <+2>:     sub    $0x28,%rsp
   0x0000000000400f02 <+6>:     mov    %rsp,%rsi		#将栈指针保存到%rsi中
   0x0000000000400f05 <+9>:     call   0x40145c <read_six_numbers>
```

进入函数`read_six_numbers`之前，栈指针已经保存到`%rsi`中了。而`phase_2`代码中对于返回栈空间的值，需要从栈顶开始保存数据大小为word（4 bytes）的数据，数据格式是从1开始的比例为2的等比序列。

进入函数`read_six_numbers`之后，发现很多操作就是将`phase_2`的栈空间地址分配给各个寄存器，不难推断出函数`read_six_numbers`就是将输入的数据分别分配到`phase_2`的栈空间中，预测一波答案`1 2 4 8 16 32`，输入后果然正确。

补充sscanf函数：

`sscanf` 是 C 标准库中的一个函数，用于按照指定的格式从字符串中读取数据并进行解析。它的函数原型如下：

```C
int sscanf(const char *str, const char *format, ...);
```

- `str` 是要解析的字符串。
- `format` 是格式控制字符串，指定了 `sscanf` 如何解析字符串中的数据。格式控制字符串中可以包含转换说明符，用来指定要解析的数据类型和格式。
- `...` 是可变参数列表，用来接收解析后的数据。

`sscanf` 函数的作用是根据指定的格式从字符串中读取数据并存储到指定的变量中。例如:

```c
#include <stdio.h>

int main() {
    char str[] = "Hello 123 456";
    char word[10];
    int num1, num2;

    sscanf(str, "%s %d %d", word, &num1, &num2);
    printf("Word: %s\n", word);
    printf("Number 1: %d\n", num1);
    printf("Number 2: %d\n", num2);

    return 0;
}
```

在这个例子中，`sscanf(str, "%s %d %d", word, &num1, &num2)` 从字符串 `str` 中解析出一个字符串、一个整数和另一个整数，并分别存储到变量 `word`、`num1` 和 `num2` 中。然后通过 `printf` 函数输出这些数据。

这里阶段2重点是函数`sscanf`的作用，挖个坑，等日后整理笔记的时候，重新回顾下这个问题。

现在看阶段3，phase3代码：

```assembly
(gdb) disassemble 
Dump of assembler code for function phase_3:
   0x0000000000400f43 <+0>:     sub    $0x18,%rsp
   0x0000000000400f47 <+4>:     lea    0xc(%rsp),%rcx			#第二个参数的指针是 0xc(%rsp)
   0x0000000000400f4c <+9>:     lea    0x8(%rsp),%rdx			#第一个参数的指针是 0x8(%rsp)
   0x0000000000400f51 <+14>:    mov    $0x4025cf,%esi
   0x0000000000400f56 <+19>:    mov    $0x0,%eax
=> 0x0000000000400f5b <+24>:    call   0x400bf0 <__isoc99_sscanf@plt>
   0x0000000000400f60 <+29>:    cmp    $0x1,%eax
   0x0000000000400f63 <+32>:    jg     0x400f6a <phase_3+39>
   0x0000000000400f65 <+34>:    call   0x40143a <explode_bomb>
   0x0000000000400f6a <+39>:    cmpl   $0x7,0x8(%rsp)			#第一个参数要小于7
   0x0000000000400f6f <+44>:    ja     0x400fad <phase_3+106>
   0x0000000000400f71 <+46>:    mov    0x8(%rsp),%eax			#第一个参数的指针赋给eax
   0x0000000000400f75 <+50>:    jmp    *0x402470(,%rax,8)
   0x0000000000400f7c <+57>:    mov    $0xcf,%eax
   0x0000000000400f81 <+62>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f83 <+64>:    mov    $0x2c3,%eax
   0x0000000000400f88 <+69>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f8a <+71>:    mov    $0x100,%eax
   0x0000000000400f8f <+76>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f91 <+78>:    mov    $0x185,%eax
   0x0000000000400f96 <+83>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f98 <+85>:    mov    $0xce,%eax
   0x0000000000400f9d <+90>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f9f <+92>:    mov    $0x2aa,%eax
   0x0000000000400fa4 <+97>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400fa6 <+99>:    mov    $0x147,%eax
   0x0000000000400fab <+104>:   jmp    0x400fbe <phase_3+123>
   0x0000000000400fad <+106>:   call   0x40143a <explode_bomb>
   0x0000000000400fb2 <+111>:   mov    $0x0,%eax
   0x0000000000400fb7 <+116>:   jmp    0x400fbe <phase_3+123>
   0x0000000000400fb9 <+118>:   mov    $0x137,%eax
   0x0000000000400fbe <+123>:   cmp    0xc(%rsp),%eax	# 第二个参数需要符合eax（+57到+104mov传递的参数）上面的取值
   0x0000000000400fc2 <+127>:   je     0x400fc9 <phase_3+134>
   0x0000000000400fc4 <+129>:   call   0x40143a <explode_bomb>
   0x0000000000400fc9 <+134>:   add    $0x18,%rsp
   0x0000000000400fcd <+138>:   ret    
End of assembler dump.
```

在执行`call   0x400bf0 <__isoc99_sscanf@plt>`之前，分析sscanf函数的入参：

- 第一个参数是一个字符串地址，由%rdi保存。

- 第二个参数（%rsi）是格式控制字符串，指定了 `sscanf` 如何解析字符串中的数据。打印%rsi的数据为:

  ```assembly
  (gdb) x/s $rsi
  0x4025cf:       "%d %d"
  ```

  这里可以得知sccanf函数会将输入的字符串分割为两个整数。

- 那么各自保存两个整数的地址就是%rdx和%rcx了。

这里的问题就在于`jmp    *0x402470(,%rax,8)`这个间接跳转指令。

jmp 

