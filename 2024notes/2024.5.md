## 5.4

要开启新的5月份旅途了！

开始lab05！

python的`append`和`extend`

- `append` 方法用于在列表末尾添加一个元素
- `extend` 方法用于在列表末尾一次性添加另一个序列中的所有元素。

记录下`for`循环中的修改循环变量问题：

在 Python 中，通常不建议在循环体内直接修改循环变量，因为这可能会导致逻辑混乱或者意外的结果。循环变量 `i` 在 `for` 循环中是由迭代器生成的，修改它可能会影响循环的行为。

现在我写的错误代码为：

```py
def insert_items(s, before, after):
    """Insert after into s after each occurrence of before and then return s.

    >>> test_s = [1, 5, 8, 5, 2, 3]
    >>> new_s = insert_items(test_s, 5, 7)
    >>> new_s
    [1, 5, 7, 8, 5, 7, 2, 3]
    >>> test_s
    [1, 5, 7, 8, 5, 7, 2, 3]
    >>> new_s is test_s
    True
    >>> double_s = [1, 2, 1, 2, 3, 3]
    >>> double_s = insert_items(double_s, 3, 4)
    >>> double_s
    [1, 2, 1, 2, 3, 4, 3, 4]
    >>> large_s = [1, 4, 8]
    >>> large_s2 = insert_items(large_s, 4, 4)
    >>> large_s2
    [1, 4, 4, 8]
    >>> large_s3 = insert_items(large_s2, 4, 6)
    >>> large_s3
    [1, 4, 6, 4, 6, 8]
    >>> large_s3 is large_s
    True
    """
    "*** YOUR CODE HERE ***"
    """
        解决思路：
            1. for遍历序列s，查询是否存在等于before的值
            2. e == before, 将after插入到e后面
            3. 索引跳到插入的after值后面
    """
    for i in range(len(s)+1):
        if s[i] == before:
            s.insert(i+1, after)
            i = i + 2
    return s
```

我想要索引略过新插入的after值 ，但是不了解循环变量 `i` 在 `for` 循环中是由迭代器生成的，不能随便修改for循环中的索引i。

这样的结果就是即使在判断中修改了`i`的值，但是回到循环迭代给`i`赋值的阶段，`i`又会重新被迭代器生成的值赋值，所以达不到`i+2`的结果。

所以直接用`while`：

```py
def insert_items(s, before, after):
	i = 0
    while  i < len(s):
        if s[i] == before:
            s.insert(i+1, after)
            i = i + 1
        i += 1
    return s
```

bomblab phase6：

```assembly
=> 0x00000000004010f4 <+0>:     push   %r14
   0x00000000004010f6 <+2>:     push   %r13
   0x00000000004010f8 <+4>:     push   %r12
   0x00000000004010fa <+6>:     push   %rbp
   0x00000000004010fb <+7>:     push   %rbx
   0x00000000004010fc <+8>:     sub    $0x50,%rsp
   0x0000000000401100 <+12>:    mov    %rsp,%r13					#int *r13 = rsp
   0x0000000000401103 <+15>:    mov    %rsp,%rsi
   0x0000000000401106 <+18>:    call   0x40145c <read_six_numbers> #num1 - num6
   0x000000000040110b <+23>:    mov    %rsp,%r14				   #int *r14 = num1 = *rsp
   0x000000000040110e <+26>:    mov    $0x0,%r12d					# int i(r12d) = 0
   0x0000000000401114 <+32>:    mov    %r13,%rbp					# int *rbp = rsp
   0x0000000000401117 <+35>:    mov    0x0(%r13),%eax				# int eax = num1
   0x000000000040111b <+39>:    sub    $0x1,%eax					# if (rsp[0] <= 6)
   0x000000000040111e <+42>:    cmp    $0x5,%eax
   0x0000000000401121 <+45>:    jbe    0x401128 <phase_6+52>
   0x0000000000401123 <+47>:    call   0x40143a <explode_bomb>
   
   #<+0>- <+47>:输入的6个值均小于等于6
   0x0000000000401128 <+52>:    add    $0x1,%r12d					#i ++  (i = 1)
   0x000000000040112c <+56>:    cmp    $0x6,%r12d					# cmp 6 and i
   0x0000000000401130 <+60>:    je     0x401153 <phase_6+95>
  					
  					# if(i < 6)
   0x0000000000401132 <+62>:    mov    %r12d,%ebx				# int ebx = i (ebx = 1)
   0x0000000000401135 <+65>:    movslq %ebx,%rax				# Move sign-extended double word to quad word	
   																# rax = 1
   0x0000000000401138 <+68>:    mov    (%rsp,%rax,4),%eax		# rax = rsp[1]
   0x000000000040113b <+71>:    cmp    %eax,0x0(%rbp)			# if(rsp[1] != rsp[0])		
   0x000000000040113e <+74>:    jne    0x401145 <phase_6+81>
   0x0000000000401140 <+76>:    call   0x40143a <explode_bomb>
   					# rsp[1] != rsp[0]
   0x0000000000401145 <+81>:    add    $0x1,%ebx				# ebx += 1(ebx = 2)
   0x0000000000401148 <+84>:    cmp    $0x5,%ebx				# ebx <= 5
   0x000000000040114b <+87>:    jle    0x401135 <phase_6+65>
   #<+62> - <+87>分析：遍历输入的6个数据，判断是否后五个均不等于num[0]
   
   
   0x000000000040114d <+89>:    add    $0x4,%r13				# *r13 = rsp + 1
   0x0000000000401151 <+93>:    jmp    0x401114 <phase_6+32>
   #<+32> - <+93>：判断是否输入的所有数字均小于等于6，且互不相等
   
   
   					# if(i == 6) 此时满足的条件是：输入的所有数字均小于等于6，且互不相等
   0x0000000000401153 <+95>:    lea    0x18(%rsp),%rsi		# int *rsi = rsp + 6	(24 / 4 = 6 words) = 0
   0x0000000000401158 <+100>:   mov    %r14,%rax			# int *rax = rsp
   0x000000000040115b <+103>:   mov    $0x7,%ecx			# int ecx = 7
   0x0000000000401160 <+108>:   mov    %ecx,%edx			# edx = 7
   0x0000000000401162 <+110>:   sub    (%rax),%edx			# edx = 7 - rsp[0]
   0x0000000000401164 <+112>:   mov    %edx,(%rax)			# *rsp = 7 - rsp[0]
   0x0000000000401166 <+114>:   add    $0x4,%rax			# rax = rsp + 1(*rax = rsp[1])
   0x000000000040116a <+118>:   cmp    %rsi,%rax			# 指针 rax 索引rsp到rsp+5的6个输入数字
   0x000000000040116d <+121>:   jne    0x401160 <phase_6+108>
   #<+95> - <+121>：指针rax索引输入的6个数字，并且重新赋值为num[i] = 7-num[i]
   
   
# ------------------- 将rsp[i]重新赋值为7 - rsp[i]------------------

   0x000000000040116f <+123>:   mov    $0x0,%esi				# int rsi = 0
   0x0000000000401174 <+128>:   jmp    0x401197 <phase_6+163>
   																# eax = 1, *edx = 0x6032d0
   0x0000000000401176 <+130>:   mov    0x8(%rdx),%rdx			# rdx = mem(0x6032d0 + 8) = 6304480
   0x000000000040117a <+134>:   add    $0x1,%eax				# eax ++ (eax = 2)
   0x000000000040117d <+137>:   cmp    %ecx,%eax				# compare eax and ecx(rsp[0])
   0x000000000040117f <+139>:   jne    0x401176 <phase_6+130>	# if eax != rsp[0]: eax ++
   0x0000000000401181 <+141>:   jmp    0x401188 <phase_6+148>	#	此时一定满足rax == rsp[0]


						#if(rsp[i] <= 1)
   0x0000000000401183 <+143>:   mov    $0x6032d0,%edx			# int *edx = 0x6032d0(*edx = 332)
   0x0000000000401188 <+148>:   mov    %rdx,0x20(%rsp,%rsi,2)	# 8（32bytes = 8words--int） + rsp + 2 * rsi = 0x6032d0
   #在40118d打断点，调试可以确认每次将rsp[8+2i]赋值什么了
   
   0x000000000040118d <+153>:   add    $0x4,%rsi				# rsi + 1
   0x0000000000401191 <+157>:   cmp    $0x18,%rsi				# rsi and 6
   0x0000000000401195 <+161>:   je     0x4011ab <phase_6+183>
   
   0x0000000000401197 <+163>:   mov    (%rsp,%rsi,1),%ecx		# ecx = rsp[rsi] 
   0x000000000040119a <+166>:   cmp    $0x1,%ecx				# compare rsp[rsi] and 1 
   0x000000000040119d <+169>:   jle    0x401183 <phase_6+143>	
   # <+143> - <+169>:如果7-num[i]小于等于1，则将给rsp+8(32 = 0x20)、10(40 = 0x28)、12(48 = 0x30)、14(56 = 0x38)、16(64 = 0x40)、18赋值
   # 为0x6032d0
   
   						#if(rsp[i] > 1)
   0x000000000040119f <+171>:   mov    $0x1,%eax				# int eax = 1
   0x00000000004011a4 <+176>:   mov    $0x6032d0,%edx			# int *edx = 0x6032d0
   0x00000000004011a9 <+181>:   jmp    0x401176 <phase_6+130>
   
   
   0x00000000004011ab <+183>:   mov    0x20(%rsp),%rbx			# rbx = rsp[8]
   0x00000000004011b0 <+188>:   lea    0x28(%rsp),%rax			# rax = rsp + 10
   0x00000000004011b5 <+193>:   lea    0x50(%rsp),%rsi			# rsi = rsp + 20
   0x00000000004011ba <+198>:   mov    %rbx,%rcx				# rcx = rsp[8]
   0x00000000004011bd <+201>:   mov    (%rax),%rdx				# rdx = rsp[10]
   0x00000000004011c0 <+204>:   mov    %rdx,0x8(%rcx)			# *(rcx + 0x8) = rsp[10]
   0x00000000004011c4 <+208>:   add    $0x8,%rax				# rax = rsp + 10 + 2
   0x00000000004011c8 <+212>:   cmp    %rsi,%rax				# if rax != rsp+20
   
   0x00000000004011cb <+215>:   je     0x4011d2 <phase_6+222>
   0x00000000004011cd <+217>:   mov    %rdx,%rcx				# rcx = rsp[10]
   0x00000000004011d0 <+220>:   jmp    0x4011bd <phase_6+201>
   # <+183> - <+220>:不知道做了什么，应该是将rsp[10]、rsp[12]、...、rsp[18]的所有值，赋值给
   
   						# if rax == rsp+20
   						# 跳出循环时，rax=rsp+20,rdx = *(rsp+18),rbx = *(rsp + 8)
   0x00000000004011d2 <+222>:   movq   $0x0,0x8(%rdx)
   0x00000000004011da <+230>:   mov    $0x5,%ebp
   0x00000000004011df <+235>:   mov    0x8(%rbx),%rax	# rax = *(rsp[8] + 2);//链表指针域
   0x00000000004011e3 <+239>:   mov    (%rax),%eax		# rax = *(rax);//rax 为node->next
   0x00000000004011e5 <+241>:   cmp    %eax,(%rbx)	# 下一个节点 和 此节点 的低32位数据进行比对		
   0x00000000004011e7 <+243>:   jge    0x4011ee <phase_6+250>	# 保证当前节点的低32位数据要大于下一节点的低32位数据
   
   0x00000000004011e9 <+245>:   call   0x40143a <explode_bomb>
   0x00000000004011ee <+250>:   mov    0x8(%rbx),%rbx
   0x00000000004011f2 <+254>:   sub    $0x1,%ebp
   0x00000000004011f5 <+257>:   jne    0x4011df <phase_6+235>
   0x00000000004011f7 <+259>:   add    $0x50,%rsp
   0x00000000004011fb <+263>:   pop    %rbx
   0x00000000004011fc <+264>:   pop    %rbp
   0x00000000004011fd <+265>:   pop    %r12
   0x00000000004011ff <+267>:   pop    %r13
   0x0000000000401201 <+269>:   pop    %r14
   0x0000000000401203 <+271>:   ret
```

## 5.5

将汇编语言反汇编为C伪代码后：

```C
phase_6(char *str){
    int *rsp = read_six_numbers(str);//rsp[0] = input[0] ---> rsp[5] = input[5]
    for(int i = 0; i < 6; i++){
        //输入数字均小于等于6，且所有数字均不相同
        for(int j = i + 1; j < 6; j++){
            if(rsp[i] > 6 || rsp[j] == rsp[i]){
                return explode_bomb();
            }
        }		
    }
	
	//将所有数字置为7减去自身
	for(int i = 0; i < 6; i++){
		rsp[i] = 7 - rsp[i];
	}
	
	int i = 0;
		
	//rsp[8]、rsp[10]、rsp[12]、rsp[14]、rsp[16]、rsp[18]均会被赋值
	while(i < 6){
		if(rsp[i] <= 1){//7-rsp[i] and 1//	num[i] >= 6
			rsp[8 + 2*i] = 0x6032d0;
		}else{
			int eax = 1;
			int edx = 0x6032d0;
			do{
				//edx = 2：0x006032e0，3：0x006032f0，4：0x00603300，5：0x00603310，6：0x00603320
				edx = *(edx + 0x8);
				eax++;
			}while(eax != rsp[i]);
			//rax == rsp[i]
			rsp[8 + 2*i] = edx;
		}
		i++;
	}
	//修改node节点的指针域
	int rbx = rsp[8]; 	//存储的是链表节点位置/指针域
	int *rax = rsp + 10;
	int *rsi = rsp + 20;//边界
	do{
		// *(rsp[8] + 2) = rsp[10]
		// *(rsp[10] + 2) = rsp[12]
		/* ....
		   *(rsp[16] + 2) = rsp[18]
		*/
		int rcx = rbx;
		int rdx = *rax;
		*(rbx + 2) = *(rax);//修改链表的指针域
		rax = rax + 2;
		&rbx ++;
	}while(rax < rsi);
	
    //判断rsp[8]到rsp[18]所指的节点，值域是否均后一个大于前一个
	//跳出循环时，rax=rsp+20,rdx = *(rsp+18),rbx = *(rsp + 8)
    //rax            0x7fffffffe0b0 == rsp+20
    //rbx            0x603320       == *(rsp + 8)
	//rcx            0x6032e0            6304480
	//rdx            0x6032d0       == *(rsp+18)

	rdx = rsp[18];
	rbx = rsp[8]
	*(rsp[18] + 2) = 0;
	ebp = 5;
    while(ebp != 0){
        rax = *(rsp[8] + 2);//链表指针域
		rax = *(rax);		//将此节点给指针rax
		if(*(rbx) >= rax){//将前一节点（*(rbx)）和后一个节点的值（猜测为值域:哪里为值域）进行比较
			rbx = *(rsp[8] + 2);//rbx指向链表的下一个节点
		//这里保证了修改完指针域后的链表，前一个节点的值要大于后一个节点的值
		}
        ebp--;
    }

	
}
```

补充`0x6032d0`处的数据：

```assembly
(gdb) x/24xw 0x6032d0
0x6032d0 <node1>:       0x0000014c      0x00000001      0x006032e0      0x00000000
0x6032e0 <node2>:       0x000000a8      0x00000002      0x006032f0      0x00000000
0x6032f0 <node3>:       0x0000039c      0x00000003      0x00603300      0x00000000
0x603300 <node4>:       0x000002b3      0x00000004      0x00603310      0x00000000
0x603310 <node5>:       0x000001dd      0x00000005      0x00603320      0x00000000
0x603320 <node6>:       0x000001bb      0x00000006      0x00000000      0x00000000
```

可以看出这是一个链表结构，长度为6，依次存储1到6的值。

经过分析：

1. rsp[8]到rsp[18]保存的是以0x6032d0开头的链表地址
2. 最后一步判断条件，保证修改完指针域后的链表，前一个节点的值要大于后一个节点的值
3. 打印0x6032d0处的数据可以看出，若想值域从大到小排列，那就需要rsp[8]指向结构：node3 -> node4 -> node5 -> node6 -> node1 -> node2。
4. 等日后再分析吧，今晚很累

最终答案为：

```tex
Border relations with Canada have never been better.
1 2 4 8 16 32
2 707
7 0
9on567
4 3 2 1 6 5
```

晚安。

## 5.6

重新回顾`lambda`表达式。

```py
     lambda            x            :          f(g(x))
"A function that    takes x    and returns     f(g(x))"
```

**disc6**

获取大于2024的斐波那契数：

生成大于2024斐波那契数的生成器：`filter(lambda n: n > 2024, gen_fib())`

```python
def gen_fib():
    n, add = 0, 1
    while True:
        yield n
        n, add = n + add, n

next(filter(lambda n: n > 2024, gen_fib()))
```

分析：

- **filter**(*function*, *iterable*)： is equivalent to the generator expression `(item for item in iterable if function(item))`
- `filter()`函数将第一个判断n是否大于2024作为判断条件函数，将生成器函数`gen_fib()`作为可迭代值作为第二个参数，将返回一个迭代器。这个迭代器的作用就是获取大于2024的斐波那契数。
- The `filter` function returns an iterator over, `zip`, and `reversed` functions also return iterators.An iterator object is created that can return results if queried using `next`.

### Q2: Merge

Write a generator function `merge` that takes in two infinite generators `a` and `b` that are in increasing order without duplicates and returns a generator that has all the elements of both generators, in increasing order, without duplicates.

问题抽象：按照递增序列排两个迭代器的值，并且不能重复

问题分析：

1. 获取两个迭代器的值：v1 = next(a), v2 = next(b)
2. 如果v1 < v2，则yield v1，随后v1 = next(a)
3. 如果v2 < v1，则yield v2，随后v2 = next(b)
4. 如果v1 = v2，则yield v1，随后v1 = next(a)并且v2 = next(b)

```py
def merge(a, b):
    """Q2:
    >>> def sequence(start, step):
    ...     while True:
    ...         yield start
    ...         start += step
    >>> a = sequence(2, 3) # 2, 5, 8, 11, 14, ...
    >>> b = sequence(3, 2) # 3, 5, 7, 9, 11, 13, 15, ...
    >>> result = merge(a, b) # 2, 3, 5, 7, 8, 9, 11, 13, 14, 15
    >>> [next(result) for _ in range(10)]
    [2, 3, 5, 7, 8, 9, 11, 13, 14, 15]
    """
    "*** YOUR CODE HERE ***"
        v1, v2 = next(a), next(b)
    while True:
      if v1 < v2:
          yield v1
          v1 = next(a)
      elif v2 < v1:
          yield v2
          v2 = next(b)
      else:
          yield v1
          v1 = next(a)
          v2 = next(b)
```

## 5.7

leave off：If something continues from where it left off, it starts happening again at the point where it had previously stopped.

feel so lonely,so you can make friends by some ways and do something to make you happy.

## 5.8

`min` 函数在处理字典时，默认情况下会基于字典的键进行比较，并返回具有最小键的键-值对（或者只返回最小的键，取决于具体用法）。`min` 函数的语法格式如下：

```py
min(iterable, key=None, default=...)
```

- `iterable`：要比较的可迭代对象，通常是字典的键或者键值对。
- `key`：可选参数，用于指定比较的关键字函数，类似于 `sorted` 函数中的 `key` 参数。
- `default`：可选参数，在可迭代对象为空时返回的默认值。

```py
coins = {2: 2, 3: 2, 4: 3, 5: 1}
smallest = min(coins)
```

这里的min函数是选出面额（key）最小的硬币。

得到了峰哥的信任，哥们尽量努力不辜负自己的时光。

今天状态不佳，请好好爱自己bro！(●'◡'●)
