# 3月份日报

## 3.1

今天就是3月的第一天了！早上跑了10k，结果vivo健康的计算出了些问题，不知道后台是否被杀了，有段距离直接没记录。

昨天看了宫崎骏动漫：鲁邦三世，感觉这哥们很有魅力！挺喜欢！

ok，今天要做什么呢？

1. 1h过一遍cs61a材料1.6-2.7（侧重点：简单整理下结构和需要认真对待的背景知识）
2. 抄一遍2.3节`完美数`、`定面积求最小周长`、`链表`代码，并且单步执行
3. 抄一遍2.4节`可变链表`、`字典实现`、`调度字典`代码并且单步执行
4. 抄写连接器部分代码

------

# CS61A阅读指南

写一下关于[cs61a课本](https://www.composingprograms.com/)的阅读指南，方便同志们更高效地阅读cs61a。

## 为什么要写这个？

初学这些知识的时候，总会觉得自己很努力但是学的不明不白，而且经常会被一些不了解的概念卡住，阅读体验极差☹。

后来在[《为什么学生不喜欢上学》](https://book.douban.com/subject/4864832/)和 [你有什么值得分享的高效学习方法？ - howhowfire的回答 - 知乎](https://www.zhihu.com/question/50343728/answer/184657839)里面作者如何规划理科学习的部分，窥探了为什么学的这么痛苦：

> 学习中的困难，要么源于主动思维过难，超出了学习者能力所及的范围，要么源于主动思维时间过长，超出了学习者意志力的承受范围。熟悉了，才能理解概念，然后运用概念。

根据这本书和知乎大佬的回答，我慢慢摸索到了新手学习cs61a的关键：

1. 了解材料涉及的背景知识
2. 熟悉材料的结构，理解每一节为什么这么设计的，以及大体设计了什么
3. 熟悉材料的代码

在通篇阅读cs61a材料之前，python新手至少需要对上面三个知识点达到了解甚至熟悉的程度，否则零基础阅读文档时会异常痛苦。

而本文就是将1和2涉及的内容写下来，方便新手同志们获得更好地阅读体验。这里从1.6节开始的理由很简单：因为前面的知识很简单，你只需要认真阅读就可以，不需要另外的背景知识作为补充，也不需要提纲挈领统揽全局。

> [!IMPORTANT]
>
> 本文并不是cs61a的阅读笔记，而是作为新人阅读cs61a材料之前的`导学案`，是为了让同志们更好地阅读cs61a的。
>
> 这个文章存在的根本原因，就是cs61a的阅读材料默认新人有较强背景知识储备，但是实际上对于我们大一新生来说，很多背景知识（类似于树、链表等数据结构和面向对象的思想）都是不具备的。
>
> 我相信在阅读cs61a材料前，先将这篇帖子阅读完并且认真理解了里面涉及到的概念术语，等到开始阅读cs61a的时候，你会感到无比愉悦。

欢迎同志们的讨论和指点！

## CS61A 导学案

### 1.6 函数

1. “用户定义函数（user-defined functions）”作为一种数值运算的抽象模式，从而使它们与涉及的特定数字无关
2. 高阶函数：用一些函数来表达计算的通用方法（general methods），而且和它们调用的特定函数无关
3. 通用方法`def improve(update, close, guess=1)`
4. 嵌套定义解决帧混乱和参数限制的问题
5. 背景：利用平均值近似计算一个数的平方根
6. 作为返回值的函数
7. 背景：`牛顿法`的概念和具体实现
8. 用函数具体实现`牛顿法`的思想：迭代改进算法
9. Lambda 表达式

### 1.7 递归

1. 背景：递归函数
2. 递归举例`sum_digits(n):"""返回正整数 n 的所有数字位之和"""`
3. 背景：递归函数的理解
4. 理解举例：递归调用时栈帧变化+打印字符`cascade(n)`
5. 树递归：单个函数进行多个递归调用

### 2.2 数据抽象

1. 概念：为什么要数据抽象？数据抽象的基本思想是？（首先粗略了解，下面案例会帮助理解）
2. 举例：有理数的抽象表示-`rational(n, d)`，`numer(x)`,`denom(x)`。
3. 列表的索引
4. 抽象屏障的意义：分析上面有理数的抽象表示
5. 如何构建一个数据抽象：使用选择器和构造器的集合以及一些行为条件 - 函数 `pair` 和 `select` 

### 2.3 序列

本节根据序列（数据）的基本属性，自己动手实现一个链表，延伸数据抽象的概念。

1. 概念：序列是什么？

2. python内置的序列结构- 列表（list）以及常用方法

3. `count(s, value)`：如何遍历序列

4. 概念：序列处理。包括列表推导式（提供了从序列创建列表的简单途径）、 聚合（将序列中的所有值聚合为一个值）和高阶函数

5. 概念：完美数

6. 序列处理实例1：利用list类型，获取从1到n的完美数`divisors(n)`。

7. 序列处理实例2：定面积下计算只有整数边长的矩形的最小周长

8. 序列处理实例3：高阶函数来寻找完美数

    至此，介绍完毕序列相关属性和对应的常用操作，下面介绍如何对序列这样的数据进行抽象

9. 概念：什么是有用的序列抽象？（序列有用的行为包括哪些？）

10. 概念：数据的闭包属性

11. 概念：[树的概念](https://algo.itcharge.cn/07.Tree/01.Binary-Tree/01.Binary-Tree-Basic/)、树递归和分割树

12. 树的实例1：代码实现构造函数 `tree`、选择器 `label` 和 `branches` （想要理解函数具体功能，必须提前理解[树的概念](https://algo.itcharge.cn/07.Tree/01.Binary-Tree/01.Binary-Tree-Basic/)）

13. 树的实例2：树递归`fib_tree(n)`，用于构造树；`count_leaves` 函数计算树的叶子数

14. 树的实例3：分割树`partition_tree(n, m)`，返回将 n 分割成不超过 m 的若干正整数之和的分割树

15. 概念：[链表](https://algo.itcharge.cn/02.Linked-List/01.Linked-List-Basic/01.Linked-List-Basic/)

16. 链表实例1：实现基本抽象，包括`is_link(s)`、`link(first, rest)`、`first(s)`、`rest(s)`。

17. 链表实例2：实现满足序列抽象的条件，包括长度`len_link(s)`和数据选择`getitem_link(s, i)`，同时介绍了利用递归实现的思路

18. 链表实例3：利用递归构造，递增地构造序列。`partitions(n, m)`

### 2.4 可变数据

对象统领函数和数据。这一节开始，就要介绍关于“面向对象”的问题了，所以需要了解下[什么是面向对象](https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1)

1. 面向对象编程的核心

2. 序列对象“扑克牌”

3. 字典概念

4. 函数状态：举例取钱函数`withdraw`及其调用过程

   上面重要的概念就是关于函数的状态，下面紧接着就举例子来实践这个概念

5. 可变列表和字典实现：`to_mutable_link(source)`和`def dictionary()`

6. 概念：消息传递。一个函数A中集成了多个函数1、2、3...，调用其中的函数时，用不同的消息区分。这个函数A就利用调度函数（dispatch functions）来操作这些消息，以实现调用内置函数1、2、3...的操作。

7. 调度字典的概念和实现` account (initial_balance)`

8. 约束传递

   1. 概念
   2. 例子：华氏温度和摄氏温度之间的关系`9 * c = 5 * (f - 32)`
   3. 实例：实现一个约束系统来换算温度（代码很庞大，需要认真理解，没有捷径）

### 2.5 面向对象编程

暂时写到这里，日后再更。欢迎同志们讨论！😉

（3月7号来更新第三章）

### 3.1 引言

1. 解释器也是程序
2. scheme编程语言
3. 研究解释器的设计以及它们在执行程序时产生的计算过程
4. 解释器的两个互递归函数

### 3.2 函数式编程

1. Scheme 程序主要是由各种表达式构成的
2. Scheme 的前缀语法介绍
3. 使用 `define`赋值
4. 计算平方根的迭代过程
5. 复合类型的创建调用
6. 符号数据（看不懂）

### 3.3 异常

### 3.4 组合语言的解释器

以Python 源代码的形式提供了一个完整的解释器

1. 元语言抽象：编程语言可以建立在其它语言之上
2. 目标：定义解释器并且实现
3. **Scheme 对**
4. 解析表达式：词法分析和语法分析
5. 计算器具体求值顺序

### 3.5 抽象语言解释器

要求你构建一个功能齐全的 Scheme 解释器，来实现通过将名称绑定到数值和定义新操作来支持抽象。

## 3.3

ok，已经将[博客园的cs61a阅读指南](https://www.cnblogs.com/shangshankandashu/articles/18046806)的前两章补完了。

下午抄了一个半小时的关于2.3节“序列”部分的代码，越写越痛苦，发现里面很多代码是需要花较长时间去理解的。

于是又回归了老问题：下一步我该怎么学？

提纲挈领将第二章看了个大概，下一步该怎么学？

我觉得应该是通过问题驱动学习，按照课程设计的项目来实现。要不没有项目驱动，我也不知道它的重点在哪里，感觉通篇都是重点，没法做到有的放矢。

别忘了经常浏览每章节的知识，做到对课本的结构熟悉的要求即可。具体做每个项目和代码的时候，再按照项目精读对应的部分即可。

然后另外一个问题就是，除此之外，还需要学什么？

学什么：[UC Berkeley 的 EECS 培养方案](https://hkn.eecs.berkeley.edu/courseguides)

![image-20240303211909457](C:\Users\crx\AppData\Roaming\Typora\typora-user-images\image-20240303211909457.png)

出去走了走，心情好很多。

现在先将cs61a，csapp和nandToTetris弄完。

本周ddl：

- cs61a：完成2月23号之前的所有代码（不包括cats项目）。
- csapp：完成datalab
- nandToTetris：跟着网课来做

粘贴下学习计算机的一些经验贴（[csapp如何学习？](https://www.zhihu.com/question/20402534)）

> 学CS的话，不太建议看书。凡是学一门课，看优秀的公开课视频以及写编程作业是最有效率的方法。对CSAPP也不例外。
>
> 建议对计算机系统感兴趣的同学看视频，遇到问题或者对某些具体细节感兴趣的时候再去看书。[15513](https://www.zhihu.com/search?q=15513&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A223555103})的ppt和lecture提炼的很好，基本把书中最干货最重要的内容包含进来了。相比于看书可能能节省不少时间。
>
> 学习这门课我觉得收获最大是写lab。

虽然我是坚定的材料党，但如果不以某种成品来校验自己对于知识的掌握，那也是毫无意义的。

实践吧！

明天跑步，休息！

# 3.4-3.10

DDL：

- CS61A：2.12- 2.23
- CSAPP：datalab
- NandToTetris：follow the class

## 3.4

用了一个小时解决完毕CS61A的`Lab03`。

我发现并不需要对材料所有内容都掌握清楚，平时预习，然后上对应这节课的时候精读即可。预习的目的就是对材料做到心中有数，具体实现细节不要在意。

下面就是学习N2T，期待这门课带来的收获😉。而且我也有课本，也可以利用“多轮重复”的方法，掌握个大概。今天完成课程后，将第一章的内容浏览一遍。

另一个问题就是**英语**：

- [x] 如何建立自己的生词本

下午准备csapp。

csapp太难了！😥

## 3.5

今天继续吧。

1. boolean identities抄写
2. truth table -> boolean expression

今日总觉得很浮躁呢，周五就要去南京，准备呆到周三回来吧。

这样休息日不算的话，呆三天，带的衣服应该是够了：一件外套，一条裤子，三个背心。

带个笔记本吗？带的话意思就是需要看会学习的东西，带吧，但是自己的

现在要做的就是，学习，然后去迪卡侬买个登山包。

今日目标：

- [x] cs61a 1h(用时2h，卡在了Q2部分，对于递归算法仍不熟悉导致)

[cs61a暖心一刻](https://cs61a.org/disc/disc04/)：

> Recursion takes practice. Please don't get discouraged if you're struggling to write recursive functions. Instead, every time you do solve one (even with help or in a group), make note of what you had to realize to make progress. Students improve through practice and reflection.

Here's the path！

> ### Q2: Max Product
>
> Implement `max_product`, which takes a list of numbers and returns the maximum product that can be formed by multiplying together non-consecutive elements of the list. Assume that all numbers in the input list are greater than or equal to 1.

这是chatgpt的答案：

```py
def max_product(s):
    """Return the maximum product of non-consecutive elements of s.

    >>> max_product([10, 3, 1, 9, 2])   # 10 * 9
    90
    >>> max_product([5, 10, 5, 10, 5])  # 5 * 5 * 5
    125
    >>> max_product([])                 # The product of no numbers is 1
    1
    """
    def helper(index, current_product):
        
        # 递归基本情况：遍历完整个列表
        if index >= len(s):
            return current_product
        # 选择当前元素，继续递归
        with_current = helper(index + 2, current_product * s[index])
        # 不选择当前元素，继续递归
        without_current = helper(index + 1, current_product)
        # 返回两种选择中的较大值
        return max(with_current, without_current)
    
    # 从列表的第一个元素开始递归调用
    return helper(0, 1)
```

（3.8重新回顾代码）

根据[递归的三步走](https://algo.itcharge.cn/09.Algorithm-Base/02.Recursive-Algorithm/01.Recursive-Algorithm/#_3-%E9%80%92%E5%BD%92%E4%B8%89%E6%AD%A5%E8%B5%B0)的原则，梳理下这个代码的逻辑，主要是看看怎么将大问题化成小问题的？

乍一看代码真的难以理解：这个

```py
with_current = helper(index + 2, current_product * s[index])
```

为什么在当前索引`i`指到间隔元素`i + 2`的时候，就要将之前的索引`i`的元素乘上呢？😶

思考真的难受，因为没有思路！😥

那就着手简单点的，看看设定一个序列`s = [1, 2, 3, 4]`，`len(s) = 4`模拟执行下这个代码？

```
helper(0, 1)
	helper(2, 1*s[0]) 
		helper(4, 1*s[0]*s[2]) ------------ 3
		helper(3, 1*s[0])
			helper(5, 1*s[0]*s[3]) -------- 4
			helper(4, 1*s[0]) ------------- 1
			return max(4, 1)--------------- 4
		return max(3, 4)------------------- 4
	helper(1,1)
		helper(3, 1*s[1])
```

ok，我现在执行了`s[0]*s[2]`和`s[0]*s[3]`即从首元素开始不间隔的元素乘积。

它怎么做到的？询问下chat-gpt：

> 在这里，`current_product` 表示截止到当前元素的乘积，而 `s[index]` 表示当前元素的值。但是，乘法操作是在下一个不相邻元素的索引位置 `index + 2` 进行的，而不是在当前元素的位置。

ok，现在用时1h，还是没想清楚。。。

行吧，今晚去万达想买个书包来着，觉得迪卡侬不值当的就没上车。

回来想修改下空洞的金币呢，没想到把游戏数据改了，直接5h存档丢失！

睡觉，明天跑步~

## 3.6

今早跑了15km，回来力量训练，又是自律的一天！😄

早晨开了一小时去回顾cs61a的`disc 4`的`solutions`，发现自己对于递归还是掌握的一般雕花啊，第二、三个题目直接不知道咋做。😢

前面的提示给我安慰：

> Recursion takes practice. Please don't get discouraged if you're struggling to write recursive functions. Instead, every time you do solve one (even with help or in a group), make note of what you had to realize to make progress. Students improve through practice and reflection.

不断反思自己哪里能进步，并且做好记录吧。

看了一下午的NandToTetris。明天应该能

完蛋，csapp的第一题用的数理逻辑，根本不会。太累了，睡觉！

## 3.7

距离出发还有一天。

CS61A破冰：

- [x] cs61a浏览一遍第三章（25mins）
- [x] 浏览昨天的题目（5mins）
- [x] 浏览一遍cats项目题目（25mins）

今天cs61a首要任务就是将cats的项目规划看一下，梳理下要做什么。

完成Phase 1：Typing的项目，下楼拿个快递，回来开始csapp。

## 3.8

so baby have good night~

南京之旅开始😎

现在是在G1737的列车上把代码拉下来，用LG gram编写的。

今天的任务：

- [x] 浏览递归部分代码和解决思路（25mins）
- [ ] NandToTetris：用Nand实现“与或非”HDL设计逻辑（2h）

## 3.11

ok，过了很开心的两天。

行动吧，都是答案。

3-12月，9个月时间，（平均）每天学习6h来算的话，应该有1600h左右的时间可供支配。

# TheWay2Hacker

coding

## 阶段一

打基础。

主要涉及两个方面，一个是代码质量和设计，代表课程是cs61a。预计时间为一个月（因为已经过去一个月了）。

另一个是步入下一阶段的先导课，是为了进入更底层视角的铺垫，csapp和NandToTetris。每周一个lab，一共7个lab，预计时间为两个半月；另一个是NandToTetris，主要目的是对计算机底层进一步熟悉，并且课程难度较为简单，目标就是模拟一个计算机。预计一个半月。

这样时间基本定好，就是4月15号，完成cs61a和NandToTetris。csapp是6月1号完成，建议直接发朋友圈ddl。

## 阶段二

“程序设计 = 算法 + 数据结构”

本阶段是以java为基础，写cs61b（60h~~约等于三周，截止时间为6月25号）和Coursera: Algorithms I & II（共计6周，截止时间为7月20号）。

体系结构：cs61c--两个月（截止时间为7月20号）

最重要的是，c++开始。（如何开始？）

## 阶段三

到了这里就是8月份了，还剩下4个月的时间。

阶段一二完成后，基本掌握了代码开发的规则和算法思想，代码质量显著提升，对于计算机底层理解更为深入。

另一个就是利用计算机工具的能力越来越强，shell脚本、gdb调试等很熟练。

下一步就是利用上面所学的知识，开始进行大项目归并。

首先就是os：MIT 6.S081，预计用时200h，接近4个月

另一个就是db：CMU 15-445: Database Systems，先修是C++，数据结构与算法，CMU 15-213（csapp），实现一个面向磁盘的传统关系型数据库 Bustub 中的部分关键组件。

快6点了，今晚汉堡王，先看看地点。日后再同步到博客园中。😉

3月11号是我人生最幸福的一天!🥰

## 3.12

- [ ] cs61a 2h

  - [x] 阅读之前代码
  - [x] 概览阅读Phase 2: Autocorrect问题描述
  - [x] 对比代码看要求

  稍微理解了下代码的操作，包含

- [ ] csapp 2h

心里有点乱。

四点去配钥匙。

一小时时间，看看如何将阶段2问题分解为流程图。（画出demo）

