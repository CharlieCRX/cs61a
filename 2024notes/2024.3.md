# 3月份日报

## 3.1

今天就是3月的第一天了！早上跑了10k，结果vivo健康的计算出了些问题，不知道后台是否被杀了，有段距离直接没记录。

昨天看了宫崎骏动漫：鲁邦三世，感觉这哥们很有魅力！挺喜欢！

ok，今天要做什么呢？

1. 1h过一遍cs61a材料1.6-2.7（侧重点：简单整理下结构和需要认真对待的背景知识）
2. 抄一遍2.3节`完美数`、`定面积求最小周长`、`链表`代码，并且单步执行
3. 抄一遍2.4节`可变链表`、`字典实现`、`调度字典`代码并且单步执行
4. 抄写连接器部分代码

------

# CS61A阅读指南

写一下关于[cs61a课本](https://www.composingprograms.com/)的阅读指南，方便同志们更高效地阅读cs61a。

## 为什么要写这个？

初学这些知识的时候，总会觉得自己很努力但是学的不明不白，而且经常会被一些不了解的概念卡住，阅读体验极差☹。

后来在[《为什么学生不喜欢上学》](https://book.douban.com/subject/4864832/)和 [你有什么值得分享的高效学习方法？ - howhowfire的回答 - 知乎](https://www.zhihu.com/question/50343728/answer/184657839)里面作者如何规划理科学习的部分，窥探了为什么学的这么痛苦：

> 学习中的困难，要么源于主动思维过难，超出了学习者能力所及的范围，要么源于主动思维时间过长，超出了学习者意志力的承受范围。熟悉了，才能理解概念，然后运用概念。

根据这本书和知乎大佬的回答，我慢慢摸索到了新手学习cs61a的关键：

1. 了解材料涉及的背景知识
2. 熟悉材料的结构，理解每一节为什么这么设计的，以及大体设计了什么
3. 熟悉材料的代码

在通篇阅读cs61a材料之前，python新手至少需要对上面三个知识点达到了解甚至熟悉的程度，否则零基础阅读文档时会异常痛苦。

而本文就是将1和2涉及的内容写下来，方便新手同志们获得更好地阅读体验。这里从1.6节开始的理由很简单：因为前面的知识很简单，你只需要认真阅读就可以，不需要另外的背景知识作为补充，也不需要提纲挈领统揽全局。

> [!IMPORTANT]
>
> 本文并不是cs61a的阅读笔记，而是作为新人阅读cs61a材料之前的`导学案`，是为了让同志们更好地阅读cs61a的。
>
> 这个文章存在的根本原因，就是cs61a的阅读材料默认新人有较强背景知识储备，但是实际上对于我们大一新生来说，很多背景知识（类似于树、链表等数据结构和面向对象的思想）都是不具备的。
>
> 我相信在阅读cs61a材料前，先将这篇帖子阅读完并且认真理解了里面涉及到的概念术语，等到开始阅读cs61a的时候，你会感到无比愉悦。

欢迎同志们的讨论和指点！

## CS61A 导学案

### 1.6 函数

1. “用户定义函数（user-defined functions）”作为一种数值运算的抽象模式，从而使它们与涉及的特定数字无关
2. 高阶函数：用一些函数来表达计算的通用方法（general methods），而且和它们调用的特定函数无关
3. 通用方法`def improve(update, close, guess=1)`
4. 嵌套定义解决帧混乱和参数限制的问题
5. 背景：利用平均值近似计算一个数的平方根
6. 作为返回值的函数
7. 背景：`牛顿法`的概念和具体实现
8. 用函数具体实现`牛顿法`的思想：迭代改进算法
9. Lambda 表达式

### 1.7 递归

1. 背景：递归函数
2. 递归举例`sum_digits(n):"""返回正整数 n 的所有数字位之和"""`
3. 背景：递归函数的理解
4. 理解举例：递归调用时栈帧变化+打印字符`cascade(n)`
5. 树递归：单个函数进行多个递归调用

### 2.2 数据抽象

1. 概念：为什么要数据抽象？数据抽象的基本思想是？（首先粗略了解，下面案例会帮助理解）
2. 举例：有理数的抽象表示-`rational(n, d)`，`numer(x)`,`denom(x)`。
3. 列表的索引
4. 抽象屏障的意义：分析上面有理数的抽象表示
5. 如何构建一个数据抽象：使用选择器和构造器的集合以及一些行为条件 - 函数 `pair` 和 `select` 

### 2.3 序列

本节根据序列（数据）的基本属性，自己动手实现一个链表，延伸数据抽象的概念。

1. 概念：序列是什么？

2. python内置的序列结构- 列表（list）以及常用方法

3. `count(s, value)`：如何遍历序列

4. 概念：序列处理。包括列表推导式（提供了从序列创建列表的简单途径）、 聚合（将序列中的所有值聚合为一个值）和高阶函数

5. 概念：完美数

6. 序列处理实例1：利用list类型，获取从1到n的完美数`divisors(n)`。

7. 序列处理实例2：定面积下计算只有整数边长的矩形的最小周长

8. 序列处理实例3：高阶函数来寻找完美数

    至此，介绍完毕序列相关属性和对应的常用操作，下面介绍如何对序列这样的数据进行抽象

9. 概念：什么是有用的序列抽象？（序列有用的行为包括哪些？）

10. 概念：数据的闭包属性

11. 概念：[树的概念](https://algo.itcharge.cn/07.Tree/01.Binary-Tree/01.Binary-Tree-Basic/)、树递归和分割树

12. 树的实例1：代码实现构造函数 `tree`、选择器 `label` 和 `branches` （想要理解函数具体功能，必须提前理解[树的概念](https://algo.itcharge.cn/07.Tree/01.Binary-Tree/01.Binary-Tree-Basic/)）

13. 树的实例2：树递归`fib_tree(n)`，用于构造树；`count_leaves` 函数计算树的叶子数

14. 树的实例3：分割树`partition_tree(n, m)`，返回将 n 分割成不超过 m 的若干正整数之和的分割树

15. 概念：[链表](https://algo.itcharge.cn/02.Linked-List/01.Linked-List-Basic/01.Linked-List-Basic/)

16. 链表实例1：实现基本抽象，包括`is_link(s)`、`link(first, rest)`、`first(s)`、`rest(s)`。

17. 链表实例2：实现满足序列抽象的条件，包括长度`len_link(s)`和数据选择`getitem_link(s, i)`，同时介绍了利用递归实现的思路

18. 链表实例3：利用递归构造，递增地构造序列。`partitions(n, m)`

### 2.4 可变数据

对象统领函数和数据。这一节开始，就要介绍关于“面向对象”的问题了，所以需要了解下[什么是面向对象](https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1)

1. 面向对象编程的核心

2. 序列对象“扑克牌”

3. 字典概念

4. 函数状态：举例取钱函数`withdraw`及其调用过程

   上面重要的概念就是关于函数的状态，下面紧接着就举例子来实践这个概念

5. 可变列表和字典实现：`to_mutable_link(source)`和`def dictionary()`

6. 概念：消息传递。一个函数A中集成了多个函数1、2、3...，调用其中的函数时，用不同的消息区分。这个函数A就利用调度函数（dispatch functions）来操作这些消息，以实现调用内置函数1、2、3...的操作。

7. 调度字典的概念和实现` account (initial_balance)`

8. 约束传递

   1. 概念
   2. 例子：华氏温度和摄氏温度之间的关系`9 * c = 5 * (f - 32)`
   3. 实例：实现一个约束系统来换算温度（代码很庞大，需要认真理解，没有捷径）

### 2.5 面向对象编程

暂时写到这里，日后再更。欢迎同志们讨论！😉

